; $.JSW1   001100 002f7e
;
; Reassembly by TobyLobster, 2021
;

; game constants

; Proper start position
player_start_room                                   = 21        ; 21 = The Bathroom
player_start_x                                      = 20 * 8    ;
player_start_y                                      = 13 * 8    ;

;player_start_room                                   = 20        ;
;player_start_x                                      = 20 * 8     ; must be even!
;player_start_y                                      = 10 * 8    ;

; Tree Root
;player_start_room                                   = 60        ;
;player_start_x                                      = 23 * 8 - 2     ; must be even!
;player_start_y                                      = 11 * 8    ;

; West of Kitchen
;player_start_room                                   = 34        ;
;player_start_x                                      = 11 * 8     ; must be even!
;player_start_y                                      = 1 * 8    ;



; ***************************************************************************************
; os variables
irq_accumulator                                     = $fc
irq1_vector_low                                     = $0204
irq1_vector_high                                    = $0205

crtcAddressRegister                                 = $fe00     ;
crtcAddressWrite                                    = $fe01     ;

; ***************************************************************************************
; Video ULA Register
;         bits 765: determines cursor width
;         bit    4: 0 = 40 bytes per scan line, 1 = 80 bytes per scan line
;         bits  32: number of columns (%00=10 columns, %01=20, %10=40, %11=80)
;            bit 1: teletext (1=enabled, 0=disabled)
;            bit 0: current flashing colour state
videoULARegister                                    = $fe20
videoULAPaletteRegister                             = $fe21     ; Video ULA palette register

ROMSEL                                              = $fe30     ; ROM Select (Master)

; ***************************************************************************************
; Write to System VIA, register B
; On Entry:
;     Interrupts must already be disabled
;     A = value to write (0-15)
;
; Notes:
;     Values 0-15 can be written to System VIA Port B:
;
;         Value   Effect
;         -------------------------
;         0       Enable sound chip
;         1       Disable Read Speech
;         2       Disable Write Speech
;         3       Disable Keyboard write
;         4       Hardware scrolling - set C0=0 (See below)
;         5       Hardware scrolling - set C1=0 (See below)
;         6       Turn on Caps LED
;         7       Turn on Shift LED
;         8       Disable sound chip
;         9       Enable Read Speech
;         10      Enable Write Speech
;         11      Enable Keyboard write
;         12      Hardware scrolling - set C0=1 (See below)
;         13      Hardware scrolling - set C1=1 (See below)
;         14      Turn off Caps LED
;         15      Turn off Shift LED
;
; If C0=0 and C1=1 then hardware scrolling starts at $5800
;
systemVIADataDirectionRegisterA                     = $fe43     ; System VIA data direction register A (DDRA)
systemVIARegisterANoHandshake                       = $fe4f     ; System VIA Register A without handshaking

systemVIARegisterB                                  = $fe40     ;
systemVIAInterruptFlagRegister                      = $fe4d     ;

systemVIATimer1CounterLow                           = $fe44     ;
systemVIATimer1CounterHigh                          = $fe45     ;
systemVIATimer1LatchLow                             = $fe46     ;
systemVIATimer1LatchHigh                            = $fe47     ;
systemVIAAuxiliaryControlRegister                   = $fe4b     ;
systemVIAInterruptFlagRegister                      = $fe4d     ;
systemVIAInterruptEnableRegister                    = $fe4e     ;


userVIATimer1CounterLow                             = $fe64     ; Timer 1 counter (low)
userVIATimer1CounterHigh                            = $fe65     ; Timer 1 counter (high)
userVIATimer1LatchLow                               = $fe66     ; Timer 1 latch (low)
userVIATimer1LatchHigh                              = $fe67     ; Timer 1 latch (high)
userVIAAuxiliaryControlRegister                     = $fe6b     ; auxiliary control register
userVIAInterruptFlagRegister                        = $fe6d     ; Interrupt flag register
userVIAInterruptEnableRegister                      = $fe6e     ; Interrupt enable register

OSBYTE                                              = $fff4     ; used during program initialization only

; physical colours
black = 0
red = 1
green = 2
yellow = 3
blue = 4
magenta = 5
cyan = 6
white = 7

; ***************************************************************************************
; This is the number of timer ticks per frame (num PAL scanlines * 64us/line)
; This timing is only true of non-interlaced modes.
; We have to subtract 2 because the latch reload costs 2us.
; This is not documented anywhere!
FramePeriod     = 312*64-2

; Calculate here the timer value to interrupt at the desired line
Timer1Value      = 76*64 + 39

; This is the delay between interrupts (one character row = 8 pixel rows)
ShortTimerValue  = 8*64 - 2

; game variables (memory locations)
irq_counter                                         = $00
vsync_counter                                       = $01
is_master                                           = $02
text_screen_low                                     = $03
text_screen_high                                    = $04
text_colour_mask                                    = $05
old_romsel                                          = $06
character_definitions_low                           = $07
character_definitions_high                          = $08
temp1                                               = $09
temp2                                               = $0a
temp3                                               = $0b
temp4                                               = $0c
temp5                                               = $0d
minutes_low                                         = $0e
minutes_high                                        = $0f
hours_low                                           = $10
hours_high                                          = $11
time_fraction                                       = $12
items_collected_low                                 = $13
items_collected_high                                = $14
first_sound_byte                                    = $15
second_sound_byte                                   = $16
music_enabled                                       = $17
game_over_timer                                     = $18

; sound variables
sound_variables_start                               = $19
sound_counters                                      = $19
sound_counters_1                                    = $1a
sound_counters_2                                    = $1b
sound_counters_3                                    = $1c
pitch_low                                           = $1d
pitch_low_1                                         = $1e
pitch_low_2                                         = $1f
pitch_low_3                                         = $20
pitch_high                                          = $21
pitch_high_1                                        = $22
pitch_high_2                                        = $23
pitch_high_3                                        = $24
sound_duration_for_channel_x                        = $25
sound_duration_for_channel_x_1                      = $26
sound_duration_for_channel_x_2                      = $27
sound_duration_for_channel_x_3                      = $28
pitch_increment_for_channel_x                       = $29
pitch_increment_for_channel_x_1                     = $2a
pitch_increment_for_channel_x_2                     = $2b
pitch_increment_for_channel_x_3                     = $2c
melody_note_volume                                  = $2d
sound_variables_end                                 = $2d

; $2e unused

; player state on entry into the current room (reset to these values on death)
entry_horizontal_speed                              = $2f
entry_jump_timer                                    = $30
entry_x                                             = $31
entry_y                                             = $32
entry_is_jumping                                    = $33

temp_high                                           = $34
note_number                                         = $35

; initialised values
life_y                                              = $4d
space_tile                                          = $4e
swimming_pool_item_collected                        = $4f
room_data_address                                   = $50
room_data_address_low                               = $50
room_data_address_high                              = $51
room_data_offset                                    = $52
bits_remaining_in_room_data_byte                    = $53
room_data_byte                                      = $54
player_room                                         = $55
pages_of_tile_table_remaining_when_finding_conveyor = $56
game_timer                                          = $57
conveyor_length                                     = $58
conveyor_screen_address_low                         = $59
conveyor_screen_address_high                        = $5a
rope_position_relative_to_centre                    = $5b
rope_velocity_relative_to_centre                    = $5c
rope_end_x                                          = $5d
rope_end_y                                          = $5e
rope_position                                       = $5f
tile_address_low1                                   = $60
tile_address_high1                                  = $61
where_player_fell_from                              = $62
player_killed                                       = $63
player_is_jumping                                   = $64
player_jump_timer                                   = $65
items_in_room_minus_one                             = $66
item_number                                         = $67
tile1                                               = $68
player_conveyor_direction                           = $69
conveyor_direction                                  = $6a
player_on_slope                                     = $6b
slope_direction                                     = $6c
do_triangle_ends                                    = $6d
length1                                             = $6e
room_contains_rope                                  = $6f
x1                                                  = $70
tile_x                                              = $70
scrolltext_address_low                              = $70
timer_one                                           = $70
y                                                   = $71
tile_y                                              = $71
scrolltext_address_high                             = $71
timer_two                                           = $71
tile_type                                           = $72
scrolltext_offset                                   = $72
conveyor_colour_eor                                 = $73
length2                                             = $74
start_x                                             = $75
previous_x                                          = $75
height1                                             = $76
previous_y1                                         = $76
x_delta                                             = $77
y_delta                                             = $78
width                                               = $79
enemy_to_consider1                                  = $79
count                                               = $7a
number_of_frames                                    = $7a
block_y_delta                                       = $7a
rope_pixel_to_consider                              = $7a
row_length                                          = $7a
item_state                                          = $7b
previous_speed                                      = $7b
enemy_x                                             = $7b
next_y                                              = $7b
sprite_frames                                       = $7b
tmp                                                 = $7b
next_tile_offset                                    = $7b
conveyor_sections_remaining_to_update               = $7b
tile2                                               = $7b
life_colour                                         = $7b
player_y_fraction                                   = $7b
mod_three                                           = $7b
previous_tile_address_low                           = $7b
rope_pixel_touched                                  = $7b
blocks_to_copy                                      = $7b
direction                                           = $7c
triangle_direction                                  = $7d
x_skip                                              = $7e
triangle_length                                     = $7f
height2                                             = $80
room                                                = $81
conveyor_colour                                     = $81
previous_y2                                         = $81
previous_tile_type                                  = $81
add_first_and_last                                  = $82
direction_base                                      = $83
unpacked_sprite_address_low                         = $84
unpacked_sprite_address_high                        = $85
unpacked_sprite_offset                              = $86
enemies_on_screen                                   = $87
unpacked_byte_two                                   = $88
sprite_colour                                       = $89
sprite_colour_eor                                   = $8a
enemy_to_consider2                                  = $8b
player_started_jump                                 = $8c
player_x                                            = $8d
player_y                                            = $8e
player_horizontal_speed                             = $8f
sprite_address_low1                                 = $90
tile_address_low2                                   = $90
sprite_address                                      = $90
rope_pixels_screen_address_low                      = $90
tile_address2                                       = $90
screen_address_low                                  = $90
rope_pixels_screen_address_high                     = $91
tile_address_high2                                  = $91
sprite_address_high1                                = $91
screen_address_high                                 = $91
sprite_address_low2                                 = $92
sprite_address_high2                                = $93
sprite_size_in_bytes                                = $94
sprite_width                                        = $95
rows_to_check                                       = $96
previous_sprite_address_high                        = $96
packed_byte1                                        = $96
x2                                                  = $96
value                                               = $96
rope_pixel_position                                 = $96
arrow                                               = $96
lives_remaining_to_plot                             = $96
times_three                                         = $96
walls                                               = $96
buffer_offset                                       = $97
previous_sprite_address_low                         = $97
life_x                                              = $97
buffer_y                                            = $97
invert                                              = $97
start_of_word                                       = $97
bit_for_item                                        = $97
rope_pixel_x                                        = $97
packed_byte2                                        = $97
seven                                               = $98
melody_active                                       = $99
player_entered_room_falling_too_far                 = $9a
player_lives                                        = $9b
player_not_plotted                                  = $9c
out_of_time                                         = $9d
house_clear                                         = $9e
player_rope_pixel                                   = $9f

title_text_source_low                               = $a0
title_text_source_high                              = $a1
title_text_destination_low                          = $a2
title_text_destination_high                         = $a3
title_text_loop_counter                             = $a4

screen_memory_start                                 = $5600
screen_address_title                                = screen_memory_start + 16 * $0200  ; row 16
text_message_address                                = screen_memory_start + 20 * $0200  ; row 20

* = $1100

!pseudopc $0208 {
; ***************************************************************************************
initialise_room
    jsr initialise_room_data                        ;
    jsr initialise_enemies                          ;
    jsr initialise_arrows                           ;
    jmp calculate_screen_address_of_conveyor        ;

; ***************************************************************************************
initialise_room_data
    lda #0                                          ;
    sta room_data_offset                            ;
    sta bits_remaining_in_room_data_byte            ;
    sta player_rope_pixel                           ;
    sta rope_position_relative_to_centre            ;
    sta game_timer                                  ;
    ldx player_room                                 ;
    jsr calculate_room_data_address                 ;
    jsr clear_screen                                ;
    jsr initialise_room_items_and_exits             ;
    jsr initialise_room_background_tiles_and_title  ;
    lda #$ff                                        ;
    sta item_number                                 ;
    lda #$d2                                        ;
    sta rope_position                               ;
    lda #1                                          ;
    sta rope_velocity_relative_to_centre            ;
    sta player_not_plotted                          ; Mark player as not needing to be unplotted
    lda out_of_time                                 ;
    sta player_killed                               ;
    lda player_horizontal_speed                     ; Store how player entered room
    sta entry_horizontal_speed                      ;
    lda player_jump_timer                           ;
    sta entry_jump_timer                            ;
    lda player_x_in_enemies                         ;
    sta entry_x                                     ;
    lda player_y_in_enemies                         ;
    sta entry_y                                     ;
    sta where_player_fell_from                      ;
    lda player_is_jumping                           ;
    sta entry_is_jumping                            ;
    lda #0                                          ;
    sta tile_x                                      ;
    sta tile_y                                      ;
    sta tile_type                                   ;
    jsr write_status_line                           ;
    jsr wipe_tile_table                             ;
initialise_background_scenery_loop
    ldy #$ff                                        ;
calculate_routine_number_loop                       ; Reading two bits at a time, count 11 as meaning +3
    iny                                             ;
    ldx #2                                          ;
    jsr get_x_bits_of_room_data                     ;
    cmp #3                                          ;
    beq calculate_routine_number_loop               ;
    sta mod_three                                   ;
    sty times_three                                 ;
    tya                                             ;
    asl                                             ;
    asl                                             ;
    adc mod_three                                   ;
    sec                                             ;
    sbc times_three                                 ;
    cmp #6                                          ;
    beq leave8                                      ;
    asl                                             ;
    tax                                             ;
    lda background_initialisation_routines_address_table,X      ;
    sta background_initialisation_routine_address_low           ;
    lda background_initialisation_routines_address_table + 1,X  ;
    sta background_initialisation_routine_address_high          ;

background_initialisation_routine_address_low = * + 1
background_initialisation_routine_address_high = * + 2
    jsr $ffff                                       ; [overwritten before use] JSR background_initialisation_routine_address
    jmp initialise_background_scenery_loop          ;
null_routine
leave8
    rts                                             ;

; ***************************************************************************************
get_x_bits_of_room_data
    sty tmp                                         ;
    lda #0                                          ;
    sta value                                       ;
get_x_bits_of_room_data_loop
    dec bits_remaining_in_room_data_byte            ;
    bpl bits_still_remaining                        ;
    lda #7                                          ;
    sta bits_remaining_in_room_data_byte            ;
    ldy room_data_offset                            ;
    lda (room_data_address),Y                       ;
    sta room_data_byte                              ;
    inc room_data_offset                            ;
bits_still_remaining
    lsr room_data_byte                              ;
    rol value                                       ;
    dex                                             ;
    bne get_x_bits_of_room_data_loop                ;
    ldy tmp                                         ;
    lda value                                       ;
    rts                                             ;

; ***************************************************************************************
background_initialisation_routines_address_table
    !word set_tile_type                             ; 0 00
    !word set_tile_x_and_y                          ; 1 01
    !word add_straight_line_of_tiles                ; 2 10
    !word add_block_of_tiles                        ; 3 11 00
    !word add_series_of_tiles                       ; 4 11 01
    !word add_diagonal_line_of_tiles                ; 5 11 10
    !word null_routine                              ; 6 11 11 00
    !word null_routine                              ; 7 11 11 01 - [unused]
    !word add_triangle_of_tiles                     ; 8 11 11 10

; ***************************************************************************************
set_tile_type
    ldx #3                                          ; Get three bits of room data for tile type
    jsr get_x_bits_of_room_data                     ;
    sta tile_type                                   ;
    rts                                             ;

; ***************************************************************************************
set_tile_x_and_y
    ldx #5                                          ; Get five bits of room data for x position
    jsr get_x_bits_of_room_data                     ;
    sta tile_x                                      ;
    ldx #4                                          ; Get five bits of room data for y position
    jsr get_x_bits_of_room_data                     ;
    sta tile_y                                      ;
    rts                                             ;

; ***************************************************************************************
add_straight_line_of_tiles
    lda #1                                          ; Add first and last tiles
    ldx #0                                          ; Get one bit of room data for direction
    ldy #5                                          ; Get five bits of room data for length of run
    jsr add_line_of_tiles                           ;
    rts                                             ;

; ***************************************************************************************
add_diagonal_line_of_tiles
    lda tile_type                                   ;
    sta previous_tile_type                          ;
    lda #2                                          ; SLOPE
    sta tile_type                                   ;
    lda #1                                          ; Add first and last tiles
    ldx #8                                          ; Get one bit of room data for diagonal direction
    ldy #4                                          ; Get four bits of room data
    jsr add_line_of_tiles                           ;
    lda previous_tile_type                          ;
    sta tile_type                                   ;
    lda tile_x                                      ;
    clc                                             ;
    adc x_delta                                     ;
    sta tile_x                                      ;
    rts                                             ;

; ***************************************************************************************
add_series_of_tiles
    ldx #4                                          ;
    jsr get_x_bits_of_room_data                     ; Get four bits of room data for number of tiles
    sta length1                                     ;
add_series_of_tiles_loop                            ; For each tile,
    ldx #5                                          ;
    jsr get_x_bits_of_room_data                     ; Get five bits of room data for x co-ordinate
    sta tile_x                                      ;
    ldx #4                                          ;
    jsr get_x_bits_of_room_data                     ; Get four bits of room data for y co-ordinate
    sta tile_y                                      ;
    jsr add_background_tile                         ;
    dec length1                                     ;
    bpl add_series_of_tiles_loop                    ;
    lda #0                                          ;
    sta tile_x                                      ;
    sta tile_y                                      ;
    rts                                             ;

; ***************************************************************************************
add_block_of_tiles
    ldx #5                                          ;
    jsr get_x_bits_of_room_data                     ; Get five bits of room data for width of block
    sta width                                       ;
    lda tile_x                                      ;
    sta start_x                                     ;
    lda tile_y                                      ;
    sta height1                                     ;
    ldx #4                                          ;
    jsr get_x_bits_of_room_data                     ; Get four bits of room data for y end
    sta tile_y                                      ;
    lda height1                                     ;
    sec                                             ;
    sbc tile_y                                      ;
    ldx #1                                          ;
    bcs skip_inversion2                             ;
    eor #$ff                                        ;
    adc #1                                          ;
    ldx #$ff                                        ;
skip_inversion2
    sta height1                                     ;
    stx block_y_delta                               ;
add_block_of_tiles_loop
    lda #0                                          ; Add tiles from left to right
    sta direction                                   ;
    lda width                                       ;
    sta length2                                     ;
    lda start_x                                     ;
    sta tile_x                                      ;
    lda #1                                          ; Add first and last tiles
    ldx #$80                                        ; Use previous direction
    jsr add_line_of_tiles                           ;
    lda tile_y                                      ;
    clc                                             ;
    adc block_y_delta                               ;
    sta tile_y                                      ;
    dec height1                                     ;
    bpl add_block_of_tiles_loop                     ;
    lda tile_y                                      ;
    sec                                             ;
    sbc block_y_delta                               ;
    sta tile_y                                      ;
    lda tile_x                                      ;
    clc                                             ;
    adc x_delta                                     ;
    sta tile_x                                      ;
    rts                                             ;

; ***************************************************************************************
add_triangle_of_tiles
    lda tile_x                                      ;
    sta previous_x                                  ;
    lda tile_y                                      ;
    sta previous_y1                                 ;
    ldx #1                                          ;
    jsr get_x_bits_of_room_data                     ; Get one bit of room data for triangle direction
    ldx #1                                          ;
    stx do_triangle_ends                            ;
    sta triangle_direction                          ;
    tay                                             ;
    beq skip_x_inversion                            ;
    ldx #$ff                                        ;
skip_x_inversion
    stx x_skip                                      ;
    ldx #4                                          ;
    jsr get_x_bits_of_room_data                     ; Get four bits of room data for triangle height
    sta row_length                                  ;
    sta triangle_length                             ;
    sec                                             ;
    sbc tile_y                                      ;
    sta height2                                     ;
    bcs skip_y_inversion                            ;
    eor #$ff                                        ;
    adc #1                                          ;
    sta height2                                     ;
    dec do_triangle_ends                            ;
    lda row_length                                  ;
    ldx tile_y                                      ;
    sta tile_y                                      ;
    stx row_length                                  ;
    jmp add_triangle_of_tiles_loop                  ;
skip_y_inversion
    ldx height2                                     ;
    lda x_skip                                      ;
    eor #$ff                                        ;
    adc #0                                          ;
    sta x_skip                                      ;
    bmi +                                           ;
    txa                                             ;
    eor #$ff                                        ;
    tax                                             ;
    inx                                             ;
+
    txa                                             ;
    clc                                             ;
    adc tile_x                                      ;
    sta tile_x                                      ;
add_triangle_of_tiles_loop
    lda #1                                          ; Add tiles from right to left
    sta direction                                   ;
    lda row_length                                  ;
    sta length2                                     ;
    lda tile_y                                      ;
    sta previous_y2                                 ;
    lda #1                                          ; Add first and last tiles
    ldx #$80                                        ; Use previous direction
    jsr add_line_of_tiles                           ;
    lda previous_y2                                 ;
    sta tile_y                                      ;
    lda tile_x                                      ;
    clc                                             ;
    adc x_skip                                      ;
    sta tile_x                                      ;
    dec row_length                                  ;
    dec height2                                     ;
    bpl add_triangle_of_tiles_loop                  ;
    lda previous_x                                  ;
    sta tile_x                                      ;
    lda previous_y1                                 ;
    sta tile_y                                      ;
    lda triangle_direction                          ;
    sta direction                                   ;
    lda triangle_length                             ;
    sta length2                                     ;
    lda tile_type                                   ;
    sta previous_tile_type                          ;
    lda #2                                          ; WALL
    sta tile_type                                   ;
    lda triangle_direction                          ; Determine whether to add first and last tiles
    eor slope_direction                             ; based on whether triangle faces same as room slope
    eor do_triangle_ends                            ;
    ldx #$88                                        ; Use previous diagonal direction
    jsr add_line_of_tiles                           ;
    lda previous_tile_type                          ;
    sta tile_type                                   ;
    lda tile_x                                      ;
    clc                                             ;
    adc x_delta                                     ;
    sta tile_x                                      ;
    rts                                             ;

; ***************************************************************************************
;
; On Entry:
;   X is the base direction
;
; Directions are:
;   0 = right
;   1 = up
;   2 = left
;   3 = down
;   8 = right and up diagonal
;   9 = left and up diagonal
;  10 = right and down diagonal
;  11 = left and down diagonal
;
; ***************************************************************************************
add_line_of_tiles
    sta add_first_and_last                          ;
    stx direction_base                              ;
    txa                                             ;
    bmi use_previous_direction                      ;
    ldx #1                                          ;
    jsr get_x_bits_of_room_data                     ;
    sta direction                                   ;
    tya                                             ;
    tax                                             ;
    jsr get_x_bits_of_room_data                     ;
    sta length2                                     ;
use_previous_direction
    lda direction_base                              ;
    ldx tile_y                                      ;
    and #$7f                                        ;
    clc                                             ;
    adc direction                                   ;
    sta direction                                   ;
    bne vertical_line                               ;
    ldx tile_x                                      ;
vertical_line
    lda length2                                     ;
    stx tmp                                         ;
    sec                                             ;
    sbc tmp                                         ;
    bcs skip_inversion3                             ;
    eor #$ff                                        ;
    clc                                             ;
    adc #1                                          ;
    inc direction                                   ;
    inc direction                                   ;
skip_inversion3
    sta length2                                     ;
    beq add_last_tile                               ;
    ldx direction                                   ;
    lda directions_x,X                              ;
    sta x_delta                                     ;
    lda directions_y,X                              ;
    sta y_delta                                     ;
add_line_of_tiles_loop
    lda add_first_and_last                          ;
    beq skip_first                                  ;
    jsr add_background_tile                         ;
skip_first
    lda tile_x                                      ;
    clc                                             ;
    adc x_delta                                     ;
    sta tile_x                                      ;
    lda tile_y                                      ;
    clc                                             ;
    adc y_delta                                     ;
    sta tile_y                                      ;
    dec length2                                     ;
    bne add_line_of_tiles_loop                      ;
add_last_tile
    lda add_first_and_last                          ;
    beq skip_last                                   ;
    jsr add_background_tile                         ;
skip_last
    rts                                             ;

; ***************************************************************************************
add_background_tile
    ldy tile_type                                   ;
    lda background_tiles_sprites,Y                  ;
    pha                                             ;
    ldx background_tiles_colours_fg,Y               ;
    lda background_tiles_colours_bg,Y               ;
    tay                                             ;
    pla                                             ;
    jsr plot_background_sprite                      ;
    jsr set_tile_table_for_background               ;
    rts                                             ;

directions_x
    !byte $01, $00, $ff, $00                        ;
directions_y
    !byte $00, $01, $00, $ff                        ;
diagonal_directions_x
    !byte $01, $ff, $01, $ff                        ;
diagonal_directions_y
    !byte $01, $01, $ff, $ff                        ;

; ***************************************************************************************
unpack_enemy_sprites
    lda #<unpacked_enemy_sprites                    ;
    sta unpacked_sprite_address_low                 ;
    lda #>unpacked_enemy_sprites                    ;
    sta unpacked_sprite_address_high                ;

    lda #8                                          ; The player sprite has 8 frames
    sta unpacked_sprite_offset                      ; skip over the player sprites
    lda enemies_on_screen                           ;
    sta enemy_to_consider1                          ;
    beq leave9                                      ; if (no enemies) then branch (return)
unpack_enemy_sprites_loop
    ldx enemy_to_consider1                          ;
    cpx enemies_on_screen                           ;
    beq first_enemy                                 ; If this isn't the first enemy,
    ldy enemies_on_screen                           ;
check_if_enemy_already_unpacked                     ; has its sprite already been used?
    lda enemies_sprite,Y                            ;
    cmp enemies_sprite,X                            ;
    bne different_sprite                            ;
    lda enemies_unpacked_sprite_offset,Y            ;
    sta enemies_unpacked_sprite_offset,X            ;
    bpl consider_next_enemy1                        ;
different_sprite
    dey                                             ;
    cpy enemy_to_consider1                          ;
    bne check_if_enemy_already_unpacked             ;
first_enemy                                         ; If not, unpack its sprite
    ldy enemies_sprite,X                            ;
    lda unpacked_sprite_offset                      ;
    sta enemies_unpacked_sprite_offset,X            ;
    lda enemy_sprites_frames,Y                      ;
    sta number_of_frames                            ;
    clc                                             ;
    adc unpacked_sprite_offset                      ;
    sta unpacked_sprite_offset                      ;
    lda enemy_sprites_frame_offsets,Y               ;
    lsr                                             ;
    ror tmp                                         ;
    lsr                                             ;
    ror tmp                                         ;
    lsr                                             ;
    ror tmp                                         ;
    clc                                             ;
    adc #>packed_enemy_sprites                      ;
    sta sprite_address_high1                        ;
    lda tmp                                         ;
    and #$e0                                        ; just the top three bits (frame_offset * 32)
    clc                                             ;
    adc #<packed_enemy_sprites                      ;
    sta sprite_address_low1                         ;
    bcc unpack_frames_loop                          ;
    inc sprite_address_high1                        ;
unpack_frames_loop
    jsr unpack_enemy_sprite                         ;
    dec number_of_frames                            ;
    bne unpack_frames_loop                          ;
consider_next_enemy1
    dec enemy_to_consider1                          ;
    bne unpack_enemy_sprites_loop                   ;
leave9
    rts                                             ;

; ***************************************************************************************
unpack_enemy_sprite
    ldy #0                                          ; loop counter for target (incrementing)
    ldx #31                                         ; loop counter for source (decrementing)
unpack_enemy_sprite_loop
    sty tempY                                       ;
    txa                                             ;
    tay                                             ;
    lda (sprite_address),Y                          ;
    jsr unpack_byte_of_sprite_data                  ;
    ldy unpacked_byte_two                           ;
    sta unpacked_byte_two                           ;
    tya                                             ;
tempY = * + 1
    ldy #$ff                                        ;
    sta (unpacked_sprite_address_low),Y             ;
    iny                                             ;
    lda unpacked_byte_two                           ;
    sta (unpacked_sprite_address_low),Y             ;
    iny                                             ;
    dex
    bpl unpack_enemy_sprite_loop                    ;

    lda sprite_address_low1                         ;
    clc                                             ;
    adc #32                                         ;
    sta sprite_address_low1                         ;
    bcc +                                           ;
    inc sprite_address_high1                        ;
+
    lda unpacked_sprite_address_low                 ;
    clc                                             ;
    adc #64                                         ;
    sta unpacked_sprite_address_low                 ;
    bcc +                                           ;
    inc unpacked_sprite_address_high                ;
+
    rts                                             ;

; ***************************************************************************************
unpack_byte_of_sprite_data
    sta packed_byte1                                ;
    and #$f0                                        ;
    sta tmp                                         ;
    lsr                                             ;
    lsr                                             ;
    lsr                                             ;
    lsr                                             ;
    ora tmp                                         ;
    sta unpacked_byte_two                           ;
    lda packed_byte1                                ;
    and #$0f                                        ;
    sta tmp                                         ;
    asl                                             ;
    asl                                             ;
    asl                                             ;
    asl                                             ;
    ora tmp                                         ;
    rts                                             ;

; ***************************************************************************************
;
; On Entry:
;  A holds the X coordinate in pixels
;  X holds the Y coordinate in pixels
;
; ***************************************************************************************
calculate_screen_address
    and #$fc                                        ; lose the lower two bits
    asl                                             ; shift up
    sta screen_address_low                          ; store
    rol screen_address_high                         ; carry into lower bit of high byte

    txa                                             ;
    and #7                                          ;
    clc                                             ;
    adc screen_address_low                          ;
    sta screen_address_low                          ;

    txa                                             ;
    lsr                                             ;
    lsr                                             ;
    lsr                                             ;
    tax                                             ; offset within table for start of row

    lda screen_address_high                         ;
    and #1                                          ;
    clc                                             ;
    adc screen_address_lookup_table,X               ;
    sta screen_address_high                         ;
    rts                                             ;

!if (<screen_memory_start != 0) {
    !error "Screen memory should be page aligned"
}

; ***************************************************************************************
plot_sprite
    jsr calculate_screen_address                    ;
    lda sprite_address_high2                        ;
    sta plot_sprite_address_high                    ;
    lda sprite_address_low2                         ;
    sta plot_sprite_address_low                     ;
    ldx sprite_size_in_bytes                        ;
plot_sprite_group_loop
    ldy sprite_width                                ;
    sec                                             ;

plot_sprite_loop
plot_sprite_address_low = * + 1
plot_sprite_address_high = * + 2
    lda $1111,X                                     ; [address overwritten before use: LDA plot_sprite_address,X]
    and sprite_colour                               ;
    sta (screen_address_low),Y                      ;
    dex                                             ;
    tya                                             ;
    sbc #8                                          ;
    tay                                             ;
    bcs plot_sprite_loop                            ;

    txa                                             ;
    bmi leave10                                     ;
plot_sprite_skipping_first_column
    inc screen_address_low                          ;
    lda screen_address_low                          ;
    bit seven                                       ;
    bne plot_sprite_group_loop                      ;
    sec                                             ;
    sbc #8                                          ;
    sta screen_address_low                          ;
    inc screen_address_high                         ;
    inc screen_address_high                         ;
    bpl plot_sprite_group_loop                      ;
leave10
    rts                                             ;

; ***************************************************************************************
calculate_background_sprite_address
    asl                                             ;
    rol sprite_address_high1                        ;
    asl                                             ;
    rol sprite_address_high1                        ;
    asl                                             ;
    rol sprite_address_high1                        ;
    clc                                             ;
    adc #<background_sprite_data                    ;
    sta sprite_address_low1                         ;
    lda sprite_address_high1                        ;
    and #7                                          ;
    adc #>background_sprite_data                    ;
    sta sprite_address_high1                        ;
    rts                                             ;

; ***************************************************************************************
;
; Plot an 8x8 sprite
;
; On Entry:
;
;   A is background sprite to draw
;   X is the foreground colour
;   Y is the background colour
;
; ***************************************************************************************
plot_background_sprite
    jsr calculate_background_sprite_address         ;
    lda colour_mask_values,X                        ;
    sta sprite_colour                               ;
    lda colour_mask_values,Y                        ;
    sta sprite_colour_eor                           ;
    eor sprite_colour                               ;
    sta sprite_colour                               ;
    ldy #7                                          ;
unpack_background_sprite_loop
    lda (sprite_address),Y                          ;
    jsr unpack_byte_of_sprite_data                  ;
    sta unpacked_background_sprite + 8,Y            ;
    lda unpacked_byte_two                           ;
    sta unpacked_background_sprite,Y                ;
    dey                                             ;
    bpl unpack_background_sprite_loop               ;
    lda #$0f                                        ;
    sec                                             ;
    sbc tile_y                                      ;
    asl                                             ;
    asl                                             ;
    asl                                             ;
    tax                                             ;
    lda tile_x                                      ;
    asl                                             ;
    asl                                             ;
    asl                                             ;
    jsr calculate_screen_address                    ;
    ldy #$0f                                        ;
plot_background_sprite_loop
    lda unpacked_background_sprite,Y                ;
    and sprite_colour                               ;
    eor sprite_colour_eor                           ;
    sta (screen_address_low),Y                      ;
    dey                                             ;
    bpl plot_background_sprite_loop                 ;
    rts                                             ;

; ***************************************************************************************
colour_mask_values
    !byte $00, $0f, $f0, $ff

; ***************************************************************************************
;
; On Entry:
;   X is the sprite number
;
; ***************************************************************************************
calculate_enemy_sprite_address
    ldy enemies_sprite,X                            ;
    cpy #$12                                        ;
    bne not_candelabra                              ;
    lda enemies_unpacked_sprite_offset,X            ;
    eor #1                                          ; Make candelabra flicker without moving
    sta enemies_unpacked_sprite_offset,X            ;
not_candelabra
    lda enemy_sprites_frames,Y                      ;
    sta sprite_frames                               ;
    lda enemies_direction,X                         ;
    bne enemy_moving_vertically                     ;

    ; Enemy moving horizontally                     ; For horizontally moving enemies,
    lda enemies_x,X                                 ; use the horizontal position to calculate frame
    and #7                                          ;
    lsr                                             ;
    ldy enemies_speed,X                             ;
    bmi calculate_frame                             ;
    clc                                             ;
    adc #4                                          ;
    bpl calculate_frame                             ;
enemy_moving_vertically                             ; For vertically moving enemies,
    lda game_timer                                  ;
    ldy enemies_speed,X                             ;
    bmi skip_inversion4                             ;
    eor #$ff                                        ;
skip_inversion4
    clc                                             ;
    adc enemies_y,X                                 ; use the vertical position to calculate frame
    and #7                                          ;
    lsr                                             ;
calculate_frame
    dec sprite_frames                               ;
    and sprite_frames                               ;
    clc                                             ;
    adc enemies_unpacked_sprite_offset,X            ;
    lsr                                             ;
    ror sprite_frames                               ;
    lsr                                             ;
    ror sprite_frames                               ;
    sta sprite_address_high2                        ;
    lda sprite_frames                               ;
    and #$c0                                        ;
    clc                                             ;
    adc #<unpacked_sprites                          ;
    sta sprite_address_low2                         ;
    lda sprite_address_high2                        ;
    adc #>unpacked_sprites                          ;
    sta sprite_address_high2                        ;

    ldy enemies_colour,X                            ;
    lda colour_mask_values,Y                        ;
    sta sprite_colour                               ;
    txa                                             ;
    tay                                             ;
    ldx enemies_y,Y                                 ;
    rts                                             ;

; ***************************************************************************************
move_enemy
    lda enemy_to_consider2                          ;
    ldy enemies_direction,X                         ;
    beq enemy_moving_horizontally1                  ;
    clc                                             ;
    adc #9                                          ; Use vertical variables for vertically moving enemies
enemy_moving_horizontally1
    tay                                             ;
    lda enemies_speed,X                             ;
    sta enemies_previous_speed,X                    ;
    clc                                             ;
    adc enemies_x,Y                                 ;
    cmp enemies_direction,X                         ;
    bcs at_edge_of_screen                           ;
    sta enemies_x,Y                                 ;
at_edge_of_screen
    cmp enemies_minimum,X                           ;
    bcc flip_direction                              ;
    beq flip_direction                              ;
    cmp enemies_maximum,X                           ;
    bcc update_position                             ;
flip_direction
    lda enemies_speed,X                             ;
    eor #$ff                                        ;
    sec                                             ;
    adc #0                                          ;
    sta enemies_speed,X                             ;
    lda enemies_x,Y                                 ;
update_position
    sta enemies_x,Y                                 ;
    rts                                             ;

; ***************************************************************************************
plot_or_unplot_player_sprite
    ldy sprite_address_low2                         ;
    sty sprite_address_for_restore_lda_low          ;
    sty sprite_address_for_copy_and_low             ;
    sty sprite_address_for_copy_ora_low             ;
    ldy sprite_address_high2                        ;
    sty sprite_address_for_restore_lda_high         ;
    sty sprite_address_for_copy_and_high            ;
    sty sprite_address_for_copy_ora_high            ;
plot_or_unplot_previous_player_sprite
    jsr calculate_screen_address                    ;
    ldx #$3f                                        ;
plot_player_sprite_outer_loop
    ldy #$18                                        ;
    sec                                             ;
plot_player_sprite_loop
plot_player_sprite_mode
    bcc restore_background                          ;
;     also     BCS restore_background
copy_background                                     ; If BCC, copy screen memory to buffer
    lda (screen_address_low),Y                      ;
sprite_address_for_copy_and_low = * + 1
sprite_address_for_copy_and_high = * + 2
    and $1111,X                                     ; actually AND sprite_address,X
    sta player_background_buffer,X                  ;
    lda (screen_address_low),Y                      ;
sprite_address_for_copy_ora_low = * + 1
sprite_address_for_copy_ora_high = * + 2
    ora $1111,X                                     ; actually ORA sprite_address,X
                                                    ; adding player sprite
    sta (screen_address_low),Y                      ;
    bcs continue_with_next_byte                     ;
restore_background                                  ; If BCS, copy buffer to screen memory
sprite_address_for_restore_lda_low = * + 1
sprite_address_for_restore_lda_high = * + 2
    lda $1111,X                                     ; actually LDA sprite_address,X
    eor #$ff                                        ;
    and (screen_address_low),Y                      ; using player sprite as mask
    ora player_background_buffer,X                  ;
    sta (screen_address_low),Y                      ;
continue_with_next_byte
    dex                                             ;
    tya                                             ;
    sbc #8                                          ;
    tay                                             ;
    bcs plot_player_sprite_loop                     ;
    txa                                             ;
    bmi leave12                                     ;
    inc screen_address_low                          ;
    lda screen_address_low                          ;
    bit seven                                       ;
    bne plot_player_sprite_outer_loop               ;
    sec                                             ;
    sbc #8                                          ;
    sta screen_address_low                          ;
    inc screen_address_high                         ;
    inc screen_address_high                         ;
    bpl plot_player_sprite_outer_loop               ;
leave12
    rts                                             ;

;
; Keys
;
keyCodeZ                           = $61
keyCodeX                           = $42
keyCodeReturn                      = $49
keyCodeSpace                       = $62
keyCodeS                           = $51
keyCodeQ                           = $10
keyCodeEscape                      = $70
keyCodeShift                       = $00
keyCodeColon                       = $48

; ***************************************************************************************
keysToTest
    !byte keyCodeZ
    !byte keyCodeX
    !byte keyCodeReturn
    !byte keyCodeSpace
    !byte keyCodeS
    !byte keyCodeQ
    !byte keyCodeEscape
    !byte keyCodeShift
keysToTestEnd

; ***************************************************************************************
; Read keyboard, avoiding the time when the music may update
read_keys
    lda irq_counter                                 ;
    cmp #12*3                                       ;
    bcs read_keys                                   ;

    lda #3                                          ;
    sta systemVIARegisterB                          ; Disable keyboard auto scanning
    lda #$7F                                        ;
    sta systemVIADataDirectionRegisterA             ; Set System VIA Port A to output on bits 0-6, and input on bit 7

    ldx #keysToTestEnd - keysToTest - 1             ;
readKeyLoop
;    lda keyStates,X                                 ; Remember previous key states
;    sta previousKeyStates,X                         ; Remember previous key states
    lda keysToTest,X                                ;
    sta systemVIARegisterANoHandshake               ; Say which key we are interested in (write to System VIA Port A)
    lda systemVIARegisterANoHandshake               ; Read key state (read from System VIA Port A)
    and #$80                                        ; just the top bit reflects key state
                                                    ; 0 means up, $80 means down
    beq +                                           ;
    lda #$ff                                        ;
+
    sta keyStates,X                                 ; Record results
;    lda previousKeyStates,X                         ; Remember previous key states
;    eor #$ff                                        ; Remember previous key states
;    and keyStates,X                                 ; Remember previous key states
;    sta justPressedKeyStates,X                      ; Remember previous key states
    dex                                             ;
    bpl readKeyLoop                                 ;

    lda #$ff                                        ;
    sta systemVIADataDirectionRegisterA             ; Set System VIA Port A to output on all bits 0-7
    lda #11                                         ; Enable keyboard auto scanning
    sta systemVIARegisterB                          ;
    rts                                             ;

; ***************************************************************************************
handle_player_keys
    lda player_conveyor_direction                   ;
    beq player_not_conveyed                         ;
    lda #0                                          ;
    sta player_conveyor_direction                   ; Mark player as not being conveyed
    beq check_for_jump                              ;
player_not_conveyed
    lda keyStateZ
    and #$fe                                        ; 'Z'
    sta player_horizontal_speed                     ;
    lda keyStateX                                   ; 'X'
    and #2                                          ;
    clc                                             ;
    adc player_horizontal_speed                     ;
    sta player_horizontal_speed                     ;
check_for_jump
    lda keyStateReturn                              ; 'Return'
    sta player_started_jump                         ;
    rts                                             ;

; ***************************************************************************************
update_game
    lda player_rope_pixel                           ;
    bne consider_keys                               ; player can't jump when on the rope
    lda player_is_jumping                           ;
    ora player_jump_timer                           ;
    bne skip_keys                                   ; Player can't start jump or move when jumping
consider_keys
    jsr read_keys                                   ;
    jsr handle_player_keys                          ;
skip_keys
    jsr handle_rope_time_and_events                 ;
    jsr handle_player_jumping                       ;
    lda player_horizontal_speed                     ;
    beq player_isnt_moving                          ;
    cmp player_speed                                ;
    beq player_already_moving                       ; Is the player already facing in direction of move?
    sta player_speed                                ; If not, make them face that direction, but don't move
    bne player_isnt_moving                          ;
player_already_moving
    clc                                             ;
    adc player_x_in_enemies                         ;
    sta player_x_in_enemies                         ;
player_isnt_moving
    jsr check_player_move_for_walls                 ;
    beq player_can_move                             ;
    lda player_x_in_enemies                         ;
    sec                                             ;
    sbc player_horizontal_speed                     ;
    sta player_x_in_enemies                         ;
player_can_move
    ldx #0                                          ; player
    jsr calculate_tile_address_for_enemy_X          ;
    jsr see_if_player_should_start_jump             ;
    jsr check_player_jump_for_walls                 ;
    lda player_jump_timer                           ;
    cmp #7                                          ;
    bcs player_falling_after_jump                   ;
    lda player_on_slope                             ;
    beq not_jumping_along_slope                     ;
    lda player_horizontal_speed                     ;
    beq not_jumping_along_slope                     ;
    ldx slope_direction                             ;
    cmp slope_speeds,X                              ;
    beq not_jumping_along_slope                     ;
    inc enemies_y                                   ; Make player move down to follow slope
    inc player_y_in_enemies                         ;
not_jumping_along_slope
    ldx #0                                          ; player
    stx player_on_slope                             ;
    jsr calculate_tile_address_for_enemy_X          ;
    jsr consider_tiles_under_player                 ;
    ldx slope_direction                             ;
    lda player_x_in_enemies                         ;
    and #7                                          ;
    cmp slope_checks,X                              ;
    bne not_slope1                                  ;
    ldy slope_values,X                              ;
    lda (tile_address_low1),Y                       ;
    cmp #3                                          ; SLOPE
    bne not_slope1                                  ;
    lda player_horizontal_speed                     ;
    cmp slope_speeds,X                              ;
    bne not_slope1                                  ;
    lda player_y_in_enemies                         ;
    sec                                             ;
    sbc #2                                          ; If player moving up slope, move them upwards
    sta player_y_in_enemies                         ;
player_falling_after_jump
not_slope1
    jsr update_conveyor                             ;
    jsr update_enemies                              ;
    ldx #0                                          ; player
    jsr calculate_tile_address_for_enemy_X          ;
    jsr mark_enemies_that_overlap_player            ;
    jsr plot_enemies                                ;
    lda #$b0                                        ; 'BCS' opcode ; Set to restore background
    sta plot_player_sprite_mode                     ;
    dec player_not_plotted                          ;
    beq skip_unplot                                 ;

    jsr check_for_q_and_s_keys                      ;
-
    lda vsync_counter                               ;
    cmp #3                                          ;
    bcc -

    lda #0                                          ;
    sta vsync_counter                               ;

    jsr plot_room_items                             ;
    jsr plot_room_items                             ;
    jsr plot_room_items                             ;
    jsr plot_room_items                             ;
    jsr plot_room_items                             ;

    lda player_x                                    ;
    ldx player_y                                    ;
    jsr plot_or_unplot_previous_player_sprite       ; Unplot player
skip_unplot
    jsr plot_enemies                                ;
    jsr update_arrows                               ;
    lda #$90                                        ; 'BCC' opcode ; Set to copy background
    sta plot_player_sprite_mode                     ;
    dec player_not_plotted                          ;
    bpl skip_plot                                   ;
    ldx #0                                          ; player
    jsr calculate_enemy_sprite_address              ;
    lda player_x_in_enemies                         ;
    and #$f8                                        ;
    sta player_x                                    ;
    stx player_y                                    ;
    ldx player_y                                    ;
    bmi skip_plot                                   ;
    jsr plot_or_unplot_player_sprite                ; Plot player

skip_plot
    ldx #0                                          ; player
    stx player_not_plotted                          ;
    jsr calculate_tile_address_for_enemy_X          ;
    jsr check_for_player_touching_tiles             ;
    jsr check_for_player_leaving_room               ;
    lda player_killed                               ;
    beq leave13                                     ;

    ldx #4                                          ; player dying sounds
    jsr start_sound_x                               ;
    ldx #5                                          ;
    jsr start_sound_x                               ;

    dec player_lives                                ;
    lda entry_horizontal_speed                      ; Set player back to where they entered the room
    sta player_horizontal_speed                     ;
    lda entry_jump_timer                            ;
    sta player_jump_timer                           ;
    lda entry_x                                     ;
    sta player_x_in_enemies                         ;
    lda entry_y                                     ;
    sta player_y_in_enemies                         ;
    lda entry_is_jumping                            ;
    sta player_is_jumping                           ;
    jsr remove_collected_items_from_room_data       ;
leave13
    rts                                             ;

; ***************************************************************************************
initialise_enemies
    ldx #3                                          ;
    jsr get_x_bits_of_room_data                     ; Get three bits of room data for number of enemies
    sta enemies_on_screen                           ;
    tay                                             ;
    beq no_enemies                                  ;
initialise_enemies_loop                             ; For each enemy,
    ldx #6                                          ; Get six bits of room data for sprite
    jsr get_x_bits_of_room_data                     ;
    sta enemies_sprite,Y                            ;
    ldx #5                                          ; Get five bits of room data for x position
    jsr get_x_bits_of_room_data_multiplied_by_eight ;
    sta enemies_x,Y                                 ;
    ldx #4                                          ; Get four bits of room data for y position
    jsr get_x_bits_of_room_data_multiplied_by_eight ;
    sta enemies_y,Y                                 ;
    ldx #5                                          ; Get five bits of room data for minimum position
    jsr get_x_bits_of_room_data_multiplied_by_eight ;
    sta enemies_minimum,Y                           ;
    ldx #5                                          ; Get five bits of room data for maximum position
    jsr get_x_bits_of_room_data_multiplied_by_eight ;
    sta enemies_maximum,Y                           ;
    ldx #1                                          ; Get one bit of room data for direction
    jsr get_x_bits_of_room_data                     ; (0 = horizontal, 1 = vertical)
    asl                                             ;
    beq not_zero                                    ;
    lda #$ff                                        ;
not_zero
    sta enemies_direction,Y                         ;
    ldx #1                                          ; Get one bit of room data for direction
    jsr get_x_bits_of_room_data                     ; (0 = left/up, 1=right/down)
    sta invert                                      ;
    ldx #3                                          ; Get three bits of room data for speed
    jsr get_x_bits_of_room_data                     ;
    sta enemies_speed,Y                             ;
    ldx invert                                      ;
    bne skip_inversion5                             ;
    eor #$ff                                        ;
    clc                                             ;
    adc #1                                          ;
    sta enemies_speed,Y                             ;
skip_inversion5
    ldx #2                                          ; Get two bits of room data for colour
    jsr get_x_bits_of_room_data                     ;
    sta enemies_colour,Y                            ;
    lda #0                                          ;
    sta enemies_previous_speed,Y                    ;
    sta enemies_previous_tile_address_low,Y         ;
    dey                                             ;
    bne initialise_enemies_loop                     ;
no_enemies
    jmp unpack_enemy_sprites                        ;

; ***************************************************************************************
get_x_bits_of_room_data_multiplied_by_eight
    jsr get_x_bits_of_room_data                     ;
    asl                                             ;
    asl                                             ;
    asl                                             ;
    rts                                             ;

; ***************************************************************************************
set_tile_table_for_background
    ldy #0                                          ;
    sty tile_address_high1                          ;
    lda #$0f                                        ;
    sec                                             ;
    sbc tile_y                                      ;
    asl                                             ;
    asl                                             ; tile_address = tile_table + (15-tile_y) * 32 + tile_x
    asl                                             ;
    asl                                             ;
    asl                                             ;
    rol tile_address_high1                          ;
    adc tile_x                                      ;
    bcc +                                           ;
    inc tile_address_high1                          ;
    clc                                             ;
+
    adc #<tile_table                                ;
    sta tile_address_low1                           ;
    lda tile_address_high1                          ;
    adc #>tile_table                                ;
    sta tile_address_high1                          ;

    lda tile_type                                   ;
    adc #1                                          ;
    cmp #5                                          ;
    beq not_item                                    ; if (DEADLY) then store that
    cmp #6                                          ; store (tile type + 1) in tile_table for PLATFORM, WALL, SLOPE, CONVEYOR
    bcc set_tile_table                              ;
    beq scenery                                     ; if (SCENERY) skip else it's ITEM
    inc item_number                                 ; If this tile is an item, store its details
    ldx item_number                                 ;
    lda screen_address_low                          ;
    sta items_screen_address_low,X                  ;
    lda screen_address_high                         ;
    sta items_screen_address_high,X                 ;
    lda tile_address_low1                           ;
    sta items_tile_address_low,X                    ;
    lda tile_address_high1                          ;
    sta items_tile_address_high,X                   ;
    txa                                             ;
    ora #$10                                        ; Mark as item
not_item
    ora #$c0                                        ; Mark as not enemy, nor background
set_tile_table
    ldy #0                                          ;
    sta (tile_address_low1),Y                       ;
scenery
    rts                                             ;

; ***************************************************************************************
wipe_tile_table
    ldy #0                                          ;
    lda #$80                                        ;
wipe_tile_table_loop
    sta tile_table,Y                                ;
    sta tile_table + $100,Y                         ;
    iny                                             ;
    bne wipe_tile_table_loop                        ;
    rts                                             ;

; ***************************************************************************************
calculate_tile_address_for_enemy_X
    lda #0                                          ;
    sta tile_address_high1                          ;
    lda enemies_y,X                                 ;
    sec                                             ;
    sbc #8                                          ;
    bcs +                                           ;
    dec tile_address_high1                          ;
+
    asl                                             ;
    asl                                             ;
    rol tile_address_high1                          ;
    and #$e0                                        ;
    sta tmp                                         ;
    lda enemies_x,X                                 ;
    lsr                                             ;
    lsr                                             ;
    lsr                                             ;
    clc                                             ;
    adc tmp                                         ;
    clc                                             ;
    adc #<tile_table                                ;
    sta tile_address_low1                           ;

    lda tile_address_high1                          ;
    adc #>tile_table                                ;
    sta tile_address_high1                          ;

    ; return with the low byte in the accumulator
    lda tile_address_low1                           ;
    rts                                             ;

; ***************************************************************************************
consider_tiles_under_player                         ; There are two tiles beneath the player's feet ; one
    ldx slope_direction                             ; which may have a slope, and one which does not
    ldy slope_tile_offsets,X                        ;
    lda (tile_address_low1),Y                       ; Consider tile beneath player's feet (with slope)
    beq is_space                                    ;
    bpl isnt_space                                  ;
is_space
    inx                                             ;
    ldy slope_tile_offsets,X                        ;
    lda (tile_address_low1),Y                       ; Consider tile beneath player's feet (without slope)
    beq player_in_midair                            ; If both are empty, the player falls
    bmi player_in_midair                            ;
isnt_space
    cmp #3                                          ; SLOPE
    bne not_slope2                                  ;
    jsr consider_slope_effect                       ; If one is a slope, see how that affects the player
    beq player_in_midair                            ;
    bpl check_for_conveyor                          ;
not_slope2
    sta tile2                                       ;
    lda player_y_in_enemies                         ;
    and #7                                          ;
    cmp #3                                          ;
    bcs player_in_midair                            ;
    lda tile2                                       ;
check_for_conveyor
    cmp #4                                          ; CONVEYOR
    bne not_conveyor                                ;
    jsr consider_conveyor_effect                    ;
not_conveyor
    lda player_is_jumping                           ;
    beq align_player_with_tile                      ;
    lda player_entered_room_falling_too_far         ;
    bne player_fell_too_far                         ;
    lda player_y_in_enemies                         ;
    sec                                             ;
    sbc where_player_fell_from                      ;
    bmi player_didnt_fall_too_far                   ;
    cmp #$21                                        ; Has the player fallen more than four tiles?
    bcc player_didnt_fall_too_far                   ;
player_fell_too_far
    inc player_killed                               ; Kill the player if they hit after falling too far
player_didnt_fall_too_far
    lda #0                                          ;
    sta player_jump_timer                           ;
    sta player_is_jumping                           ;
align_player_with_tile
    lda player_on_slope                             ;
    bne leave14                                     ;
    lda player_y_in_enemies                         ;
    and #$f8                                        ;
    sta player_y_in_enemies                         ;
leave14
    rts                                             ;
player_in_midair
    lda player_jump_timer                           ;
    bne leave15                                     ;
    lda player_is_jumping                           ;
    bne skip_noting_fall                            ;
    lda player_y_in_enemies                         ;
    sta where_player_fell_from                      ;
    sta player_is_jumping                           ;
skip_noting_fall
    lda #0                                          ;
    sta player_horizontal_speed                     ;
    lda player_y_in_enemies                         ;
    clc                                             ;
    adc #4                                          ;
    sta player_y_in_enemies                         ;
leave15
    rts                                             ;

; ***************************************************************************************
update_enemies
    lda enemies_on_screen                           ;
    beq leave16                                     ;
    sta enemy_to_consider2                          ;
update_enemies_loop
    ldx enemy_to_consider2                          ;
    jsr move_enemy                                  ;
    lda #1                                          ;
    sta enemies_need_replot,X                       ;
    lda #0                                          ;
    sta enemy_has_moved,X                           ;
    jsr calculate_tile_address_for_enemy_X          ;
    ldy enemies_previous_tile_address_low,X         ;
    sty previous_tile_address_low                   ;
    cmp enemies_previous_tile_address_low,X         ;
    beq consider_next_enemy2                        ;
    inc enemy_has_moved,X                           ;
    sta enemies_previous_tile_address_low,X         ;
    txa                                             ;
    ora #$80                                        ;
    ldy #$20                                        ; Mark enemy in four tiles
    sta (tile_address_low1),Y                       ;
    iny                                             ;
    sta (tile_address_low1),Y                       ;
    ldy #$40                                        ;
    sta (tile_address_low1),Y                       ;
    iny                                             ;
    sta (tile_address_low1),Y                       ;
    lda previous_tile_address_low                   ;
    beq consider_next_enemy2                        ;
    lda enemies_previous_speed,X                    ;
    beq consider_next_enemy2                        ; If the enemy is moving,
    asl                                             ;
    lda enemies_direction,X                         ;
    and #2                                          ;
    adc #0                                          ;
    tax                                             ;
    ldy direction_tile_offsets_one,X                ;
    lda space_tile                                  ;
    sta (tile_address_low1),Y                       ; Remove enemy from previously occupied tiles
    ldy direction_tile_offsets_two,X                ;
    sta (tile_address_low1),Y                       ;
    ldx enemy_to_consider2                          ;
consider_next_enemy2
    dec enemy_to_consider2                          ;
    bne update_enemies_loop                         ;
leave16
    rts                                             ;

; ***************************************************************************************
wipe_space_vacated_by_enemy
    ldx enemy_to_consider2                          ;
    lda enemy_has_moved,X                           ;
    beq leave17                                     ;
    lda enemies_direction,X                         ;
    bne leave17                                     ; Leave if this enemy is moving vertically.
    lda #8                                          ;
    sta sprite_width                                ; Set sprite size to be 16x2 pixels
    lda #$1f                                        ;
    sta sprite_size_in_bytes                        ;
    lda #$f8                                        ;
    ldy enemies_previous_speed,X                    ;
    bpl enemy_moving_right                          ;
enemy_moving_left
    lda #$0c                                        ;
enemy_moving_right
    clc                                             ;
    adc enemies_x,X                                 ;
    sta enemy_x                                     ;
    lda #<space_sprite                              ;
    sta sprite_address_low2                         ;
    lda #>space_sprite                              ;
    sta sprite_address_high2                        ;
    lda enemies_y,X                                 ;
    tax                                             ;
    lda enemy_x                                     ;
    jsr plot_sprite                                 ;
    lda #$18                                        ; Restore sprite size to 16x16 pixels
    sta sprite_width                                ;
    lda #$3f                                        ;
    sta sprite_size_in_bytes                        ;
    ldx enemy_to_consider2                          ;
leave17
    rts                                             ;

; ***************************************************************************************
direction_tile_offsets_one
    !byte $1f, $22, $00, $60

direction_tile_offsets_two
    !byte $3f, $42, $01, $61

; ***************************************************************************************
plot_enemy
    lda enemies_direction,Y                         ;
    beq enemy_moving_horizontally2                  ;

    ; moving vertically
    lda enemies_previous_speed,Y                    ;
    bmi enemy_moving_up                             ;
enemy_moving_down                                   ; If this enemy is moving down,
    ldx enemies_sprite,Y                            ;
    cpx #$21                                        ;
    beq enemy_is_skull_mouth                        ; The skull mouth will be overwritten by the skull top
    sta previous_speed                              ; Otherwise,
    asl                                             ;
    asl                                             ;
    sbc #0                                          ;
    sta sprite_size_in_bytes                        ; Set sprite to be section previously occupied
    lda sprite_address_low2                         ;
    sta previous_sprite_address_low                 ;
    lda #<space_sprite                              ;
    sta sprite_address_low2                         ;
    lda sprite_address_high2                        ;
    sta previous_sprite_address_high                ;
    lda #>space_sprite                              ;
    sta sprite_address_high2                        ;
    lda enemies_y,Y                                 ;
    sec                                             ;
    sbc previous_speed                              ;
    tax                                             ;
    lda enemies_x,Y                                 ;
    jsr plot_sprite                                 ; Wipe previous position of sprite
    lda previous_sprite_address_high                ;
    sta sprite_address_high2                        ;
    lda #$3f                                        ; Set sprite to be 16x16 pixels
    sta sprite_size_in_bytes                        ;
    lda previous_sprite_address_low                 ;
    sta plot_sprite_address_low                     ; Plot sprite
    jsr into_plot_sprite_with_skip                  ;
    rts                                             ;
enemy_is_skull_mouth
    ldx enemies_y,Y                                 ;
enemy_moving_horizontally2
    lda enemies_x,Y                                 ;
    and #$f8                                        ;
    jsr plot_sprite                                 ;
    rts                                             ;
enemy_moving_up                                     ; If the enemy is moving up,
    lda enemies_x,Y                                 ;
    jsr plot_sprite                                 ; Plot sprite
    lda #<space_sprite                              ;
    sta plot_sprite_address_low                     ;
    ldy enemy_to_consider2                          ;
    lda #>space_sprite                              ;
    sta sprite_address_high2                        ;
    lda enemies_previous_speed,Y                    ;
    eor #$ff                                        ;
    clc                                             ;
    adc #1                                          ;
    asl                                             ;
    asl                                             ;
    sbc #0                                          ;
    sta sprite_size_in_bytes                        ; Set sprite to be section previously occupied
    jsr into_plot_sprite_with_skip                  ; Wipe previous position of sprite
    lda #$3f                                        ;
    sta sprite_size_in_bytes                        ; Restore sprite to 16x16 pixels
    rts                                             ;

; ***************************************************************************************
into_plot_sprite_with_skip
    ldx sprite_size_in_bytes                        ;
    lda sprite_address_high2                        ;
    sta plot_sprite_address_high                    ;
    jmp plot_sprite_skipping_first_column           ;

check_player_move_for_walls
    ldx #0                                          ; player
    stx walls                                       ;
    jsr calculate_tile_address_for_enemy_X          ;
    ldy #$20                                        ;
    lda player_horizontal_speed                     ;
    beq leave_with_result                           ; No walls hit if player not moving
    bmi player_moving_left                          ;
player_moving_right
    iny                                             ;
player_moving_left
    jsr check_tile_for_wall                         ; Check top of player
    jsr check_tile_for_wall                         ; Check middle/bottom of player
    lda player_y_in_enemies                         ;
    and #7                                          ;
    beq leave_with_result                           ;
    jsr check_tile_for_wall                         ; Check bottom of player if not aligned
leave_with_result
    lda walls                                       ;
    rts                                             ;

; ***************************************************************************************
check_tile_for_wall
    lda (tile_address_low1),Y                       ;
    cmp #2                                          ; WALL
    bne not_wall                                    ;
    inc walls                                       ;
not_wall
    tya                                             ;
    clc                                             ;
    adc #$20                                        ;
    tay                                             ;
    rts                                             ;

; ***************************************************************************************
see_if_player_should_start_jump
    lda player_started_jump                         ;
    beq leave18                                     ;
    inc player_is_jumping                           ;
    lda #$12                                        ;
    sta player_jump_timer                           ;
    inc player_started_jump                         ;
    lda player_y_in_enemies                         ;
    sec                                             ;
    sbc #8                                          ;
    sta where_player_fell_from                      ;
    jsr check_player_jump_for_walls                 ;
    beq leave18                                     ;
    ldx #0                                          ;
    jsr start_sound_x                               ; Player jump sound
    jsr handle_player_jumping                       ;
leave18
    rts                                             ;

; ***************************************************************************************
check_player_jump_for_walls
    lda player_y_in_enemies                         ;
    and #7                                          ;
    bne leave19                                     ;
    ldy #0                                          ; Consider tile above player's left
    lda (tile_address_low1),Y                       ;
    eor #2                                          ; WALL
    beq cant_jump                                   ;
    iny                                             ; Consider tile above player's right
    lda (tile_address_low1),Y                       ;
    eor #2                                          ; WALL
    bne leave19                                     ;
cant_jump
    jsr handle_player_jumping                       ; Conclude any existing jump
    lda #0                                          ; If either is a wall, player can't jump
    sta player_jump_timer                           ;
leave19
    rts                                             ;

; ***************************************************************************************
check_for_player_touching_tiles
    lda player_y_in_enemies                         ;
    ora #7                                          ;
    sec                                             ;
    sbc player_y_in_enemies                         ;
    sta rows_to_check                               ;
    ldy #$20                                        ; Consider tile at top left of player
    lda #$3d                                        ;
    jsr check_for_player_touching_tile              ;
    ldy #$21                                        ; Consider tile at top right of player
    lda #$3f                                        ;
    jsr check_for_player_touching_tile              ;
    rts                                             ;

; ***************************************************************************************
check_for_player_touching_tile
    sta buffer_offset                               ;
    ldx rows_to_check                               ;
    jsr check_rows_of_player_against_tile1          ; Check top of player (aligned to tile boundaries)
    ldx #7                                          ;
    jsr check_rows_of_player_against_tile1          ; Check middle of player
    lda #7                                          ;
    sec                                             ;
    sbc rows_to_check                               ;
    beq leave20                                     ;
    tax                                             ;
    dex                                             ;
    jsr check_rows_of_player_against_tile1          ; Check bottom of player
leave20
    rts                                             ;

; ***************************************************************************************
check_rows_of_player_against_tile1
    tya                                             ;
    clc                                             ;
    adc #$20                                        ;
    sta item_state                                  ; next_tile_offset ; Consider tile immediately below when next called
    lda (tile_address_low1),Y                       ;
    sta tile1                                       ;
    bpl tile_is_background                          ;
    ldy buffer_offset                               ; If this tile is an enemy or an item,
check_rows_of_player_against_tile2                  ; for each row of the player within the tile,
    lda player_background_buffer,Y                  ;
    beq not_part_of_player_left                     ; is there part of the player there?
    jsr player_is_touching_tile                     ; If so, consider the interaction
not_part_of_player_left
    dey                                             ;
    lda player_background_buffer,Y                  ; Check again on right-hand side
    beq not_part_of_player_right                    ;
    jsr player_is_touching_tile                     ;
not_part_of_player_right
    dey                                             ;
    dey                                             ;
    dey                                             ;
    dex                                             ;
    bpl check_rows_of_player_against_tile2          ;
    sty buffer_y                                    ;
    ldy next_tile_offset                            ;
    rts                                             ;
tile_is_background                                  ; If this tile is just background,
    inx                                             ; set things up for the next check
    txa                                             ;
    asl                                             ;
    asl                                             ;
    eor #$ff                                        ;
    sec                                             ;
    adc buffer_offset                               ;
    sta buffer_offset                               ;
    ldy next_y                                      ;
    rts                                             ;

; ***************************************************************************************
player_is_touching_tile
    stx x1                                          ;
    sty y                                           ;
    lda #0                                          ;
    sta player_background_buffer,Y                  ;
    lda tile1                                       ;
    and #$7f                                        ;
    beq tile_is_space                               ;
    cmp #$4e                                        ;
    bcs tile_is_item                                ;
    cmp #2                                          ;
    bne not_bathroom_toilet                         ; Is this the bathroom toilet? (room $15, slot 2)
    lda player_room                                 ;
    cmp #$15                                        ; The Bathroom
    beq leave_with_initial_x_and_y                  ; If so, it isn't deadly.
not_bathroom_toilet
    inc player_killed                               ; Otherwise, kill the player
leave_with_initial_x_and_y
    ldx x1                                          ;
    ldy y                                           ;
    rts                                             ;
tile_is_item                                        ; If the tile is an item,
    and #$0f                                        ;
    tax                                             ;
    lda items_colour,X                              ;
    beq leave_with_initial_x_and_y                  ; has it been collected?
    lda #0                                          ;
    sta items_colour,X                              ; If not, remove it from the screen
    stx item_number                                 ;
    jsr collect_item                                ;
    bpl leave_with_initial_x_and_y                  ;
tile_is_space
    lda room_contains_rope                          ;
    bne leave_with_initial_x_and_y                  ;
    inc player_killed                               ; Player has been hit by an arrow or moving enemy
    bne leave_with_initial_x_and_y                  ;

plot_room_items
    ldx items_in_room_minus_one                     ;
    bmi leave21                                     ;
    cpx item_number                                 ;
    bcc skip_item                                   ;

    ldx item_number                                 ;
    lda items_screen_address_low,X                  ;
    sta screen_address_low                          ;
    lda items_screen_address_high,X                 ;
    sta screen_address_high                         ;

    ldy items_colour,X                              ;
    beq item_collected1                             ;
    dec items_colour,X                              ;
    bne skip_reset_colour                           ;
    lda #3                                          ;
    sta items_colour,X                              ;
skip_reset_colour
    ldy items_colour,X                              ;
item_collected1
    lda colour_mask_values,Y                        ;
    sta sprite_colour                               ;

    ldy #$0f                                        ; loop counter
plot_item_loop
    lda unpacked_background_sprite,Y                ;
    and sprite_colour                               ;
    sta (screen_address_low),Y                      ;
    dey                                             ;
    bpl plot_item_loop                              ;

    lda items_tile_address_low,X                    ;
    sta tile_address_low2                           ;
    lda items_tile_address_high,X                   ;
    sta tile_address_high2                          ;
    txa                                             ;
    ora #$e0                                        ;
    ldy #0                                          ;
    sta (tile_address2),Y                           ;
skip_item
    dec item_number                                 ;
    bpl leave21                                     ;
    lda #$0b                                        ; [maximum number of items in a room?]
    sta item_number                                 ;
leave21
    rts                                             ;

; ***************************************************************************************
consider_slope_effect
    ldx slope_direction                             ;
    tya                                             ; Y is a tile offset of tile beneath player with slope
    cmp slope_tile_offsets,X                        ;
    bne leave_with_minus_one                        ;
player_is_climbing_slope
    inc player_on_slope                             ;
    lda player_y_in_enemies                         ;
    and #7                                          ;
    sta player_y_fraction                           ;
    lda player_x_in_enemies                         ;
    and #7                                          ;
    eor slope_climb_eors,X                          ;
    sec                                             ;
    adc slope_climb_adds,X                          ;
    bmi player_not_climbing_slope                   ;
    cmp player_y_fraction                           ;
    bcc player_not_climbing_slope                   ;
    dec enemies_y                                   ; Make player move up to follow slope
    dec player_y_in_enemies                         ;
    bcs leave_with_zero                             ;
player_not_climbing_slope
    clc                                             ;
    adc #4                                          ;
    cmp player_y_fraction                           ;
    bcc leave_with_zero                             ;
    sbc #2                                          ;
    sta player_y_fraction                           ;
    lda player_y_in_enemies                         ;
    and #$f8                                        ;
    ora player_y_fraction                           ;
    sbc #1                                          ;
    sta player_y_in_enemies                         ;
    lda #1                                          ;
    ldx player_room                                 ;
    cpx #$16                                        ; The slopes in "Halfway up the East Wall"
    beq leave_with_four                             ;
    cpx #$1d                                        ; and "The Chapel" are treated as conveyors
    bne leave_with_one                              ;
leave_with_four
    lda #4                                          ; CONVEYOR
leave_with_one
    tax                                             ; 1 = PLATFORM
    rts                                             ;
leave_with_zero
    lda #0                                          ; SPACE
    rts                                             ;
leave_with_minus_one
    lda #$ff                                        ; Treat tile as though not a slope
    rts                                             ;

; ***************************************************************************************
slope_climb_eors
    !byte $ff, $00

slope_climb_adds
    !byte $05, $fe

slope_checks
    !byte $00, $06

slope_values
    !byte $41, $40

slope_speeds
    !byte $02, $fe

slope_tile_offsets
    !byte $61, $60, $61

; ***************************************************************************************
consider_conveyor_effect
    lda player_horizontal_speed                     ; Is the player moving?
    beq start_conveying_player                      ;
    cmp conveyor_direction                          ; If not, or they're moving in the conveyor's direction,
    bne leave22                                     ;
start_conveying_player
    lda conveyor_direction                          ; move them with the conveyor
    sta player_horizontal_speed                     ;
    sta player_conveyor_direction                   ; (preventing them from changing direction)
leave22
    rts                                             ;

check_for_player_leaving_room
    ldy #0                                          ;
    lda player_x_in_enemies                         ;
    beq player_at_left_or_right_edge_of_room        ;
    iny                                             ;
    cmp #$f6                                        ;
    beq player_at_left_or_right_edge_of_room        ;
    iny                                             ;
    ldx #$68                                        ;
    lda player_y_in_enemies                         ;
    bmi player_at_top_or_bottom_edge_of_room        ;
    iny                                             ;
    ldx #1                                          ;
    cmp #$71                                        ;
    bcc leave23                                     ;
    lda player_is_jumping                           ;
    beq player_at_top_or_bottom_edge_of_room        ;
    lda player_y_in_enemies                         ;
    sec                                             ;
    sbc where_player_fell_from                      ;
    cmp #$22                                        ;
    bcc player_at_top_or_bottom_edge_of_room        ;
    sta player_entered_room_falling_too_far         ;
    jmp player_at_top_or_bottom_edge_of_room        ;
player_at_left_or_right_edge_of_room
    eor #$f4                                        ;
    sta player_x_in_enemies                         ;
    jmp change_room                                 ;
player_at_top_or_bottom_edge_of_room
    stx player_y_in_enemies                         ;
    lda #0                                          ;
    sta player_horizontal_speed                     ;
change_room
    lda exit_rooms,Y                                ;
goto_room
    sta player_room                                 ;
    jsr remove_collected_items_from_room_data       ;
    jsr initialise_room                             ;
leave23
    rts                                             ;

cycle_item_colours
    !byte 1,2,3,1,2,3,1,2,3,1,2,3

; ***************************************************************************************
initialise_room_items_and_exits
    ldx #4                                          ; Get four bits of room data for number of items in room
    jsr get_x_bits_of_room_data                     ;
    tay                                             ;
    dey                                             ;
    sty items_in_room_minus_one                     ;
    bmi no_items                                    ;
set_items_loop                                      ; For each item,
    ldx #1                                          ; get one bit of room data for its state
    jsr get_x_bits_of_room_data                     ; (0 = collected, 1 = uncollected)
    beq +
    lda cycle_item_colours,Y                        ;
+
    sta items_colour,Y                              ;
    dey                                             ;
    bpl set_items_loop                              ;
no_items
    ldy #0                                          ;
set_exits_loop                                      ; For each of four directions
    ldx #6                                          ; get six bits of room data for the room exited to
    jsr get_x_bits_of_room_data                     ;
    sta exit_rooms,Y                                ;
    iny                                             ;
    cpy #4                                          ;
    bne set_exits_loop                              ;
    ldx #1                                          ; Get one bit of room data for conveyor direction
    jsr get_x_bits_of_room_data                     ; (0 = left, 1 = right)
    asl                                             ;
    asl                                             ;
    sec                                             ;
    sbc #2                                          ;
    sta conveyor_direction                          ;
    ldx #1                                          ; Get one bit of room data for slope direction
    jsr get_x_bits_of_room_data                     ; (0 = /, 1 = \)
    sta slope_direction                             ;
    ldx #1                                          ; Get one bit of room data for rope
    jsr get_x_bits_of_room_data                     ; (1 = room contains rope)
    sta room_contains_rope                          ;
    rts                                             ;

; ***************************************************************************************
remove_collected_items_from_room_data
    ldy #0                                          ;
    ldx items_in_room_minus_one                     ;
    bmi leave24                                     ;
    lda #4                                          ;
    sta bit_for_item                                ;
remove_collected_items_from_room_data_loop
    dec bit_for_item                                ;
    bpl skip_new_byte                               ;
    lda #7                                          ;
    sta bit_for_item                                ;
    iny                                             ;
skip_new_byte
    lda items_colour,X                              ;
    beq item_collected2                             ;
    lda #$ff                                        ;
item_collected2
    sta item_state                                  ;
    stx x2                                          ;
    ldx bit_for_item                                ;
    lda inverse_of_bits,X                           ;
    eor #$ff                                        ;
    and item_state                                  ;
    sta item_state                                  ;
    lda (room_data_address),Y                       ;
    and inverse_of_bits,X                           ;
    ora item_state                                  ;
    sta (room_data_address),Y                       ;
    ldx x2                                          ;
    dex                                             ;
    bpl remove_collected_items_from_room_data_loop  ;
leave24
    rts                                             ;

; ***************************************************************************************
inverse_of_bits
    !byte $7f, $bf, $df, $ef, $f7, $fb, $fd, $fe

; ***************************************************************************************
reset_items
    ldy #$0b                                        ;
    lda #1                                          ;
mark_all_items_as_uncollected_loop
    sta items_colour,Y                              ;
    dey                                             ;
    bpl mark_all_items_as_uncollected_loop          ;
    lda #$3c                                        ;
    sta room                                        ;
reset_items_room_loop
    ldx room                                        ;
    jsr calculate_room_data_address                 ;
    ldx #4                                          ;
    jsr get_x_bits_of_room_data                     ;
    sta items_in_room_minus_one                     ;
    dec items_in_room_minus_one                     ;
    jsr remove_collected_items_from_room_data       ;
    dec room                                        ;
    bne reset_items_room_loop                       ;
    rts                                             ;

; ***************************************************************************************
calculate_room_data_address
    lda #0                                          ;
    sta room_data_offset                            ;
    sta bits_remaining_in_room_data_byte            ;
    lda room_data_address_low_table,X               ;
    sta room_data_address_low                       ;
    lda room_data_address_high_table,X              ;
    sta room_data_address_high                      ;
    rts                                             ;

; ***************************************************************************************
update_conveyor
    lda pages_of_tile_table_remaining_when_finding_conveyor ;
    beq leave25                                     ; Is there a conveyor in this room? If not, leave
    lda game_timer                                  ;
    and #7                                          ;
    tax                                             ;
    lda conveyor_length                             ;
    sta conveyor_sections_remaining_to_update       ;
    lda conveyor_screen_address_low                 ;
    sta screen_address_low                          ;
    lda conveyor_screen_address_high                ;
    sta screen_address_high                         ;
    ldy #0                                          ;
    clc                                             ;
update_conveyor_loop
    lda unpacked_conveyor_sprite,X                  ;
    sta (screen_address_low),Y                      ;
    iny                                             ;
    iny                                             ;
    lda unpacked_conveyor_sprite + 8,X              ;
    sta (screen_address_low),Y                      ;
    tya                                             ;
    adc #6                                          ;
    tay                                             ;
    lda unpacked_conveyor_sprite + 16,X             ;
    sta (screen_address_low),Y                      ;
    iny                                             ;
    iny                                             ;
    lda unpacked_conveyor_sprite + 24,X             ;
    sta (screen_address_low),Y                      ;
    tya                                             ;
    adc #6                                          ;
    tay                                             ;
    bne +                                           ;
    inc screen_address_high                         ;
    clc                                             ;
+
    dec conveyor_sections_remaining_to_update       ;
    bne update_conveyor_loop                        ;
leave25
    rts                                             ;

; ***************************************************************************************
calculate_screen_address_of_conveyor
    ldy #<tile_table                                ;
    sty tile_address_low1                           ;
    lda #>tile_table                                ;
    sta tile_address_high1                          ;
    lda #0                                          ;
    sta temp_high                                   ;
    lda #2                                          ;
    sta pages_of_tile_table_remaining_when_finding_conveyor ;
    ldy #0                                          ;
find_start_of_conveyor_loop
    jsr check_if_tile_is_conveyor                   ;
    bne find_start_of_conveyor_loop                 ;
    sty conveyor_screen_address_low                 ;
    lda temp_high                                   ;
    and #1                                          ;
    asl conveyor_screen_address_low                 ;
    rol                                             ;
    asl conveyor_screen_address_low                 ;
    rol                                             ;
    asl conveyor_screen_address_low                 ;
    rol                                             ;
    asl conveyor_screen_address_low                 ;
    rol                                             ;
    adc #>screen_memory_start                       ;
    sta conveyor_screen_address_high                ;
    ldx #0                                          ;
    inc pages_of_tile_table_remaining_when_finding_conveyor ;
find_end_of_conveyor_loop
    inx                                             ;
    jsr check_if_tile_is_conveyor                   ;
    beq find_end_of_conveyor_loop                   ;
    stx conveyor_length                             ;
    jmp prepare_conveyor_sprites                    ;

check_if_tile_is_conveyor
    iny                                             ;
    bne compare_tile_with_four                      ;
    inc tile_address_high1                          ;
    inc temp_high                                   ;
    dec pages_of_tile_table_remaining_when_finding_conveyor ;
    bne compare_tile_with_four                      ;
    pla                                             ; Leave calculate_screen_address_of_conveyor at end of
    pla                                             ; tile table
    rts                                             ;
compare_tile_with_four
    lda (tile_address_low1),Y                       ;
    cmp #4                                          ; CONVEYOR
    rts                                             ;

; ***************************************************************************************
prepare_conveyor_sprites
    lda background_tiles_sprites + 3                ;
    jsr calculate_background_sprite_address         ;
    ldx background_tiles_colours_fg + 3             ;
    lda colour_mask_values,X                        ;
    sta conveyor_colour                             ;
    ldx background_tiles_colours_bg + 3             ;
    lda colour_mask_values,X                        ;
    sta conveyor_colour_eor                         ;
    eor conveyor_colour                             ;
    sta conveyor_colour                             ;
    ldy #0                                          ;
    lda conveyor_direction                          ;
    bmi prepare_top_of_left_conveyor                ;
prepare_top_of_right_conveyor
    ldx #0                                          ; Prepare top of conveyor
    jsr prepare_right_conveyor_bytes                ;
    bmi prepare_conveyor_bottom                     ;
prepare_top_of_left_conveyor
    ldx #7                                          ;
    jsr prepare_left_conveyor_bytes                 ;
prepare_conveyor_bottom
    ldy #2                                          ;
    lda conveyor_direction                          ;
    bmi prepare_bottom_of_left_conveyor             ;
prepare_bottom_of_right_conveyor
    ldx #$0f                                        ; Prepare bottom of conveyor
    jsr prepare_left_conveyor_bytes                 ;
    bmi leave26                                     ;
prepare_bottom_of_left_conveyor
    ldx #8                                          ;
    jsr prepare_right_conveyor_bytes                ;
leave26
    rts                                             ;

; ***************************************************************************************
prepare_right_conveyor_bytes
    lda (sprite_address),Y                          ;
    sta packed_byte2                                ;
    lda #7                                          ;
    sta count                                       ;
prepare_right_conveyor_bytes_loop
    jsr rotate_and_store_conveyor_byte              ;
    inx                                             ;
    dec count                                       ;
    bpl prepare_right_conveyor_bytes_loop           ;
    rts                                             ;

prepare_left_conveyor_bytes
    lda (sprite_address),Y                          ;
    sta packed_byte2                                ;
    lda #7                                          ;
    sta count                                       ;
prepare_left_conveyor_bytes_loop
    jsr rotate_and_store_conveyor_byte              ;
    dex                                             ;
    dec count                                       ;
    bpl prepare_left_conveyor_bytes_loop            ;
    rts                                             ;

; ***************************************************************************************
rotate_and_store_conveyor_byte
    clc                                             ;
    lda packed_byte2                                ;
    bpl +                                           ;
    sec                                             ;
+
    rol                                             ;
    sta packed_byte2                                ;
    jsr unpack_byte_of_sprite_data                  ;
    and conveyor_colour                             ;
    eor conveyor_colour_eor                         ;
    sta unpacked_conveyor_sprite,X                  ;
    lda unpacked_byte_two                           ;
    and conveyor_colour                             ;
    eor conveyor_colour_eor                         ;
    sta unpacked_conveyor_sprite + 16,X             ;
    rts                                             ;

; ***************************************************************************************
animate_game_over_boot
    lda #0                                          ;
    sta melody_active                               ; Disable melody
    ldx #0                                          ; Room 0 is the Game Over screen
    jsr calculate_room_data_address                 ;
    jsr initialise_enemies                          ;
    lda #1                                          ;
    sta enemies_unpacked_sprite_offset + 2          ; Set second barrel to use player sprite
    sta enemies_need_replot + 1                     ; Mark all enemies as needing plotting
    sta enemies_need_replot + 2                     ;
    sta enemies_need_replot + 3                     ;
    jsr plot_enemies                                ;
    lda #>(unpacked_enemy_sprites + $40)            ;
    sta sprite_address_high2                        ;
    lda #<(unpacked_enemy_sprites + $40)            ;
    sta sprite_address_low2                         ;
    ldx #3                                          ; Play game over sound
    jsr start_sound_x                               ;
animate_game_over_boot_loop
    lda enemies_x + 1                               ;
    ldx enemies_y + 1                               ;
    jsr plot_sprite                                 ; Plot boot
    ldx #$0f                                        ;
    jsr delay                                       ;
    inc enemies_y + 1                               ;
    lda enemies_y + 1                               ;
    cmp #$61                                        ;
    bne animate_game_over_boot_loop                 ;
    rts                                             ;

; ***************************************************************************************
delay
    ldy #0                                          ;
delay_loop
    dey                                             ;
    bne delay_loop                                  ;
    dex                                             ;
    bne delay_loop                                  ;
    rts                                             ;

; ***************************************************************************************
handle_player_jumping
    lda player_jump_timer                           ;
    beq leave27                                     ;
    tax                                             ;
    lda player_y_in_enemies                         ;
    clc                                             ;
    adc jump_parabola_table,X                       ;
    sta player_y_in_enemies                         ;
    dec player_jump_timer                           ;
    bne leave27                                     ;
    and #$fc                                        ; when jump finishes, align to a 4 pixel boundary in Y
    sta player_y_in_enemies                         ;
leave27
    rts                                             ;

; ***************************************************************************************
screen_address_lookup_table
    !byte (>screen_memory_start) + $00
    !byte (>screen_memory_start) + $02
    !byte (>screen_memory_start) + $04
    !byte (>screen_memory_start) + $06
    !byte (>screen_memory_start) + $08
    !byte (>screen_memory_start) + $0a
    !byte (>screen_memory_start) + $0c
    !byte (>screen_memory_start) + $0e
    !byte (>screen_memory_start) + $10
    !byte (>screen_memory_start) + $12
    !byte (>screen_memory_start) + $14
    !byte (>screen_memory_start) + $16
    !byte (>screen_memory_start) + $18
    !byte (>screen_memory_start) + $1a
    !byte (>screen_memory_start) + $1c
    !byte (>screen_memory_start) + $1e
    !byte (>screen_memory_start) + $20
    !byte (>screen_memory_start) + $22
    !byte (>screen_memory_start) + $24
    !byte (>screen_memory_start) + $26
    !byte (>screen_memory_start) + $28
    !byte (>screen_memory_start) + $2a
    !byte (>screen_memory_start) + $2c
    !byte (>screen_memory_start) + $2e
    !byte (>screen_memory_start) + $30
    !byte (>screen_memory_start) + $32
    !byte (>screen_memory_start) + $34
    !byte (>screen_memory_start) + $36
    !byte (>screen_memory_start) + $38
    !byte (>screen_memory_start) + $3a
    !byte (>screen_memory_start) + $3c
    !byte (>screen_memory_start) + $3e

; ***************************************************************************************
set_text_position
    ; Screen address = screen_start + (Y * 512 + 16 * X)
    lda #0                                      ;
    sta text_screen_high                        ;
    txa                                         ;
    asl                                         ;
    asl                                         ;
    asl                                         ;
    asl                                         ;
    rol text_screen_high                        ;
    sta text_screen_low                         ;
    tya                                         ;
    asl                                         ;
    clc                                         ;
    adc text_screen_high                        ;
    adc #>screen_memory_start                   ;
    sta text_screen_high                        ;
    rts                                         ;

; ***************************************************************************************
; Write character A at current character position
; Text Source address = character_set_definitions_start + (8 * A)
; Preserves A,X,Y and flags
write_char
    sta temp3                                   ;
    stx temp4                                   ;
    sty temp5                                   ;
    cmp #9                                      ;
    bne +                                       ;
    jsr move_to_next_screen_cell                ;
    jsr move_to_next_screen_cell                ;
    jmp finish_up_write_char                    ;
+
    cmp #32                                     ;
    bcc finish_up_write_char                    ;
    ldx #$bf                                    ;
    lda is_master                               ;
    beq +                                       ; if (bbc b) then branch
    lda ROMSEL                                  ;
    sta old_romsel                              ;
    lda #128                                    ;
    sta ROMSEL                                  ;
    ldx #$88                                    ;
+
    stx origin_of_character_definitions_high    ;
    lda temp3                                   ;
    asl                                         ;
    asl                                         ;
    rol character_definitions_high              ;
    asl                                         ;
    rol character_definitions_high              ;
    sta character_definitions_low               ;
    lda character_definitions_high              ;
    and #3                                      ;
    clc                                         ;
origin_of_character_definitions_high = * + 1
    adc #$bf                                    ; $bf => $c000 for BBC B, $88 => $8900 for Master
    sta character_definitions_high              ;

write_char_internal
    ; leftmost four pixels of character
    ldy #7                                      ;
-
    lda (character_definitions_low), Y          ;

    and #$f0                                    ; }
    sta temp2                                   ; }
    lsr                                         ; }
    lsr                                         ; }
    lsr                                         ; } adjust colour to white
    lsr                                         ; }
    clc                                         ; }
    adc temp2                                   ; }
    and text_colour_mask                        ; set colour
    sta (text_screen_low), Y                    ; store byte to screen
    dey                                         ;
    bpl -                                       ;

    jsr move_to_next_screen_cell                ; move to right hand side of character

    ; do rightmost four pixels of each character
    ldy #7                                      ;
-
    lda (character_definitions_low), Y          ;

    and #15                                     ; }
    sta temp2                                   ; }
    asl                                         ; }
    asl                                         ; }
    asl                                         ; } adjust colour to white
    asl                                         ; }
    clc                                         ; }
    adc temp2                                   ; }
    and text_colour_mask                        ; set colour
    sta (text_screen_low), Y                    ; store byte to screen
    dey                                         ;
    bpl -                                       ;

    jsr move_to_next_screen_cell                ; move to next cell
finish_up_write_char
    ldy temp5                                   ;
    ldx temp4                                   ;
    lda temp3                                   ;
    rts                                         ;

move_to_next_screen_cell
    lda text_screen_low                         ;
    clc                                         ;
    adc #8                                      ;
    sta text_screen_low                         ; move to next character cell
    bcc +                                       ;
    inc text_screen_high                        ;
+
    rts                                         ;

; ***************************************************************************************
;
; Send byte to sound chip
;
; On Entry:
;   A = byte to send
;
; On Exit:
;   Preserves X
;
; Notes:
; To write pitch P (10 bit integer) to channel C (0-2, or 3=noise) and set volume V:
;
; write first byte:   128 + 32*C + top four bits of pitch P (0-15)
; write second byte:  lower 6 bits of pitch P
;
; To set volume V (0-15) on channel C (0-2, or 3=noise):
; write volume byte:  128 + 32*C + 16 + volume (0-15, 0 = loudest)
;
; ***************************************************************************************
send_to_sound_chip
    ldy #$ff                                            ; }
    sty systemVIADataDirectionRegisterA                 ; } set data direction to all outputs
    sta systemVIARegisterANoHandshake                   ; send data byte to sound chip
    iny                                                 ; Y=0
    sty systemVIARegisterB                              ; set the write enable line low (active)
                                                        ; to let the sound chip know there
                                                        ; is data
    jsr +                                               ; execute a short delay (this is to
                                                        ; keep the write enable line low for
                                                        ; at least 8 us, 16 cycles. This is
                                                        ; required by the sound chip hardware)
    ldy #8                                              ; }
    sty systemVIARegisterB                              ; } pull the write enable line high (inactive)
+
    rts                                                 ;

; ***************************************************************************************
tile_table
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

; ***************************************************************************************
space_sprite
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

player_background_buffer
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

; ***************************************************************************************
sprite_arrow_left                                   ; 2 bits per pixel, 8x8, stored in screen order
    !byte $00, $00                                  ; ........
    !byte $44, $ff                                  ; ........
    !byte $44, $00                                  ; .#....##
    !byte $00, $00                                  ; #######.
    !byte $00, $00                                  ; .#....##
    !byte $33, $ee                                  ; ........
    !byte $33, $00                                  ; ........
    !byte $00, $00                                  ; ........

sprite_arrow_right
    !byte $00, $00                                  ; ........
    !byte $cc, $77                                  ; ........
    !byte $cc, $00                                  ; ##....#.
    !byte $00, $00                                  ; .#######
    !byte $00, $00                                  ; ##....#.
    !byte $22, $ff                                  ; ........
    !byte $22, $00                                  ; ........
    !byte $00, $00                                  ; ........

; ***************************************************************************************
unpacked_conveyor_sprite
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

unpacked_background_sprite
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

; ***************************************************************************************
;
; clear screen memory from $5600-$7fff
;
; ***************************************************************************************
clear_screen
    ldy #>($8000-screen_memory_start)               ;
clear_screen_y
    lda #>screen_memory_start                       ;
    sta clear_screen_loop + 2                       ;
    ldx #0                                          ;
    lda #0                                          ;
clear_screen_loop
    sta screen_memory_start,x                       ;
    inx                                             ;
    bne clear_screen_loop                           ;
    inc clear_screen_loop + 2                       ;
    dey                                             ;
    bne clear_screen_loop                           ;
    rts                                             ;

; ***************************************************************************************
;
; Map
;                                 $01
;                         $02 3 4 $05 6 7 $08
;                     $09 $0A $0B $0C $0D $0E
;             $0F $10 $11 $12 $13 $14 $15 $16
;             $17 $18 $19 $1A $1B $1C $1D $1E         $29 $2A
;             $1F $20 $21 $22 $23 $24 $25 $26 $27 $28 $2B $2C $2D
; $2E $2F $30 $31 $32                         $33 $34 $35 $36 $37 $38 $39
;                                                 $3A $3B $3C
;
!src "definitions.a"

; ***************************************************************************************
unpacked_sprites                                    ; 2 bits per pixel, 16x16, vertically inverted
player_sprite_left_frame_0
    !byte $33, $11, $cc, $00                        ; ....####........
    !byte $77, $00, $cc, $00                        ; ....####........
    !byte $55, $bb, $88, $00                        ; ...######.......
    !byte $11, $ff, $00, $00                        ; ....#.##........
    !byte $66, $ff, $66, $00                        ; ...#####........
    !byte $77, $ff, $ee, $00                        ; ....####........
    !byte $33, $ff, $cc, $00                        ; .....##.........
    !byte $11, $ff, $88, $00                        ; ....####........
    !byte $00, $ff, $00, $00                        ; ...######.......
    !byte $00, $66, $00, $00                        ; ..########......
    !byte $00, $ff, $00, $00                        ; .##########.....
    !byte $11, $ff, $00, $00                        ; .##.####.##.....
    !byte $00, $bb, $00, $00                        ; ...#####........
    !byte $11, $ff, $88, $00                        ; .#.##.###.......
    !byte $00, $ff, $00, $00                        ; .###....##......
    !byte $00, $ff, $00, $00                        ; ..##...###......

player_sprite_left_frame_1
    !byte $00, $ee, $ee, $00                        ; ......####......
    !byte $00, $77, $66, $00                        ; ......####......
    !byte $00, $66, $ee, $00                        ; .....######.....
    !byte $00, $33, $cc, $00                        ; ......#.##......
    !byte $00, $dd, $ff, $00                        ; .....#####......
    !byte $00, $ee, $ff, $00                        ; ......####......
    !byte $00, $77, $ee, $00                        ; .......##.......
    !byte $00, $77, $ee, $00                        ; ......####......
    !byte $00, $33, $cc, $00                        ; .....######.....
    !byte $00, $11, $88, $00                        ; .....######.....
    !byte $00, $33, $cc, $00                        ; ....###.####....
    !byte $00, $77, $cc, $00                        ; ....##.#####....
    !byte $00, $22, $cc, $00                        ; ......####......
    !byte $00, $77, $ee, $00                        ; .....##.###.....
    !byte $00, $33, $cc, $00                        ; .....###.##.....
    !byte $00, $33, $cc, $00                        ; ....###.###.....

player_sprite_left_frame_2
    !byte $00, $00, $ee, $00                        ; ........####....
    !byte $00, $00, $66, $00                        ; ........####....
    !byte $00, $00, $66, $00                        ; .......######...
    !byte $00, $00, $ff, $00                        ; ........#.##....
    !byte $00, $11, $bb, $88                        ; .......#####....
    !byte $00, $11, $dd, $88                        ; ........####....
    !byte $00, $11, $dd, $88                        ; .........##.....
    !byte $00, $11, $dd, $88                        ; ........####....
    !byte $00, $00, $ff, $00                        ; .......###.##...
    !byte $00, $00, $66, $00                        ; .......###.##...
    !byte $00, $00, $ff, $00                        ; .......###.##...
    !byte $00, $11, $ff, $00                        ; .......##.###...
    !byte $00, $00, $bb, $00                        ; ........####....
    !byte $00, $11, $ff, $88                        ; .........##.....
    !byte $00, $00, $ff, $00                        ; .........##.....
    !byte $00, $00, $ff, $00                        ; ........###.....

player_sprite_left_frame_3
    !byte $00, $00, $ee, $ee                        ; ..........####..
    !byte $00, $00, $77, $66                        ; ..........####..
    !byte $00, $00, $66, $ee                        ; .........######.
    !byte $00, $00, $33, $cc                        ; ..........#.##..
    !byte $00, $00, $dd, $ff                        ; .........#####..
    !byte $00, $00, $ee, $ff                        ; ..........####..
    !byte $00, $00, $77, $ee                        ; ...........##...
    !byte $00, $00, $77, $ee                        ; ..........####..
    !byte $00, $00, $33, $cc                        ; .........######.
    !byte $00, $00, $11, $88                        ; .........######.
    !byte $00, $00, $33, $cc                        ; ........###.####
    !byte $00, $00, $77, $cc                        ; ........##.#####
    !byte $00, $00, $22, $cc                        ; ..........####..
    !byte $00, $00, $77, $ee                        ; .........##.###.
    !byte $00, $00, $33, $cc                        ; .........###.##.
    !byte $00, $00, $33, $cc                        ; ........###.###.

player_sprite_right_frame_0
    !byte $77, $77, $00, $00                        ; ..####..........
    !byte $66, $ee, $00, $00                        ; ..####..........
    !byte $77, $66, $00, $00                        ; .######.........
    !byte $33, $cc, $00, $00                        ; ..##.#..........
    !byte $ff, $bb, $00, $00                        ; ..#####.........
    !byte $ff, $77, $00, $00                        ; ..####..........
    !byte $77, $ee, $00, $00                        ; ...##...........
    !byte $77, $ee, $00, $00                        ; ..####..........
    !byte $33, $cc, $00, $00                        ; .######.........
    !byte $11, $88, $00, $00                        ; .######.........
    !byte $33, $cc, $00, $00                        ; ####.###........
    !byte $33, $ee, $00, $00                        ; #####.##........
    !byte $33, $44, $00, $00                        ; ..####..........
    !byte $77, $ee, $00, $00                        ; .###.##.........
    !byte $33, $cc, $00, $00                        ; .##.###.........
    !byte $33, $cc, $00, $00                        ; .###.###........

player_sprite_right_frame_1
    !byte $00, $77, $00, $00                        ; ....####........
    !byte $00, $66, $00, $00                        ; ....####........
    !byte $00, $66, $00, $00                        ; ...######.......
    !byte $00, $ff, $00, $00                        ; ....##.#........
    !byte $11, $dd, $88, $00                        ; ....#####.......
    !byte $11, $bb, $88, $00                        ; ....####........
    !byte $11, $bb, $88, $00                        ; .....##.........
    !byte $11, $bb, $88, $00                        ; ....####........
    !byte $00, $ff, $00, $00                        ; ...##.###.......
    !byte $00, $66, $00, $00                        ; ...##.###.......
    !byte $00, $ff, $00, $00                        ; ...##.###.......
    !byte $00, $ff, $88, $00                        ; ...###.##.......
    !byte $00, $dd, $00, $00                        ; ....####........
    !byte $11, $ff, $88, $00                        ; .....##.........
    !byte $00, $ff, $00, $00                        ; .....##.........
    !byte $00, $ff, $00, $00                        ; .....###........

player_sprite_right_frame_2
    !byte $00, $77, $77, $00                        ; ......####......
    !byte $00, $66, $ee, $00                        ; ......####......
    !byte $00, $77, $66, $00                        ; .....######.....
    !byte $00, $33, $cc, $00                        ; ......##.#......
    !byte $00, $ff, $bb, $00                        ; ......#####.....
    !byte $00, $ff, $77, $00                        ; ......####......
    !byte $00, $77, $ee, $00                        ; .......##.......
    !byte $00, $77, $ee, $00                        ; ......####......
    !byte $00, $33, $cc, $00                        ; .....######.....
    !byte $00, $11, $88, $00                        ; .....######.....
    !byte $00, $33, $cc, $00                        ; ....####.###....
    !byte $00, $33, $ee, $00                        ; ....#####.##....
    !byte $00, $33, $44, $00                        ; ......####......
    !byte $00, $77, $ee, $00                        ; .....###.##.....
    !byte $00, $33, $cc, $00                        ; .....##.###.....
    !byte $00, $33, $cc, $00                        ; .....###.###....

player_sprite_right_frame_3
    !byte $00, $33, $88, $cc                        ; ........####....
    !byte $00, $33, $00, $ee                        ; ........####....
    !byte $00, $11, $dd, $aa                        ; .......######...
    !byte $00, $00, $ff, $88                        ; ........##.#....
    !byte $00, $66, $ff, $66                        ; ........#####...
    !byte $00, $77, $ff, $ee                        ; ........####....
    !byte $00, $33, $ff, $cc                        ; .........##.....
    !byte $00, $11, $ff, $88                        ; ........####....
    !byte $00, $00, $ff, $00                        ; .......######...
    !byte $00, $00, $66, $00                        ; ......########..
    !byte $00, $00, $ff, $00                        ; .....##########.
    !byte $00, $00, $ff, $88                        ; .....##.####.##.
    !byte $00, $00, $dd, $00                        ; ........#####...
    !byte $00, $11, $ff, $88                        ; .......###.##.#.
    !byte $00, $00, $ff, $00                        ; ......##....###.
    !byte $00, $00, $ff, $00                        ; ......###...##..

; ***************************************************************************************
unpacked_enemy_sprites
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

next_index
    !byte 1, 2, 0
colour_array
    !byte $f0, $ff, $0f

; ***************************************************************************************
arrow_timers_table
    ;      0    1    2    3    4
    !byte $d0, $16, $1e, $26, $7f                   ; [Third value unused]

; ***************************************************************************************
paletteLookupTable
    !byte $00, $20, $80, $a0

; ***************************************************************************************
; This is what the jump parabola should be, but the engine has trouble with odd increments it seems.
; See West of Kitchen jumping up into The Banyan Tree; In Tree Root, jumping onto the cyan platform can cause problems.
; And other cases too.
;
;jump_parabola_table
;    !byte $00, $04, $04, $03, $03, $02, $02, $01, $01, $00, $00, $ff, $ff, $fe, $fe, $fd, $fd
;    !byte $fc, $fc

jump_parabola_table
    !byte $00, $04, $04, $04, $04, $02, $02, $02, $00, $00, $00, $00, $fe, $fe, $fe, $fe, $fc
    !byte $fc, $fc

; ***************************************************************************************
handle_rope_time_and_events
    lda room_contains_rope                          ;
    beq no_rope                                     ;
    jsr unplot_rope                                 ;
    lda #$80                                        ;
    sta rope_end_x                                  ;
    lda #0                                          ;
    sta rope_pixel_touched                          ;
    sta rope_end_y                                  ;
    ldx rope_position                               ;
    lda #$1f                                        ;
    sta rope_pixel_to_consider                      ;
update_rope_pixels_loop
    jsr update_rope_pixel                           ;
    dec rope_pixel_to_consider                      ;
    bne update_rope_pixels_loop                     ;
    lda rope_velocity_relative_to_centre            ;
    asl                                             ;
    clc                                             ;
    adc rope_position                               ;
    tay                                             ;
    cmp #$d2                                        ;
    bne rope_didnt_change_sides                     ;
    lda rope_position_relative_to_centre            ;
    eor #$ff                                        ;
    sta rope_position_relative_to_centre            ;
    lda #8                                          ;
rope_didnt_change_sides
    cmp #8                                          ;
    bne rope_didnt_reach_end                        ;
    lda rope_velocity_relative_to_centre            ;
    eor #$ff                                        ;
    sta rope_velocity_relative_to_centre            ;
    inc rope_velocity_relative_to_centre            ;
rope_didnt_reach_end
    sty rope_position                               ;
    jsr check_for_player_contact_with_rope          ;
no_rope
    jsr handle_time                                 ;
    jmp handle_endgame                              ;

; ***************************************************************************************
update_rope_pixel
    stx rope_pixel_position                         ;
    txa                                             ;
    bpl skip_floor1                                 ;
    ldx #$26                                        ;
    cmp #$f0                                        ;
    bcs skip_floor1                                 ;
    ldx #$27                                        ;
skip_floor1
    lda rope_x_delta_table,X                        ;
    cmp rope_position_relative_to_centre            ;
    bcc skip_inversion1                             ;
    eor #$ff                                        ;
skip_inversion1
    adc rope_end_x                                  ;
    sta rope_end_x                                  ;
    lda rope_end_y                                  ;
    clc                                             ;
    adc rope_y_delta_table,X                        ;
    sta rope_end_y                                  ;
    ldy rope_pixel_to_consider                      ;
    sta rope_pixels_y,Y                             ;
    tax                                             ;
    lda rope_end_x                                  ;
    sta rope_pixels_x,Y                             ;
    jsr plot_rope_pixel                             ;
    lda screen_address_low                          ;
    ldx rope_pixel_to_consider                      ;
    sta rope_pixels_screen_address_low_table,X      ;
    lda screen_address_high                         ;
    sta rope_pixels_screen_address_high_table,X     ;
    ldx rope_pixel_position                         ;
    inx                                             ;
    rts                                             ;

; ***************************************************************************************
plot_rope_pixel
    sta rope_pixel_x                                ;
    jsr calculate_screen_address                    ;
    ldy #0                                          ;
    lda (screen_address_low),Y                      ;
    beq rope_not_touching_player                    ; [Bug: triggers for enemies too (e.g. Cold Store)]
    lda rope_pixel_to_consider                      ;
    sta rope_pixel_touched                          ;
rope_not_touching_player
    lda rope_pixel_x                                ;
    and #3                                          ;
    tax                                             ;
    lda rope_pixel_values_table,X                   ;
    sta (screen_address_low),Y                      ;
    rts                                             ;

rope_pixel_values_table
    !byte $88, $44, $22, $11

; ***************************************************************************************
unplot_rope
    ldx #$1f                                        ;
    ldy #0                                          ;
unplot_rope_loop
    lda rope_pixels_screen_address_low_table,X      ;
    sta rope_pixels_screen_address_low              ;
    lda rope_pixels_screen_address_high_table,X     ;
    sta rope_pixels_screen_address_high             ;
    lda #0                                          ;
    sta (rope_pixels_screen_address_low),Y          ;
    dex                                             ;
    bpl unplot_rope_loop                            ;
    rts                                             ;

; ***************************************************************************************
check_for_player_contact_with_rope
    ldx player_rope_pixel                           ;
    bne player_already_on_rope                      ;
    lda rope_pixel_touched                          ;
    beq leave1                                      ;
    ldx #0                                          ;
    stx player_entered_room_falling_too_far         ;
    lda player_y_in_enemies                         ;
check_y_loop
    inx                                             ;
    cmp rope_pixels_y,X                             ;
    bcc check_y_loop                                ;
    cpx #2                                          ;
    bcc remove_player_from_rope                     ;
    stx player_rope_pixel                           ;
player_already_on_rope
    lda player_jump_timer                           ;
    cmp #$0e                                        ;
    bcs remove_player_from_rope                     ;
    lda #0                                          ;
    sta player_is_jumping                           ;
    sta player_jump_timer                           ;
    lda rope_pixels_x,X                             ;
    sec                                             ;
    sbc #4                                          ;
    and #$fe                                        ;
    sta player_x_in_enemies                         ;
    lda rope_pixels_y,X                             ;
    sec                                             ;
    sbc #6                                          ;
    bpl skip_floor2                                 ;
    lda #$c0                                        ;
skip_floor2
    sta player_y_in_enemies                         ;
    lda player_horizontal_speed                     ;
    beq leave1                                      ;
    lda rope_position_relative_to_centre            ;
    eor rope_velocity_relative_to_centre            ;
    inx                                             ;
    eor player_horizontal_speed                     ;
    bpl player_moving_up_rope                       ;
player_moving_down_rope
    dex                                             ;
    dex                                             ;
player_moving_up_rope
    stx player_rope_pixel                           ;
    cpx #3                                          ;
    bcs leave1                                      ;
    lda player_y_in_enemies                         ; Make player fall off bottom of rope
    adc #4                                          ;
    sta player_y_in_enemies                         ;
remove_player_from_rope
    lda player_y_in_enemies                         ;
    and #$fc                                        ;
    sta player_y_in_enemies                         ;
    lda #0                                          ;
    sta player_rope_pixel                           ;
leave1
    rts                                             ;

; ***************************************************************************************
write_status_line
    ldx #0                                          ;
    ldy #20                                         ;
    jsr set_text_position                           ;
    ldx #$ff                                        ;
write_items_collected_loop
    inx                                             ;
    lda items_collected_string,X                    ;
    jsr write_char                                  ;
    cmp #0                                          ;
    bne write_items_collected_loop                  ;
    jsr write_items_collected                       ;
    jmp write_time                                  ;

items_collected_string
    !text "Items collected 000 Time  7:00pm", 0     ;

; ***************************************************************************************
collect_item
    ldx #2                                          ; Play sound for collecting item
    jsr start_sound_x                               ;
    inc items_collected_low                         ;
    lda items_collected_low                         ;
    cmp #$0a                                        ;
    bcc write_items_collected                       ;
    inc items_collected_high                        ;
    lda #0                                          ;
    sta items_collected_low                         ;
    lda items_collected_high                        ;
    cmp #8                                          ;
    bcc write_items_collected                       ;
    inc house_clear                                 ; 80 items needed to clear house
write_items_collected
    ldx #$11                                        ;
    ldy items_collected_high                        ;
    jsr write_digit_y_at_status_line_column_x       ;
    lda items_collected_low                         ;
    jmp write_digit_a                               ;

; ***************************************************************************************
write_digit_y_at_status_line_column_x
    sty temp5                                       ;
    ldy #20                                         ;
    jsr set_text_position                           ;
    lda temp5                                       ;
write_digit_a
    clc                                             ;
    adc #'0'                                        ;
    jmp write_char                                  ;

; ***************************************************************************************
handle_time
    dec game_timer                                  ;
    bne leave2                                      ;
    inc time_fraction                               ;
    lda time_fraction                               ;
    cmp #3                                          ;
    bne leave2                                      ;
    ldy #0                                          ;
    sty time_fraction                               ;
    inc minutes_low                                 ;
    lda minutes_low                                 ;
    cmp #10                                         ;
    bcc write_time                                  ;
    sty minutes_low                                 ;
    inc minutes_high                                ;
    lda minutes_high                                ;
    cmp #6                                          ;
    bcc write_time                                  ;
    sty minutes_high                                ;
    inc hours_low                                   ;
    lda hours_low                                   ;
    cmp #10                                         ;
    bcc +                                           ;
    sty hours_low                                   ;
    lda #1                                          ;
    sta hours_high                                  ;
+
    lda hours_low                                   ;
    cmp #2                                          ;
    bne write_time                                  ;
    lda hours_high                                  ;
    bmi write_time                                  ;
    inc out_of_time                                 ;
    inc player_killed                               ;
write_time
    ldx #$19                                        ;
    ldy hours_high                                  ;
    jsr write_digit_y_at_status_line_column_x       ;
    lda hours_low                                   ;
    jsr write_digit_a                               ;
    lda #':'                                        ;
    jsr write_char                                  ;
    lda minutes_high                                ;
    jsr write_digit_a                               ;
    lda minutes_low                                 ;
    jsr write_digit_a                               ;
leave2
    rts                                             ;

; ***************************************************************************************
reset_game
    lda #0                                          ;
    sta time_fraction                               ;
    sta player_entered_room_falling_too_far         ;
    sta items_collected_low                         ;
    sta items_collected_high                        ;
    sta minutes_low                                 ;
    sta minutes_high                                ;
    sta house_clear                                 ;
    sta out_of_time                                 ;
    sta player_is_jumping                           ;
    sta player_jump_timer                           ;
    sta swimming_pool_item_collected                ;
    lda #2                                          ;
    sta player_speed                                ; face right
    lda #$f0                                        ;
    sta hours_high                                  ;
    lda #7                                          ; Game starts at 7:00pm
    sta hours_low                                   ;
    lda #7                                          ; Player starts with 7 lives
    sta player_lives                                ;
    lda #player_start_y                             ;
    sta player_y_in_enemies                         ;
    lda #player_start_x                             ;
    sta player_x_in_enemies                         ;
    lda #player_start_room                          ; Player starts in "The Bathroom"
    sta player_room                                 ;
    jmp reset_items                                 ;

; ***************************************************************************************
handle_endgame
    lda player_room                                 ;
    cmp #$13                                        ; Master Bedroom
    bne not_master_bedroom                          ;
    lda player_y_in_enemies                         ;
    cmp #$67                                        ;
    bcs below_maria                                 ;
    ldx #$0a                                        ;
    cmp #$60                                        ;
    bcs set_maria_offset                            ;
    ldx #$0b                                        ; Make Maria raise her arm when Willy in line of sight
    bne set_maria_offset                            ;
below_maria
    lda enemies_unpacked_sprite_offset + 1          ;
    and #9                                          ;
    eor #1                                          ;
    sta enemies_unpacked_sprite_offset + 1          ;
    tax                                             ;
set_maria_offset
    stx enemies_unpacked_sprite_offset + 1          ;
not_master_bedroom
    cmp #$15                                        ; The Bathroom
    bne not_the_bathroom                            ;
    lda game_timer                                  ;
    and #1                                          ;
    bne not_the_bathroom                            ;
    lda enemies_unpacked_sprite_offset + 2          ;
    eor #1                                          ; Make the toilet flap its lid
    sta enemies_unpacked_sprite_offset + 2          ;
not_the_bathroom
    lda house_clear                                 ;
    beq leave4                                      ; Has the player collected all the items?
    bmi dash_for_toilet                             ; If so, are they dashing for the toilet?
check_for_pillow
    lda player_room                                 ;
    cmp #$13                                        ; Master Bedroom
    bne leave4                                      ;
    lda #0                                          ;
    sta enemies_colour + 1                          ; Hide Maria if all items have been collected
    lda player_x_in_enemies                         ;
    cmp #$18                                        ;
    bne leave4                                      ; Is the player about to touch the pillow?
    lda #$ff                                        ; If so, make them dash for the toilet
    sta house_clear                                 ;
    rts                                             ;

; ***************************************************************************************
dash_for_toilet
    lda #2                                          ;
    sta player_horizontal_speed                     ; Make the player move right.
    lda #0                                          ;
    sta player_started_jump                         ;
    lda player_room                                 ;
    cmp #$14                                        ; Top Landing ; Is the player in Top Landing?
    bne not_top_landing                             ;
    lda player_x_in_enemies                         ;
    cmp #$88                                        ; Jump over hole
    beq force_jump                                  ;
    cmp #$b0                                        ; Jump over enemy
    bne leave3                                      ;
force_jump
    inc player_started_jump                         ;
leave3
    rts                                             ;
not_top_landing
    bcc leave4                                      ; Is the player in The Bathroom?
    lda player_x_in_enemies                         ;
    cmp #$d8                                        ;
    bcc leave4                                      ; Is the player about to touch the toilet?
    lda #$0a                                        ;
    ora enemies_unpacked_sprite_offset + 2          ;
    sta enemies_unpacked_sprite_offset + 2          ; Set the toilet to contain the player's legs.
    lda #2                                          ;
    sta player_not_plotted                          ; Set the player to be unplotted, but not plotted
leave4
    rts                                             ;

; ***************************************************************************************
mark_enemies_that_overlap_player                    ; Called with tile_address_low1 of the player
    ldy #$20                                        ;
    jsr check_tiles_for_enemy                       ;
    ldy #$40                                        ;
    jsr check_tiles_for_enemy                       ;
    lda player_y_in_enemies                         ;
    and #7                                          ;
    beq leave5                                      ;
    ldy #$60                                        ;
check_tiles_for_enemy
    jsr check_tile_for_enemy                        ;
    iny                                             ;
check_tile_for_enemy
    lda (tile_address_low1),Y                           ;
    bpl leave5                                      ; Is there an enemy in this tile?
    cmp #$8a                                        ;
    bcs leave5                                      ;
    and #$0f                                        ;
    tax                                             ;
    lda #2                                          ;
    sta enemies_need_replot,X                       ; Set enemy to not need unplotting, killing player
leave5
    rts                                             ;

; ***************************************************************************************
update_arrows
    ldy #1                                          ;
update_arrows_loop
    ldx arrow_timer,Y                               ;
    bmi update_active_arrow                         ;
    beq consider_next_arrow1                        ;
    lda game_timer                                  ;
    and #1                                          ;
    bne consider_next_arrow1                        ;
    dex                                             ;
    bne no_new_arrow                                ;
    lda #$ff                                        ;
    sta arrow_timer,Y                               ;
    lda arrow_initial_x_positions,Y                 ;
    sta arrow_x,Y                                   ;
    jmp arrow_still_active                          ;

no_new_arrow
    txa                                             ;
    sta arrow_timer,Y                               ;
    cmp #3                                          ;
    bne consider_next_arrow1                        ;
    ldx #1                                          ; Play sound for arrow firing
    jsr start_sound_x                               ;
consider_next_arrow1
    dey                                             ;
    bpl update_arrows_loop                          ;
    rts                                             ;

; ***************************************************************************************
update_active_arrow
    jsr plot_arrow                                  ; Unplot arrow
    lda arrow_x,Y                                   ;
    clc                                             ;
    adc arrow_speeds,Y                              ;
    sta arrow_x,Y                                   ;
    cmp arrow_initial_x_positions,Y                 ;
    bne arrow_still_active                          ;
    lda #$7f                                        ;
    sta arrow_timer,Y                               ;
    bpl consider_next_arrow1                        ;
arrow_still_active
    jsr plot_arrow                                  ;
    ldx #8                                          ; Use enemy slot 8 for arrow
    jsr calculate_tile_address_for_enemy_X          ;
    ldy #$20                                        ;
    lda (tile_address_low1),Y                       ;
    ldy arrow                                       ;
    sta arrow_active,Y                              ;
    jmp consider_next_arrow1                        ;

plot_arrow
    sty arrow                                       ;
    lda arrow_x,Y                                   ;
    sta enemies_x + 8                               ;
    ldx arrow_y,Y                                   ;
    stx enemies_y + 8                               ;
    jsr calculate_screen_address                    ;
    lda arrow_sprite_offsets_low,Y                  ;
    sta arrow_sprite_address_low                    ;
    lda arrow_sprite_offsets_high,Y                 ;
    sta arrow_sprite_address_high                   ;
    lda arrow_active,Y                              ;
    bmi unplot_arrow                                ;
    ldy #$0f                                        ;
plot_arrow_loop
arrow_sprite_address_low = * + 1
arrow_sprite_address_high = * + 2
    lda sprite_arrow_left,Y                         ; [address is overwritten before use]
    eor (screen_address_low),Y                      ;
    sta (screen_address_low),Y                      ;
    dey                                             ;
    bne plot_arrow_loop                             ;
    ldy arrow                                       ;
    rts                                             ;
unplot_arrow
    lda #0                                          ;
    sta arrow_active,Y                              ;
    ldy #$0f                                        ;
wipe_arrow_loop
    sta (screen_address_low),Y                      ;
    dey                                             ;
    bne wipe_arrow_loop                             ;
    ldy arrow                                       ;
    rts                                             ;

; ***************************************************************************************
arrow_sprite_offsets_low
    !byte <sprite_arrow_right, <sprite_arrow_left
arrow_sprite_offsets_high
    !byte >sprite_arrow_right, >sprite_arrow_left

arrow_initial_x_positions
    !byte $00, $f8

arrow_speeds
    !byte $08, $f8

arrow_x
    !byte $00, $00

arrow_active
    !byte $00, $00

; ***************************************************************************************
update_lives
    lda game_timer                                  ;
    and #3                                          ;
    bne leave6                                      ;
life_sprite_address_low = * + 1
    lda #$00                                        ;
    clc                                             ;
    adc #64                                         ;
    sta life_sprite_address_low                     ;
    clc                                             ;
    adc #<player_sprite_right_frame_0               ;
    sta sprite_address_low2                         ;
    lda #>player_sprite_right_frame_0               ;
    adc #0                                          ;
    sta sprite_address_high2                        ;
    lda #3                                          ;
    sta life_colour                                 ;
    lda #$f0                                        ;
    sta life_x                                      ;
    lda player_lives                                ;
    beq leave6                                      ;
    sta lives_remaining_to_plot                     ;
update_lives_loop
    ldx life_colour                                 ;
    dex                                             ;
    bne skip_floor3                                 ;
    ldx #3                                          ;
skip_floor3
    stx life_colour                                 ;
    lda life_colours,X                              ;
    sta sprite_colour                               ;
    lda life_x                                      ;
    clc                                             ;
    adc #$10                                        ;
    sta life_x                                      ;
    ldx life_y                                      ;
    jsr plot_sprite                                 ;
    dec lives_remaining_to_plot                     ;
    bne update_lives_loop                           ;
leave6
    rts                                             ;

; ***************************************************************************************
palette_changes
    !byte $ff                                       ; row 0
    !byte $ff                                       ; row 1
    !byte $ff                                       ; row 2
    !byte $ff                                       ; row 3
    !byte $ff                                       ; row 4
    !byte $ff                                       ; row 5
    !byte $ff                                       ; row 6
    !byte $ff                                       ; row 7
    !byte $ff                                       ; row 8
    !byte $ff                                       ; row 9
    !byte $ff                                       ; row 10
    !byte $ff                                       ; row 11
    !byte $ff                                       ; row 12
    !byte $ff                                       ; row 13
    !byte $ff                                       ; row 14
    !byte $ff                                       ; row 15

palette_loop_counter
    !byte 0

; ***************************************************************************************
start_of_palettes
room_palette
    !byte black                                     ; logical colour 0
    !byte black                                     ; logical colour 1
    !byte black                                     ; logical colour 2
    !byte black                                     ; logical colour 3
footer_palette
    !byte black                                     ; logical colour 0
    !byte magenta                                   ; logical colour 1
    !byte cyan                                      ; logical colour 2
    !byte yellow                                    ; logical colour 3
title_palette
    !byte black                                     ; logical colour 0
    !byte red                                       ; logical colour 1
    !byte green                                     ; logical colour 2
    !byte white                                     ; logical colour 3
game_over_palette
    !byte black
    !byte yellow
    !byte white
    !byte blue

; ***************************************************************************************
initialise_room_background_tiles_and_title
    ldy #5                                          ; For each of six tile types
set_tile_colours_loop
    ldx #2                                          ;
    jsr get_x_bits_of_room_data                     ; Get two bits of room data for each tile colour
    sta background_tiles_colours_fg,Y               ;
    ldx #2                                          ;
    jsr get_x_bits_of_room_data                     ; Get two bits of room data for each tile colour (background)
    sta background_tiles_colours_bg,Y               ;
    dey                                             ;
    bpl set_tile_colours_loop                       ;

    ldy #6                                          ; For each of seven tile types
set_tile_sprites_loop
    ldx #8                                          ; Get eight bits of room data for each tile sprite
    jsr get_x_bits_of_room_data                     ;
    sta background_tiles_sprites,Y                  ;
    dey                                             ;
    bpl set_tile_sprites_loop                       ;

    ldy #3                                          ; For each of four screen colours
set_screen_colours_loop
    ldx #3                                          ;
    jsr get_x_bits_of_room_data                     ; Get three bits of room data for each screen colour
    sta room_palette,Y                              ;
    dey                                             ;
    bpl set_screen_colours_loop                     ;

    jsr clear_room_palette_changes                  ;

    ldx #4
    jsr get_x_bits_of_room_data                     ; Get four bits of room data for number of palette changes
    beq +                                           ;
    sta palette_loop_counter                        ;
-
    ldx #4                                          ;
    jsr get_x_bits_of_room_data                     ; Get four bits of room data for row of palette change
    tay
    ldx #5                                          ;
    jsr get_x_bits_of_room_data                     ; Get five bits of room data for palette change value
    sta palette_changes,Y                           ;
    dec palette_loop_counter                        ;
    bne -                                           ;

+
    lda #1                                          ; First word is uppercase
    sta start_of_word                               ;

    ldx #4                                          ; Get four bits of room data for position of room title
    jsr get_x_bits_of_room_data                     ;
    tax
    ldy #$10                                        ;
    jsr set_text_position                           ; TAB to start of room title

write_room_title_loop
    ldx #5                                          ; Get five bits of room data for each character of title
    jsr get_x_bits_of_room_data                     ;
    cmp #$1b                                        ;
    bcs is_1b_1c_1d_1e_or_1f                        ;
    jsr write_letter                                ; $00 to $1a writes "a" to "z"
    jmp write_room_title_loop                       ;

; ***************************************************************************************
is_1b_1c_1d_1e_or_1f
    bne is_1c_1d_1e_or_1f                           ;
    lda #$27                                        ; "'" ; $1b writes "'"
    jsr write_char                                  ;
    jmp write_room_title_loop                       ;

; ***************************************************************************************
is_1c_1d_1e_or_1f
    cmp #$1d                                        ;
    beq is_1d                                       ;
    bcs is_1e_or_1f                                 ;

    ; $1c ends room title
    ; move title text down one pixel
    lda #<(screen_address_title + 7)                ;
    sta title_text_source_low                       ;
    lda #>(screen_address_title + 7)                ;
    sta title_text_source_high                      ;

    lda #<(screen_address_title + $0200)            ;
    sta title_text_destination_low                  ;
    lda #>(screen_address_title + $0200)            ;
    sta title_text_destination_high                 ;

    lda #8
    sta move_title_down_loop_counter                ;
-
    jsr copy_row                                    ;

    ; destination is the old source
    lda title_text_source_low                       ;
    sta title_text_destination_low                  ;
    lda title_text_source_high                      ;
    sta title_text_destination_high                 ;

    ; update source
    dec title_text_source_low                       ;
    dec move_title_down_loop_counter                ;
    bne -

    ldy #0                                          ;
-
    lda #0                                          ;
    sta screen_address_title,Y                      ;
    sta screen_address_title + $0100,Y              ;
    tya                                             ;
    clc                                             ;
    adc #8                                          ;
    tay                                             ;
    bne -                                           ;

    rts                                             ;

move_title_down_loop_counter
    !byte 0

; ***************************************************************************************
copy_row
    ldx #1                                          ;
    ldy #0                                          ;
-
    lda (title_text_source_low),Y                   ;
    sta (title_text_destination_low),Y              ;
    tya                                             ;
    clc                                             ;
    adc #8                                          ;
    tay                                             ;
    bne -                                           ;
    inc title_text_source_high                      ;
    inc title_text_destination_high                 ;
    dex                                             ;
    bpl -                                           ;
    dec title_text_source_high                      ;
    dec title_text_source_high                      ;
    dec title_text_destination_high                 ;
    dec title_text_destination_high                 ;
    rts                                             ;

; ***************************************************************************************
is_1e_or_1f
    cmp #$1e                                        ;
    bne is_1f                                       ;
    inc buffer_offset                               ; start_of_word ; $1e writes " ", resetting case
is_1d
    lda #' '                                        ; $1d writes " ", keeping lower case
    jsr write_char                                  ;
    jmp write_room_title_loop                       ;
is_1f
    lda #$13                                        ; "t" ; $1f writes "The"
    jsr write_letter                                ;
    lda #'h'                                        ;
    jsr write_char                                  ;
    lda #'e'                                        ;
    jsr write_char                                  ;
    jmp write_room_title_loop                       ;

; ***************************************************************************************
write_letter
    clc                                             ;
    adc #'a'                                        ;
    ldy start_of_word                               ;
    beq lower_case                                  ;
    and #$df                                        ;
    ldx #0                                          ;
    stx start_of_word                               ;
lower_case
    jmp write_char                                  ;

; ***************************************************************************************
initialise_arrows
    ldy #1                                          ; For each of two arrows
initialise_arrows_loop
    lda #0                                          ;
    sta arrow_active,Y                              ;
    sta arrow_timer,Y                               ;
    ldx #1                                          ; Get one bit of room data for presence of arrow
    jsr get_x_bits_of_room_data                     ;
    tax                                             ;
    beq consider_next_arrow2                        ; If arrow present
    ldx #4                                          ; Get four bits of room data for arrow_y
    jsr get_x_bits_of_room_data                     ;
    tax                                             ;
    beq consider_next_arrow2                        ;
    asl                                             ;
    asl                                             ;
    asl                                             ;
    eor #$78                                        ;
    sta arrow_y,Y                                   ;
    ldx #3                                          ; Get three bits of room data for arrow timing
    jsr get_x_bits_of_room_data                     ;
    tax                                             ;
    lda arrow_timers_table,X                        ;
    sta arrow_timer,Y                               ;
    sta arrow_x,Y                                   ;
    sta arrow_active,Y                              ;
consider_next_arrow2
    dey                                             ;
    bpl initialise_arrows_loop                      ;

handle_room_tweaks_on_entry
    lda #0                                          ;
    ldy #$80                                        ;
    ldx player_room                                 ;
    cpx #$19                                        ; Swimming Pool
    bne fill_space_sprite                           ; Is this the Swimming Pool?
    lda swimming_pool_item_collected                ;
    bne already_collected_item                      ;
    inc swimming_pool_item_collected                ; If so, collect item on first visit
    jsr collect_item                                ;
already_collected_item
    ldx #0                                          ;
fill_enemy_with_water_loop
    lda #$f0                                        ; Set background of enemy sprite to be colour 2 (cyan)
    ora unpacked_enemy_sprites,X                    ;
    sta unpacked_enemy_sprites,X                    ;
    lda #$f0                                        ;
    ora unpacked_enemy_sprites + $100,X             ;
    sta unpacked_enemy_sprites + $100,X             ;
    dex                                             ;
    bne fill_enemy_with_water_loop                  ;
    lda #$f0                                        ; Set background of space sprite (used to unplot enemy
    ldy #1                                          ; after movement) to be the same. Use tile 1 for space
fill_space_sprite                                   ; so player can stand on swimming pool water.
    sty space_tile                                  ;
    ldx #$3f                                        ; [Bug: fills half of player_background_buffer too]
fill_space_sprite_loop
    sta space_sprite,X                              ;
    dex                                             ;
    bpl fill_space_sprite_loop                      ;
    ldx #0                                          ;
    lda player_room                                 ;
    cmp #$1b                                        ; Is this The Nightmare Room?
    bne not_nightmare_room                          ;
    lda #$10                                        ;
    sta enemies_unpacked_sprite_offset + 7          ; If so, change left-most enemy to use Maria sprite.
    lda #3                                          ; It is originally a pig, setting up the sprite for:
    sta enemies_sprite + 7                          ;
    ldx #8                                          ; Use pig for player sprite.
not_nightmare_room
    stx enemies_unpacked_sprite_offset              ; (otherwise use player)
    rts                                             ;

; ***************************************************************************************
real_entry_point
    jsr title_screen                                ;
    jsr reset_game                                  ;
new_life_loop
    jsr initialise_room                             ;
game_loop
    jsr update_lives                                ;
    jsr update_game                                 ;
    jsr check_for_suicide                           ;
    lda player_killed                               ;
    beq game_loop                                   ;
    lda player_lives                                ;
    bpl new_life_loop                               ;
game_over
    ldy #32                                         ;
    jsr clear_screen_y                              ;
    jsr clear_room_palette_changes                  ;
    lda #game_over_palette - start_of_palettes      ;
    jsr set_full_room_palette                       ;
    lda #3 + 4 * white                              ; Set logical colour 3 to white
    sta palette_changes + 12                        ;
    lda #1 + 4 * red                                ; Set logical colour 1 to red
    sta palette_changes + 14                        ;

    lda #0                                          ;
    jsr fill_space_sprite                           ; Ensure space sprite is black
    jsr animate_game_over_boot                      ;
    ldx #50                                         ;
    stx game_over_timer                             ;
game_over_loop
-
    lda vsync_counter                               ;
    cmp #5                                          ;
    bcc -
    ldy #0                                          ; loop counter
    sty vsync_counter                               ;

    ldx #11                                         ;
    ldy #8                                          ;
    jsr set_text_position                           ;

    ldy #0                                          ; loop counter
write_game_over_loop
colour_index = * + 1
    ldx #0                                          ;
    lda next_index,x                                ;
    sta colour_index                                ;
    tax                                             ;
    lda colour_array,x                              ;
    sta text_colour_mask                            ;
    lda game_over_string,Y                          ;
    jsr write_char                                  ;
    iny                                             ;
    cpy #game_over_string_end - game_over_string    ;
    bne write_game_over_loop                        ;

    dec game_over_timer                             ;
    bne game_over_loop                              ;
    jmp real_entry_point                            ;

check_for_suicide
    lda keyStateShift                               ;
    beq leave7                                      ;
    lda keyStateEscape                              ;
    beq leave7                                      ;
    pla                                             ; Remove check_for_suicide from stack
    pla                                             ;
    jmp real_entry_point                            ;
leave7
    rts                                             ;

; ***************************************************************************************
game_over_string
    !text "Game", 9, 9, "Over"                      ;
game_over_string_end

; ***************************************************************************************
start_sound_x
    txa                                         ;
    tay                                         ; Y = X
    lda channel_for_sound_x,X                   ;
    tax                                         ;
    lda initial_pitch_low_for_sound_x,Y         ;
    sta pitch_low,X                             ;
    lda initial_pitch_high_for_sound_x,Y        ;
    sta pitch_high,X                            ;
    lda #1                                      ;
    sta sound_counters,X                        ;
    lda duration_for_sound_x,Y                  ;
    sta sound_duration_for_channel_x,X          ;
    lda pitch_increment_for_sound_x,Y           ;
    sta pitch_increment_for_channel_x,X         ;
return1
    rts                                         ;

; ***************************************************************************************
update_channel_x
    lda sound_counters,X                        ;
    beq return1                                 ;
    lda pitch_low,X                             ;
    sec                                         ;
    sbc pitch_increment_for_channel_x,X         ;
    sta pitch_low,X                             ;
    bcs +                                       ;
    dec pitch_high,X                            ;
+                                               ;
    inc sound_counters,X                        ;
    lda sound_counters,X                        ;
    cmp sound_duration_for_channel_x,X          ;
    bne +                                       ;
    lda #0                                      ;
    sta sound_counters,X                        ;
    lda #0                                      ;
    jmp set_volume                              ;
+
    ; calculate bytes to send to sound chip
    lda pitch_low,X                             ;
    and #$0f                                    ;
    ora first_byte_upper,X                      ; 'OR' in upper nybble of the first byte
    sta first_sound_byte                        ;

    lda pitch_high,X                            ;
    asl                                         ;
    asl                                         ;
    asl                                         ;
    asl                                         ;
    sta temp_sound_byte                         ;
    lda pitch_low,X                             ;
    lsr                                         ;
    lsr                                         ;
    lsr                                         ;
    lsr                                         ;
temp_sound_byte = * + 1
    ora #$ff                                    ;
    sta second_sound_byte                       ;

    ; send bytes to sound chip
    lda first_sound_byte                        ;
    jsr send_to_sound_chip                      ;
    cpx #0                                      ;
    beq +                                       ;
    lda second_sound_byte                       ;
    jsr send_to_sound_chip                      ;
+

    ; check for fade in
    lda sound_counters,X                        ; time sound has been playing
    asl                                         ;
    cmp sound_volume_for_channel,X              ;
    bcc set_volume                              ;

    ; check for end of sound, to fade out
    sec                                         ;
    sbc sound_duration_for_channel_x,X          ;
    sbc sound_duration_for_channel_x,X          ;
    clc                                         ;
    adc #8                                      ;
    cmp #8                                      ;
    bcs full_volume                             ;
    sta diff                                    ;
    lda sound_volume_for_channel,X              ;
    sec                                         ;
diff = * + 1
    sbc #$ff                                    ;
set_volume
    eor volume_byte_for_channel,X               ;
    jmp send_to_sound_chip                      ;

full_volume
    lda sound_volume_for_channel,X              ;
    jmp set_volume                              ;

; ***************************************************************************************
update_sound
    ldx #3                                      ;
-
    stx temp_channel_x                          ;
    jsr update_channel_x                        ;
temp_channel_x = * + 1
    ldx #$ff                                    ;
    dex                                         ;
    bpl -                                       ;
    rts                                         ;

; ***************************************************************************************
keyStates
keyStateZ
   !byte 0
keyStateX
   !byte 0
keyStateReturn
   !byte 0
keyStateSpace
   !byte 0
keyStateS
   !byte 0
keyStateQ
   !byte 0
keyStateEscape
   !byte 0
keyStateShift
   !byte 0

;previousKeyStates
;previousKeyStateZ
;   !byte 0
;previousKeyStateX
;   !byte 0
;previousKeyStateRETURN
;   !byte 0
;previousKeyStateSpace
;   !byte 0
;previousKeyStateS
;   !byte 0
;previousKeyStateQ
;   !byte 0
;previousKeyStateEscape
;   !byte 0
;previousKeyStateShift
;   !byte 0
;
;justPressedKeyStates
;justPressedStateZ
;   !byte 0
;justPressedStateX
;   !byte 0
;justPressedStateRETURN
;   !byte 0
;justPressedStateSpace
;   !byte 0
;justPressedStateS
;   !byte 0
;justPressedStateQ
;   !byte 0
;justPressedStateEscape
;   !byte 0
;justPressedStateShift
;    !byte 0

; ***************************************************************************************
scroll_scrolltext
    ldx #>(text_message_address - $10)              ;
    stx target_address_high                         ;
    ldx #>(text_message_address + 8 - $10)          ; Uncomment to avoid !if above
    stx source_address_high                         ;
    ldy #<(text_message_address - $10)              ; Target: $57f0 = $5800 - $10
    sty target_address_low                          ;
    lda #<(text_message_address + 8 - $10)          ; Source: $57f8 = $5808 - $10
    sta source_address_low                          ;
    ldy #$10                                        ;
    lda #2                                          ;
    sta blocks_to_copy                              ;
    ldx #$f8                                        ;
scroll_scrolltext_loop
source_address_low = * + 1
source_address_high = * + 2
    lda $ffff,Y                                     ;
target_address_low = * + 1
target_address_high = * + 2
    sta $ffff,Y                                     ;
    iny                                             ;
    bne +                                           ;
    inc target_address_high                         ;
    inc source_address_high                         ;
+
    dex                                             ;
    bne scroll_scrolltext_loop                      ;
    dec blocks_to_copy                              ;
    bne scroll_scrolltext_loop                      ;

    lda #0                                          ;
    ldx #7                                          ;
-
    sta text_message_address + $1f8,x               ;
    dex                                             ;
    bpl -                                           ;
    rts                                             ;

; ***************************************************************************************
plot_title_screen_logo
    ldx #0                                          ;
    ldy #2                                          ; TAB(0,2)
    jsr set_text_position                           ;

    ldx #0                                          ;

plot_title_screen_logo_loop
    lda title_screen_logo,X                         ;
    sta blocks_to_copy                              ;
    ldy #7                                          ; loop counter
unpack_byte_loop
    lsr blocks_to_copy                              ;
    bcc skip_block                                  ;
    ; draw block
    lda #<fuzzy_block                               ;
    sta character_definitions_low                   ;
    lda #>fuzzy_block                               ;
    sta character_definitions_high                  ;
    sta temp3                                       ;
    stx temp4                                       ;
    sty temp5                                       ;
    jsr write_char_internal                         ;
next_byte
    dey                                             ;
    bpl unpack_byte_loop                            ;
    inx                                             ;
    cpx #title_screen_logo_end - title_screen_logo  ;
    bne plot_title_screen_logo_loop                 ;

    rts                                             ;

skip_block
    lda #9                                          ;
    jsr write_char                                  ;
    jmp next_byte                                   ;

fuzzy_block
    !byte %11111111
    !byte %11010101
    !byte %10101010
    !byte %11010101
    !byte %10101010
    !byte %11010101
    !byte %10101010
    !byte %11010101

; ***************************************************************************************
clear_room_palette_changes
    ldy #15                                         ;
    lda #$ff                                        ;
-
    sta palette_changes, Y                          ;
    dey                                             ;
    bpl -                                           ;
    rts                                             ;

; ***************************************************************************************
set_full_room_palette
    clc                                             ;
    adc #3                                          ;
    tax                                             ;
    ldy #3                                          ;
-
    lda room_palette,X                              ;
    sta room_palette,Y                              ;
    dex                                             ;
    dey                                             ;
    bpl -                                           ;
    rts                                             ;

colour_cycler
    !byte 1

colour_cycles
    !byte magenta, yellow, red, cyan, blue, green

; ***************************************************************************************
update_colour_cycler
    sty temp_y_value
    ldy colour_cycler                               ;
    lda colour_cycles - 1,Y                         ;
temp_y_value = * + 1
    ldy #$ff                                        ;
    sta colour_cycler                               ;
    rts                                             ;

; ***************************************************************************************
title_change_palette
    lda game_timer                                  ;
    and #1                                          ;
    bne skip_title_colour_change                    ;

    ldy #2                                          ; loop counter
-
    jsr update_colour_cycler                        ;

    asl                                             ;
    asl                                             ;
    clc                                             ;
    adc #2                                          ;
    sta palette_changes, Y                          ;
    iny                                             ;
    cpy #14                                         ;
    bne -                                           ;

    ; move colour cycler on
    ldx #5
-
    jsr update_colour_cycler                        ;
    dex                                             ;
    bne -                                           ;

skip_title_colour_change
    rts                                             ;

title_delay_before_restart
    !byte 0

; ***************************************************************************************
title_screen
    lda #$81                                        ;
    sta life_y                                      ;

    ; DEBUG!
    lda #0
    sta melody_active                               ; Enable melody
    lda #16                                         ; Title screen has full line of lives
    sta player_lives                                ;
    jsr clear_screen                                ;

    jsr clear_room_palette_changes                  ;

    lda #title_palette - start_of_palettes          ;
    jsr set_full_room_palette                       ;

    lda #$f0                                        ;
    sta text_colour_mask                            ; colour 3
    jsr plot_title_screen_logo                      ;
    lda #$ff                                        ;
    sta text_colour_mask                            ; Use colour 3 for scrolltext

    lda #>title_screen_press_space                  ;
    sta scrolltext_address_high                     ;
    lda #<title_screen_press_space                  ;
    sta scrolltext_address_low                      ;
    jmp scroll_the_message                          ;

restart_scrolltext
    lda #>title_screen_scrolltext                   ;
    sta scrolltext_address_high                     ;
    lda #<title_screen_scrolltext                   ;
    sta scrolltext_address_low                      ;
    lda #0                                          ;
    sta title_delay_before_restart                  ;

scroll_the_message
    ldy #0                                          ;
    sty scrolltext_offset                           ;
title_screen_loop
    lda title_delay_before_restart                  ; are we delaying?
    beq +                                           ;
    dec title_delay_before_restart                  ;
    beq restart_scrolltext                          ;
    bne wait_for_vsyncs                             ; ALWAYS branch
+
    ldx #31                                         ;
    ldy #20                                         ; TAB(30,20)
    jsr set_text_position                           ;

    lda game_timer                                  ;
    and #1                                          ;
    bne wait_for_vsyncs                             ;
    ldy scrolltext_offset                           ;
    lda (scrolltext_address_low),Y                  ; Write character of scrolltext
    beq end_of_scrolltext                           ;
    jsr write_char                                  ;
    inc scrolltext_offset                           ;
    bne ++                                          ; move on to next character
    inc scrolltext_address_high                     ;
++

wait_for_vsyncs
    lda vsync_counter                               ;
    cmp #2                                          ;
    bcs +                                           ;
    jsr check_for_space_bar                         ;
    jmp wait_for_vsyncs                             ;
+
    lda #0                                          ;
    sta vsync_counter                               ;

    ; --- delay ---
    ldx #2                                          ;
    jsr delay                                       ;

    jsr title_change_palette                        ;
    lda title_delay_before_restart                  ; are we delaying?
    bne +                                           ;
    jsr scroll_scrolltext                           ;
+
    inc game_timer                                  ;
    jsr update_lives                                ; Animate lives
    jsr check_for_space_bar                         ;
    jsr check_for_q_and_s_keys                      ;
    jmp title_screen_loop                           ;

; ***************************************************************************************
end_of_scrolltext
    lda #$80                                        ;
    sta title_delay_before_restart                  ;
    jmp title_screen_loop                           ;

check_for_space_bar
    jsr read_keys                                   ;
    lda keyStateSpace                               ;
    beq leave                                       ;
    lda #$8c                                        ;
    sta life_y                                      ;
    pla                                             ; Leave title_screen when SPACE pressed
    pla                                             ;
leave
    rts                                             ;

; ***************************************************************************************
;change_colour
;    dec change_colour_value                         ;
;change_colour_value = * + 1
;    lda #0                                          ;
;    and #7                                          ;
;    beq change_colour                               ;
;write_change_colour
;    ldy #2                                          ;
;    jsr set_logical_colour_y_to_a                   ;
;    rts                                             ;

; ***************************************************************************************
title_screen_scrolltext
    !text "...Jetset Willy was written for the BBC Micro by Chris Robson..."
    !text "...Jet Set Willy was prepared by Tynesoft under licence from Software Projects "
    !text    "and is copyright to Software Projects..."
    !text "...You must guide Willy to collect all the items around the house before "
    !text    "midnight so that Maria will let you go to bed..."
title_screen_press_space
;    !text "....Press SPACE to start the game."
    !text " ++++ Press SPACE to start ++++ "
    !byte 0

; ***************************************************************************************
title_screen_logo
    !le32 %....###.###.###..###.###.###....
    !le32 %.....#....#...#...#....#..#.....
    !le32 %.....#..###.###...#..###..#.....
    !le32 %.....#....#.#.....#....#..#.....
    !le32 %.....#..###.###...#..###..##....
    !le32 %................................
    !le32 %................................
    !le32 %......#...#..#...#.#.#...#......
    !le32 %......#...#..#...#.#.#...#......
    !le32 %......#####..#...#.#.#.#.#......
    !le32 %........#....#...#.#.#.#.#......
    !le32 %........#..###.###.#.#####......

title_screen_logo_end

; ***************************************************************************************
update_music
    lda melody_active                               ;
    bne play_melody                                 ;
    lda #0                                          ;
    sta note_number                                 ;
    jmp play_silence                                ;

play_melody
    lda music_enabled                               ;
    beq +                                           ;
    dec note_length                                 ;
    bne set_melody_vol                              ;
    ldx note_number                                 ;
    lda melody_duration_table,X                     ;
    sta note_length                                 ;
    lda melody_pitch_table,X                        ;

; write first byte:   128 + 32*C + bottom four bits of pitch P (0-15)
; write second byte:  top 6 bits of pitch P
;
; To set volume V (0-15) on channel C (0-2, or 3=noise):
; write volume byte:  128 + 32*C + 16 + volume (0-15, 0 = loudest)

    and #$0f                                        ;
    ora #$80                                        ; 'OR' in upper nybble for channel 3
    jsr send_to_sound_chip                          ; first byte

    lda melody_pitch_table,X                        ;
    lsr                                             ;
    lsr                                             ;
    lsr                                             ;
    lsr                                             ;
    jsr send_to_sound_chip                          ; second byte

    lda #11 * 4                                     ;
    sta melody_note_volume                          ;

    inc note_number                                 ;
    lda note_number                                 ;
    cmp #$25                                        ;
    bne set_melody_vol                              ;
    lda #0                                          ;
    sta note_number                                 ;
set_melody_vol
    ; set volume of playing note
    lda melody_note_volume                          ;
    lsr                                             ;
    lsr                                             ;
    eor #$9f                                        ;
    jsr send_to_sound_chip                          ; volume byte

    ; update volume
    lda melody_note_volume                          ;
    beq +                                           ;
    dec melody_note_volume                          ;
+
    rts                                             ;

; ***************************************************************************************
check_for_q_and_s_keys
    lda keyStateS                                   ;
    beq s_not_pressed                               ;
    lda #1                                          ;
    sta music_enabled                               ;
s_not_pressed
    lda keyStateQ                                   ;
    beq q_not_pressed                               ;
    lda #0                                          ;
    sta music_enabled                               ;
play_silence
    lda #$9f                                        ;
    jsr send_to_sound_chip                          ; volume byte
q_not_pressed
    rts                                             ;

note_length
    !byte $06

; ***************************************************************************************
irq_routine
    txa                                             ;
    pha                                             ;
    tya                                             ;
    pha
    lda systemVIAInterruptFlagRegister              ; get interrupt flag register
    and #$c0                                        ;
    cmp #$c0                                        ;
    bne exit_irq                                    ; unknown interrupt
    sta systemVIAInterruptFlagRegister              ; clear interrupt

    ldx irq_counter                                 ;
    inx                                             ;
    cpx #13*3                                       ;
    bcc +                                           ;
    jsr update_sound                                ; update all audio
    jsr update_music                                ;
    ldx #0                                          ;
+
    stx irq_counter                                 ;
    cpx #16                                         ;
    bne +                                           ;
    inc vsync_counter                               ;
    lda #4                                          ; change to footer palette
    jmp change_all_palette                          ;

+
    bcs +                                           ;
    ; apply palette changes in rows 0-15
    lda palette_changes,X                           ;
    bmi exit_irq                                    ;
    and #3                                          ;
    tay                                             ;
    lda palette_changes,X                           ;
    lsr                                             ;
    lsr                                             ;
    jsr set_logical_colour_y_to_a                   ;

+
    cpx #20                                         ;
    bne +                                           ;

    ; final row
    ldy #3                                          ;
    lda #white                                      ;
    jsr set_logical_colour_y_to_a                   ;

+
    cpx #21                                         ;
    bne exit_irq                                    ;

change_all_room_palette
    lda #0                                          ; change to room palette
+
change_all_palette
    clc                                             ;
    adc #<room_palette                              ;
    sta change_palette_low                          ;
    ldy #0                                          ;
-
change_palette_low = * + 1
    lda room_palette,Y                              ;
    jsr set_logical_colour_y_to_a                   ;
    iny                                             ;
    cpy #4                                          ;
    bne -                                           ;

exit_irq
    pla                                             ;
    tay                                             ;
    pla                                             ;
    tax                                             ;
    lda irq_accumulator                             ;
    rti                                             ;

!if ((>room_palette) != (>(room_palette + 4))) {
    !error "Alignment of room_palette is wrong"
}

; ***************************************************************************************

melody_pitch_table
    !byte 169, 190, 169, 190, 201, 253
    !byte 201, 190, 169, 190, 169, 190, 201, 190, 169, 150, 142, 150, 142, 150, 169
    !byte 127, 134, 150, 169, 190, 201, 190, 169, 201
    !byte 160, 169, 190, 169, 160, 190, 127

melody_duration_table
    !byte  8,  8,  8,  8, 16, 32
    !byte  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8, 64
    !byte 32, 16, 16,  8,  8,  8,  8, 16, 16
    !byte  8,  8,  8,  8, 16, 16, 64

; ***************************************************************************************
; Change the appearance of logical colour Y to physical colour A
set_logical_colour_y_to_a
    eor #7                                  ;
    ora paletteLookupTable,Y                ;
    sta videoULAPaletteRegister             ; store actual colour in register
    eor #$10                                ;
    sta videoULAPaletteRegister             ; store actual colour in register
    eor #$50                                ;
    sta videoULAPaletteRegister             ; store actual colour in register
    eor #$10                                ;
    sta videoULAPaletteRegister             ; store actual colour in register
    rts                                     ;

; ***************************************************************************************
; per channel information
; constants
sound_volume_for_channel
    !byte 11
    !byte 15
    !byte 14
    !byte 11
volume_byte_for_channel
    !byte $ff
    !byte $df
    !byte $bf
    !byte $9f
first_byte_upper
    !byte $e0
    !byte $c0
    !byte $a0
    !byte $80

; ***************************************************************************************
; per sound information
channel_for_sound_x
    !byte 1                 ; 0 : jump
    !byte 0                 ; 1 : arrow
    !byte 2                 ; 2 : item collection
    !byte 1                 ; 3 : game over
    !byte 0                 ; 4 : dying 1
    !byte 1                 ; 5 : dying 2

initial_pitch_low_for_sound_x
    !byte <347              ; 0 : jump
    !byte <5                ; 1 : arrow
    !byte <85               ; 2 : item collection
    !byte <600              ; 3 : game over
    !byte <5                ; 4 : dying 1
    !byte <100              ; 5 : dying 2

initial_pitch_high_for_sound_x
    !byte >347              ; 0 : jump
    !byte >5                ; 1 : arrow
    !byte >85               ; 2 : item collection
    !byte >600              ; 3 : game over
    !byte >5                ; 4 : dying 1
    !byte >100              ; 5 : dying 2

duration_for_sound_x
    !byte 28                ; 0 : jump
    !byte 7                 ; 1 : arrow
    !byte 20                ; 2 : item collection
    !byte 70                ; 3 : game over
    !byte 10                ; 4 : dying 1
    !byte 10                ; 5 : dying 2

pitch_increment_for_sound_x
    !byte 10                ; 0 : jump
    !byte 0                 ; 1 : arrow
    !byte 0                 ; 2 : item collection
    !byte 8                 ; 3 : game over
    !byte 0                 ; 4 : dying 1
    !byte 10                ; 5 : dying 2

; ***************************************************************************************
plot_enemies
    ldx enemies_on_screen                           ;
    beq leave11                                     ;
    stx enemy_to_consider2                          ;
plot_enemies_loop
    dec enemies_need_replot,X                       ;
    bne skip_enemy                                  ;
    jsr calculate_enemy_sprite_address              ;
    jsr plot_enemy                                  ;
    jsr wipe_space_vacated_by_enemy                 ;
skip_enemy
    dec enemy_to_consider2                          ;
    ldx enemy_to_consider2                          ;
    bne plot_enemies_loop                           ;
leave11
    rts                                             ;

; ***************************************************************************************
rope_x_delta_table
    !byte $02, $01, $01, $02, $02, $02, $02, $02, $02, $01, $02, $02, $02, $01, $02, $02
    !byte $02, $02, $01, $02, $02, $01, $01, $02, $01, $01, $03, $02, $02, $03, $02, $03
    !byte $02, $03, $03, $03, $03, $03, $01, $00

rope_y_delta_table
    !byte $03, $03, $03, $03, $02, $03, $03, $02, $02, $03, $02, $02, $02, $03, $02, $02
    !byte $02, $02, $03, $02, $02, $03, $03, $02, $03, $03, $01, $03, $03, $01, $02, $01
    !byte $02, $01, $02, $02, $02, $02, $03, $03

; ***************************************************************************************
rope_pixels_screen_address_low_table
    !byte <screen_memory_start + $01
    !byte <screen_memory_start + $b9
    !byte <screen_memory_start + $bf
    !byte <screen_memory_start + $c4
    !byte <screen_memory_start + $c2
    !byte <screen_memory_start + $c8
    !byte <screen_memory_start + $cd
    !byte <screen_memory_start + $d2
    !byte <screen_memory_start + $d0
    !byte <screen_memory_start + $dd
    !byte <screen_memory_start + $da
    !byte <screen_memory_start + $df
    !byte <screen_memory_start + $e4
    !byte <screen_memory_start + $e1
    !byte <screen_memory_start + $e6
    !byte <screen_memory_start + $e3
    !byte <screen_memory_start + $e8
    !byte <screen_memory_start + $ed
    !byte <screen_memory_start + $ea
    !byte <screen_memory_start + $ef
    !byte <screen_memory_start + $f4
    !byte <screen_memory_start + $f1
    !byte <screen_memory_start + $f6
    !byte <screen_memory_start + $f3
    !byte <screen_memory_start + $f8
    !byte <screen_memory_start + $fd
    !byte <screen_memory_start + $fa
    !byte <screen_memory_start + $ff
    !byte <screen_memory_start + $04
    !byte <screen_memory_start + $01
    !byte <screen_memory_start + $06
    !byte <screen_memory_start + $03

rope_pixels_screen_address_high_table
    !byte >screen_memory_start + $00
    !byte >screen_memory_start + $16
    !byte >screen_memory_start + $14
    !byte >screen_memory_start + $14
    !byte >screen_memory_start + $14
    !byte >screen_memory_start + $14
    !byte >screen_memory_start + $12
    !byte >screen_memory_start + $12
    !byte >screen_memory_start + $12
    !byte >screen_memory_start + $10
    !byte >screen_memory_start + $10
    !byte >screen_memory_start + $0e
    !byte >screen_memory_start + $0e
    !byte >screen_memory_start + $0e
    !byte >screen_memory_start + $0c
    !byte >screen_memory_start + $0c
    !byte >screen_memory_start + $0c
    !byte >screen_memory_start + $0a
    !byte >screen_memory_start + $0a
    !byte >screen_memory_start + $08
    !byte >screen_memory_start + $08
    !byte >screen_memory_start + $08
    !byte >screen_memory_start + $06
    !byte >screen_memory_start + $06
    !byte >screen_memory_start + $06
    !byte >screen_memory_start + $04
    !byte >screen_memory_start + $04
    !byte >screen_memory_start + $02
    !byte >screen_memory_start + $03
    !byte >screen_memory_start + $03
    !byte >screen_memory_start + $01
    !byte >screen_memory_start + $01


; ***************************************************************************************
rope_pixels_x
    !byte $30, $5d, $5f, $60, $62, $64, $66, $68, $6a, $6c, $6d, $6e, $70, $71, $72, $73
    !byte $74, $75, $76, $77, $78, $79, $7a, $7b, $7c, $7d, $7e, $7f, $80, $80, $80, $80

; ***************************************************************************************
rope_pixels_y
    !byte $00, $59, $57, $54, $52, $50, $4d, $4a, $48, $45, $42, $3f, $3c, $39, $36, $33
    !byte $30, $2d, $2a, $27, $24, $21, $1e, $1b, $18, $15, $12, $0f, $0c, $09, $06, $03

; ***************************************************************************************
; Tile types:
;  0 = PLATFORM
;  1 = WALL
;  2 = SLOPE
;  3 = CONVEYOR
;  4 = DEADLY
;  5 = SCENERY
;  6 = ITEM
background_tiles_colours_fg
    !byte $01, $02, $03, $03, $02, $00, $00 ;
background_tiles_colours_bg
    !byte $02, $00, $00, $00, $00, $00, $00 ;
background_tiles_sprites
    !byte $8d, $8e, $03, $90, $40, $91, $00 ;

; ***************************************************************************************
enemies_sprite
    !byte $00, $1c, $04, $02, $26, $1c, $0e, $00, $00

enemies_unpacked_sprite_offset
    !byte $00, $2a, $4d, $5a, $2e, $31, $31, $30, $0d

enemies_direction
    !byte $00, $00, $00, $ff, $00, $00, $00, $00, $00

player_x_in_enemies
enemies_x
    !byte $a8, $3a, $e0, $78, $6c, $2c, $94, $8a, $f8

player_y_in_enemies
enemies_y
    !byte $68, $18, $68, $70, $18, $48, $60, $ad, $40

player_speed
enemies_speed
    !byte $02, $fe, $00, $00, $fe, $02, $fe, $2c, $ce

enemies_minimum
    !byte $86, $00, $00, $78, $68, $10, $00, $bd, $26

enemies_maximum
    !byte $0c, $e8, $00, $78, $b0, $38, $a8, $8d, $81

enemies_colour
    !byte $0a, $02, $03, $01, $02, $01, $03, $20, $f1

enemies_previous_tile_address_low
    !byte $ff, $47, $9c, $00, $4d, $05, $72, $c9, $25

enemies_previous_speed
    !byte $d0, $fe, $00, $00, $fe, $02, $fe, $a5, $ec

enemies_need_replot
    !byte $02, $ff, $ff, $00, $ff, $ff, $ff, $7c, $0a

enemy_has_moved
    !byte $c9, $00, $00, $01, $00, $00, $00, $7c, $0a

arrow_timer
    !byte $00, $00

arrow_y
    !byte $40, $40

items_colour
    !byte $02, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01

items_screen_address_low
    !byte $70, $20, $40, $60, $70, $90, $b0, $c9, $a0, $d0, $06, $8d

items_screen_address_high
    !byte $4b, $49, $49, $49, $49, $49, $49, $68, $aa, $68, $85, $fc

exit_rooms
    !byte $14, $15, $15, $15

items_tile_address_low
    !byte $b7, $92, $94, $96, $97, $99, $9b, $68, $84, $08, $08, $08

items_tile_address_high
    !byte $6f, $6f, $6f, $6f, $6f, $6f, $6f, $08, $08, $08, $08, $08

; ***************************************************************************************
os_screen_address_lookup_table
    !be16 $0000
    !be16 $0200
    !be16 $0400
    !be16 $0600
    !be16 $0800
    !be16 $0a00
    !be16 $0c00
    !be16 $0e00
    !be16 $1000
    !be16 $1200
    !be16 $1400
    !be16 $1600
    !be16 $1800
    !be16 $1a00
    !be16 $1c00
    !be16 $1e00
    !be16 $2000
    !be16 $2200
    !be16 $2400
    !be16 $2600
    !be16 $2800
    !be16 $2a00
    !be16 $2c00
    !be16 $2e00
    !be16 $3000
    !be16 $3200
    !be16 $3400
    !be16 $3600
    !be16 $3800
    !be16 $3a00
    !be16 $3c00
    !be16 $3e00

life_colours
    ;      KK,  RR,  YY,  WW
    !byte $00, $0f, $f0, $ff
end_of_real_code

!if (* > screen_memory_start) {
    !error "Code too long by ", * - screen_memory_start
}
}
free_before_screen = screen_memory_start - end_of_real_code

; ***************************************************************************************
;
; everything from here on is initialisation code run only once, then becomes part of the
; screen memory.
;
; ***************************************************************************************


; ***************************************************************************************
entry_point
    lda #140                                        ;
    ldx #12                                         ; *TAPE
    jsr OSBYTE                                      ;

    lda #$c8                                        ; Write BREAK/ESCAPE effect
    ldx #3                                          ; Normal ESCAPE effect, Memory cleared on next reset
    jsr OSBYTE                                      ;

    lda #0                                          ;
    ldx #$ff                                        ; Check for Master
    jsr OSBYTE                                      ;

    lda #0                                          ; }
    cpx #3                                          ; }
    bcc +                                           ; } Make is_master $00 if executing on a BBC B/B+
    lda #$ff                                        ; }             or $ff on a Master
+                                                   ; }
    sta is_master                                   ; }

    ; relocate code
    sei
    ldy #<$1100                                     ;
    sty $70                                         ;
    ldx #>$1100                                     ;
    stx $71                                         ; Copy code from $1100 to $0208

    ldy #<$0208                                     ;
    sty $72                                         ;
    ldx #>$0208                                     ;
    stx $73                                         ;

    ldx #>(end_of_real_code - $0208 + $ff)          ; loop counter (copy as many pages as we need)
    ldy #0                                          ;
-
    lda ($70),y                                     ;
    sta ($72),y                                     ; copy a page of memory
    iny                                             ;
    bne -                                           ;

    inc $71                                         ;
    inc $73                                         ; increment high byte of source and destination

    dex                                             ; decrement loop counter
    bne -                                           ; if (not done yet) then branch back

    ; set custom mode 1
    ; Set hardware scrolling value
    lda #4                                          ; Set C0=0
    sta systemVIARegisterB                          ; Setting the address for hardware scrolling
    lda #13                                         ; Set C1=1
    sta systemVIARegisterB                          ; Set Hardware scrolling address (C0=1,C1=1 i.e. $3000)

    ; Set Video ULA register
    lda #%11011000                                  ;
    sta videoULARegister                            ; write to control register

    ; set video ULA
    lda #%11011000                                  ;
    sta videoULARegister                            ;

    ; Write to all 16 registers of the CRTC
    ldy #15                                         ;
write_CRTC_loop
    lda register_CRTC_array,Y                       ; A = value to write
    sty crtcAddressRegister                         ; Set CRTC address register to write into (0-15)
    sta crtcAddressWrite                            ; Write new value into register
    dey                                             ;
    bpl write_CRTC_loop                             ;

    ldx #initial_zero_page_values_end - initial_zero_page_values - 1 ; Copy initial_zero_page_values to zero page
copy_zero_page_values_loop                          ;
    lda initial_zero_page_values,X                  ;
    sta $4d,X                                       ;
    dex                                             ;
    bpl copy_zero_page_values_loop                  ;

    lda #1                                          ;
    sta music_enabled                               ;
    lda #0                                          ;
    ldx #sound_variables_end - sound_variables_start + 1 ;
-
    sta sound_variables_start,X                     ;
    dex                                             ;
    bpl -                                           ;

    LDA #$7f                                        ; }
    STA systemVIAInterruptEnableRegister            ; } Disable all interrupts
    cli                                             ;

    lda #<irq_routine                               ;
    sta irq1_vector_low                             ;
    lda #>irq_routine                               ;
    sta irq1_vector_high                            ;

    lda #$c0                                        ; Enable timer 1
    sta systemVIAInterruptEnableRegister            ; Interrupt enable register
    lda #$c0                                        ; Enable free run mode
    sta systemVIAAuxiliaryControlRegister           ; Auxiliary control register

    lda #<Timer1Value                               ;
    sta systemVIATimer1CounterLow                   ;
    ; Get high byte ready so we can write it as quickly as possible at the right moment
    ldx #>Timer1Value                               ;

    ; Wait for VSync without having to catch it from its IRQ
    lda #2                                          ;
    sta systemVIAInterruptFlagRegister              ; clear VSync flag
-
    bit systemVIAInterruptFlagRegister              ;
    beq -                                           ; poll VSync flag

    stx systemVIATimer1CounterHigh                  ; start Timer 1 counting
    sta systemVIAInterruptFlagRegister              ; clear VSync flag

    ; Set timer to fire every 'short time' (set latch)
    lda #<ShortTimerValue                           ;
    sta systemVIATimer1LatchLow                     ;
    lda #>ShortTimerValue                           ;
    sta systemVIATimer1LatchHigh                    ;

    lda #0                                          ;
    sta irq_counter                                 ;

    lda #1                                          ;
    sta melody_active                               ;

    jmp real_entry_point                            ;

; ***************************************************************************************
register_CRTC_array
    !byte 127                                       ; R0 = Horizontal total register
    !byte 64                                        ; R1 = Horizontal displayed register
    !byte 86                                        ; R2 = Horizontal sync position register
    !byte 40                                        ; R3 = The sync width register
    !byte 38                                        ; R4 = Vertical total register
    !byte 0                                         ; R5 = Vertical total adjust register
    !byte 32 - 11                                   ; R6 = Vertical displayed register (number of visible character rows)
    !byte 35 - 5                                    ; R7 = Vertical sync position (*TV)
    !byte 0                                         ; R8 = Interlace and delay register
    !byte 7                                         ; R9 = Scan lines per character
    !byte $20                                       ; R10 = Cursor start register
    !byte 0                                         ; R11 = The cursor end register
    !byte >(screen_memory_start / 8)                ; R12 = Displayed screen start address/8 register (High)
    !byte <(screen_memory_start / 8)                ; R13 = Displayed screen start address/8 register (low)
    !byte 15                                        ; R14 = Cursor position register
    !byte 80                                        ; R15 = Cursor position register

; ***************************************************************************************
initial_zero_page_values
; $4d
    !byte $8c                                       ; $4d  life_y
    !byte $fb                                       ; $4e  space_tile
    !byte $01                                       ; $4f  swimming_pool_item_collected
    !byte $fd                                       ; $50  room_data_address_low
    !byte $2c                                       ; $51  room_data_address_high
    !byte $46                                       ; $52  room_data_offset
    !byte $01                                       ; $53  bits_remaining_in_room_data_byte
    !byte $00                                       ; $54  room_data_byte
    !byte $11                                       ; $55  player_room
    !byte $02                                       ; $56  pages_of_tile_table_remaining_when_finding_conveyor
    !byte $88                                       ; $57  game_timer
    !byte $04                                       ; $58  conveyor_length
    !byte $c0                                       ; $59  conveyor_screen_address_low
    !byte $45                                       ; $5a  conveyor_screen_address_high
    !byte $00                                       ; $5b  rope_position_relative_to_centre
    !byte $01                                       ; $5c  rope_velocity_relative_to_centre
    !byte $b9                                       ; $5d  rope_end_x
    !byte $48                                       ; $5e  rope_end_y
    !byte $d2                                       ; $5f  rope_position
    !byte $ef                                       ; $60  tile_address_low
    !byte $6e                                       ; $61  tile_address_high
    !byte $40                                       ; $62  where_player_fell_from
    !byte $00                                       ; $63  player_killed
    !byte $01                                       ; $64  player_is_jumping
    !byte $02                                       ; $65  player_jump_timer
    !byte $02                                       ; $66  items_in_room_minus_one
    !byte $07                                       ; $67  item_number
    !byte $80                                       ; $68  tile
    !byte $00                                       ; $69  player_conveyor_direction
    !byte $fe                                       ; $6a  conveyor_direction
    !byte $00                                       ; $6b  player_on_slope
    !byte $00                                       ; $6c  slope_direction
    !byte $00                                       ; $6d  do_triangle_ends
    !byte $ff                                       ; $6e  length
    !byte $00                                       ; $6f  room_contains_rope
    !byte $01                                       ; $70  scrolltext_address_low
    !byte $3e                                       ; $71  scrolltext_address_high
    !byte $05                                       ; $72  tile_type
    !byte $00                                       ; $73  [unused]
    !byte $00                                       ; $74  length
    !byte $00                                       ; $75  start_x / previous_x
    !byte $ff                                       ; $76  previous_y / height
    !byte $01                                       ; $77  x_delta
    !byte $01                                       ; $78  y_delta
    !byte $00                                       ; $79  width / enemy_to_consider
    !byte $ff                                       ; $7a  (various)
    !byte $81                                       ; $7b  (various)
    !byte $08                                       ; $7c  direction
    !byte $01                                       ; $7d  triangle_direction
    !byte $ff                                       ; $7e  x_skip
    !byte $00                                       ; $7f  triangle_length
    !byte $ff                                       ; $80  height
    !byte $f0                                       ; $81  previous_tile_type / previous_y / room / conveyor_colour
    !byte $01                                       ; $82  add_first_and_last
    !byte $08                                       ; $83  direction_base
    !byte $00                                       ; $84  unpacked_sprite_address_low
    !byte $75                                       ; $85  unpacked_sprite_address_high
    !byte $10                                       ; $86  unpacked_sprite_offset
    !byte $02                                       ; $87  enemies_on_screen
    !byte $aa                                       ; $88  unpacked_byte_two
    !byte $85                                       ; $89  sprite_colour
    !byte $00                                       ; $8a  enemy_to_consider
    !byte $00                                       ; $8b  player_started_jump
    !byte $78                                       ; $8c  player_x
    !byte $42                                       ; $8d  player_y
    !byte $00                                       ; $8e  player_horizontal_speed
    !byte $ff                                       ; $8f  [unused]
    !byte $f1                                       ; $90  screen_address_low
    !byte $44                                       ; $91  screen_address_high
    !byte $c0                                       ; $92  sprite_address_low
    !byte $72                                       ; $93  sprite_address_high
    !byte $3f                                       ; $94  sprite_size_in_bytes
    !byte $18                                       ; $95  sprite_width
    !byte $05                                       ; $96  (various)
    !byte $ff                                       ; $97  (various)
    !byte $07                                       ; $98  seven ; This value is used
    !byte $ff                                       ; $99  melody_active
    !byte $00                                       ; $9a  player_entered_room_falling_too_far
    !byte $07                                       ; $9b  player_lives
    !byte $00                                       ; $9c  player_not_plotted
    !byte $00                                       ; $9d  out_of_time
    !byte $00                                       ; $9e  house_clear
    !byte $00                                       ; $9f  player_rope_pixel
initial_zero_page_values_end

free_total = free_before_screen
