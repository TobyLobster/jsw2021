; Jet Set Willy
;
; Reassembly by TobyLobster, 2021
;

; game constants

; Proper start position
player_start_room                                   = 21        ; 21 = The Bathroom
player_start_x                                      = 20 * 8    ;
player_start_y                                      = 13 * 8    ;

; Temp start
;player_start_room                                   = 51       ;
;player_start_x                                      = 1 * 8    ; must be even!
;qplayer_start_y                                      = 10 * 8    ;

; Tree Root
;player_start_room                                   = 60           ;
;player_start_x                                      = 23 * 8 - 2   ; must be even!
;player_start_y                                      = 11 * 8       ;

; West of Kitchen
;player_start_room                                   = 34           ;
;player_start_x                                      = 11 * 8       ; must be even!
;player_start_y                                      = 1 * 8        ;

charA          = 0
charT          = 17
chara          = 26
chare          = 30
charh          = 33
charp          = 41
char0          = 52
charApostrophe = 62
charSpace      = 63
charColon      = 64
charFullStop   = 65
charPlus       = 66
charFuzzy      = 67
charTab        = 68

; notes
b2  = 0
cs3 = 1
d3  = 2
e3  = 3
es3 = f3
f3  = 4
fs3 = 5
a3  = 6
b3  = 7
cs4 = 8
d4  = 9
e4  = 10
fs4 = 11
g4  = 12
gs4 = 13
a4  = 14
as4 = 15
b4  = 16
c5  = 17
cs5 = 18
d5  = 19
ds5 = 20
e5  = 21
es5 = f5
f5  = 22
fs5 = 23
g5  = 24
gs5 = 25
a5  = 26
b5  = 27
cs6 = 28
d6  = 29
e6  = 30
non = 31

!macro note .pitch, .dur {
    !if (.dur = 1) {
        .durIndex = 0
    }
    !if (.dur = 2) {
        .durIndex = 1
    }
    !if (.dur = 3) {
        .durIndex = 2
    }
    !if (.dur = 4) {
        .durIndex = 3
    }
    !if (.dur = 6) {
        .durIndex = 4
    }
    !if (.dur = 7) {
        .durIndex = 5
    }
    !if (.dur = 9) {
        .durIndex = 6
    }
    !if (.dur = 12) {
        .durIndex = 7
    }
    !ifndef .durIndex {
        !error "Unknown duration"
    }
    !byte .pitch + 32 * .durIndex
}

!macro end_melody {
    !byte 0
}

; ***************************************************************************************
; os variables
irq_accumulator                                     = $fc
irq1_vector_low                                     = $0204
irq1_vector_high                                    = $0205

crtcAddressRegister                                 = $fe00     ;
crtcAddressWrite                                    = $fe01     ;

; ***************************************************************************************
; Video ULA Register
;         bits 765: determines cursor width
;         bit    4: 0 = 40 bytes per scan line, 1 = 80 bytes per scan line
;         bits  32: number of columns (%00=10 columns, %01=20, %10=40, %11=80)
;            bit 1: teletext (1=enabled, 0=disabled)
;            bit 0: current flashing colour state
videoULARegister                                    = $fe20
videoULAPaletteRegister                             = $fe21     ; Video ULA palette register

ROMSEL                                              = $fe30     ; ROM Select (Master)

; ***************************************************************************************
; Write to System VIA, register B
; On Entry:
;     Interrupts must already be disabled
;     A = value to write (0-15)
;
; Notes:
;     Values 0-15 can be written to System VIA Port B:
;
;         Value   Effect
;         -------------------------
;         0       Enable sound chip
;         1       Disable Read Speech
;         2       Disable Write Speech
;         3       Disable Keyboard write
;         4       Hardware scrolling - set C0=0 (See below)
;         5       Hardware scrolling - set C1=0 (See below)
;         6       Turn on Caps LED
;         7       Turn on Shift LED
;         8       Disable sound chip
;         9       Enable Read Speech
;         10      Enable Write Speech
;         11      Enable Keyboard write
;         12      Hardware scrolling - set C0=1 (See below)
;         13      Hardware scrolling - set C1=1 (See below)
;         14      Turn off Caps LED
;         15      Turn off Shift LED
;
; If C0=0 and C1=1 then hardware scrolling starts at $5800
;
systemVIADataDirectionRegisterA                     = $fe43     ; System VIA data direction register A (DDRA)
systemVIARegisterANoHandshake                       = $fe4f     ; System VIA Register A without handshaking

systemVIARegisterB                                  = $fe40     ;
systemVIAInterruptFlagRegister                      = $fe4d     ;

systemVIATimer1CounterLow                           = $fe44     ;
systemVIATimer1CounterHigh                          = $fe45     ;
systemVIATimer1LatchLow                             = $fe46     ;
systemVIATimer1LatchHigh                            = $fe47     ;
systemVIAAuxiliaryControlRegister                   = $fe4b     ;
systemVIAInterruptFlagRegister                      = $fe4d     ;
systemVIAInterruptEnableRegister                    = $fe4e     ;


userVIATimer1CounterLow                             = $fe64     ; Timer 1 counter (low)
userVIATimer1CounterHigh                            = $fe65     ; Timer 1 counter (high)
userVIATimer1LatchLow                               = $fe66     ; Timer 1 latch (low)
userVIATimer1LatchHigh                              = $fe67     ; Timer 1 latch (high)
userVIAAuxiliaryControlRegister                     = $fe6b     ; auxiliary control register
userVIAInterruptFlagRegister                        = $fe6d     ; Interrupt flag register
userVIAInterruptEnableRegister                      = $fe6e     ; Interrupt enable register

OSBYTE                                              = $fff4     ; used during program initialization only

; physical colours
black   = 0
red     = 1
green   = 2
yellow  = 3
blue    = 4
magenta = 5
cyan    = 6
white   = 7

; ***************************************************************************************
; This is the number of timer ticks per frame (num PAL scanlines * 64us/line)
; This timing is only true of non-interlaced modes.
; We have to subtract 2 because the latch reload costs 2us.
; This is not documented anywhere!
FramePeriod     = 312*64-2

; Calculate here the timer value to interrupt at the desired line
Timer1Value      = 76*64 + 39

; This is the delay between interrupts (one character row = 8 pixel rows)
ShortTimerValue  = 8*64 - 2

; game variables (memory locations)
irq_counter                                         = $00
vsync_counter                                       = $01
; $02 [unused]
text_screen_low                                     = $03
text_screen_high                                    = $04
text_colour_mask                                    = $05
old_romsel                                          = $06
character_definitions_low                           = $07
character_definitions_high                          = $08
temp1                                               = $09
temp2                                               = $0a
temp3                                               = $0b
temp4                                               = $0c
temp5                                               = $0d
minutes_low                                         = $0e
minutes_high                                        = $0f
hours                                               = $10
music_note_byte                                     = $11
time_fraction                                       = $12
items_collected_low                                 = $13
items_collected_high                                = $14
first_sound_byte                                    = $15
second_sound_byte                                   = $16
music_enabled                                       = $17
game_over_timer                                     = $18

; sound variables
sound_variables_start                               = $19
sound_counters                                      = $19
sound_counters_1                                    = $1a
sound_counters_2                                    = $1b
sound_counters_3                                    = $1c
pitch_low                                           = $1d
pitch_low_1                                         = $1e
pitch_low_2                                         = $1f
pitch_low_3                                         = $20
pitch_high                                          = $21
pitch_high_1                                        = $22
pitch_high_2                                        = $23
pitch_high_3                                        = $24
sound_duration_for_channel_x                        = $25
sound_duration_for_channel_x_1                      = $26
sound_duration_for_channel_x_2                      = $27
sound_duration_for_channel_x_3                      = $28
pitch_increment_for_channel_x                       = $29
pitch_increment_for_channel_x_1                     = $2a
pitch_increment_for_channel_x_2                     = $2b
pitch_increment_for_channel_x_3                     = $2c
sound_temp_y                                        = $2d
sound_variables_end                                 = $2d
hours_am                                            = $2e

; player state on entry into the current room (reset to these values on death)
entry_horizontal_speed                              = $2f
entry_jump_timer                                    = $30
entry_x                                             = $31
entry_y                                             = $32
entry_is_jumping                                    = $33

temp_high                                           = $34
shortcut_table_entry                                = $35
title_length                                        = $36

keyStates                                           = $37
keyStateZ                                           = keyStates
keyStateX                                           = $38
keyStateReturn                                      = $39
keyStateSpace                                       = $3a
keyStateS                                           = $3b
keyStateQ                                           = $3c
keyStateEscape                                      = $3d
keyStateShift                                       = $3e

items_colour                                        = $3f
items_colour1                                       = $40
items_colour2                                       = $41
items_colour3                                       = $42
items_colour4                                       = $43
items_colour5                                       = $44
items_colour6                                       = $45
items_colour7                                       = $46
items_colour8                                       = $47
items_colour9                                       = $48
items_colour10                                      = $49
items_colour11                                      = $4a

replay_timer                                        = $4b

; $4c [unused]

; initialised values
life_y                                              = $4d
space_tile                                          = $4e
swimming_pool_item_collected                        = $4f
room_data_address                                   = $50
room_data_address_low                               = $50
room_data_address_high                              = $51
room_data_offset                                    = $52
bits_remaining_in_room_data_byte                    = $53
room_data_byte                                      = $54
player_room                                         = $55
pages_of_tile_table_remaining_when_finding_conveyor = $56
game_timer                                          = $57
conveyor_length                                     = $58
conveyor_screen_address_low                         = $59
conveyor_screen_address_high                        = $5a
rope_position_relative_to_centre                    = $5b
rope_velocity_relative_to_centre                    = $5c
rope_end_x                                          = $5d
rope_end_y                                          = $5e
rope_position                                       = $5f
tile_address_low1                                   = $60
tile_address_high1                                  = $61
where_player_fell_from                              = $62
player_killed                                       = $63
player_is_jumping                                   = $64
player_jump_timer                                   = $65
items_in_room_minus_one                             = $66
item_number                                         = $67
tile1                                               = $68
player_conveyor_direction                           = $69
conveyor_direction                                  = $6a
player_on_slope                                     = $6b
slope_direction                                     = $6c
do_triangle_ends                                    = $6d
length1                                             = $6e
room_contains_rope                                  = $6f
x1                                                  = $70
tile_x                                              = $70
scrolltext_address_low                              = $70
timer_one                                           = $70
y                                                   = $71
tile_y                                              = $71
scrolltext_address_high                             = $71
timer_two                                           = $71
tile_type                                           = $72
scrolltext_offset                                   = $72
conveyor_colour_eor                                 = $73
length2                                             = $74
start_x                                             = $75
previous_x                                          = $75
height1                                             = $76
previous_y1                                         = $76
x_delta                                             = $77
y_delta                                             = $78
width                                               = $79
enemy_to_consider1                                  = $79
count                                               = $7a
number_of_frames                                    = $7a
block_y_delta                                       = $7a
rope_pixel_to_consider                              = $7a
row_length                                          = $7a
item_state                                          = $7b
previous_speed                                      = $7b
enemy_x                                             = $7b
next_y                                              = $7b
sprite_frames                                       = $7b
tmp                                                 = $7b
next_tile_offset                                    = $7b
conveyor_sections_remaining_to_update               = $7b
tile2                                               = $7b
life_colour                                         = $7b
player_y_fraction                                   = $7b
mod_three                                           = $7b
previous_tile_address_low                           = $7b
rope_pixel_touched                                  = $7b
direction                                           = $7c
triangle_direction                                  = $7d
x_skip                                              = $7e
triangle_length                                     = $7f
height2                                             = $80
room                                                = $81
conveyor_colour                                     = $81
previous_y2                                         = $81
previous_tile_type                                  = $81
add_first_and_last                                  = $82
direction_base                                      = $83
unpacked_sprite_address_low                         = $84
unpacked_sprite_address_high                        = $85
unpacked_sprite_offset                              = $86
enemies_on_screen                                   = $87
unpacked_byte_two                                   = $88
sprite_colour                                       = $89
sprite_colour_eor                                   = $8a
enemy_to_consider2                                  = $8b
player_started_jump                                 = $8c
player_x                                            = $8d
player_y                                            = $8e
player_horizontal_speed                             = $8f
tile_address_low2                                   = $90
rope_pixels_screen_address_low                      = $90
tile_address2                                       = $90
screen_address_low                                  = $90
rope_pixels_screen_address_high                     = $91
tile_address_high2                                  = $91
screen_address_high                                 = $91
;sprite_address_low2                                 = $92
;sprite_address_high2                                = $93
sprite_size_in_bytes                                = $94
sprite_width                                        = $95
rows_to_check                                       = $96
previous_sprite_address_high                        = $96
x2                                                  = $96
value                                               = $96
rope_pixel_position                                 = $96
arrow                                               = $96
lives_remaining_to_plot                             = $96
times_three                                         = $96
walls                                               = $96
buffer_offset                                       = $97
previous_sprite_address_low                         = $97
life_x                                              = $97
buffer_y                                            = $97
invert                                              = $97
start_of_word                                       = $97
bit_for_item                                        = $97
rope_pixel_x                                        = $97
seven                                               = $98
melody_active                                       = $99
player_entered_room_falling_too_far                 = $9a
player_lives                                        = $9b
player_not_plotted                                  = $9c       ; 2 = don't plot
                                                                ; 1 = don't unplot
                                                                ; 0 = normal
out_of_time                                         = $9d
house_clear                                         = $9e
player_rope_pixel                                   = $9f

title_text_source_low                               = $a0
title_text_source_high                              = $a1
title_text_destination_low                          = $a2
title_text_destination_high                         = $a3
title_text_loop_counter                             = $a4
temp_address_low                                    = $a5
temp_address_high                                   = $a6
num_sprites_remaining                               = $a7
num_rows_remaining                                  = $a8
should_reflect                                      = $a9
reflect_destination_offset                          = $aa
temp_reflectY                                       = $ab
temp_reverse                                        = $ac
anim_index                                          = $ad
scenery_len                                         = $ae
final_strip_offset                                  = $af
move_title_down_loop_counter                        = $b0
title_delay_before_restart                          = $b1
sprite_counter_low                                  = $b2
sprite_counter_high                                 = $b3
compressed_data_low                                 = $b4
compressed_data_high                                = $b5
enemy_sprite_counter                                = $b6
size_in_bytes                                       = $b7
decoded                                             = $b8
is_start_of_sprite                                  = $b9
val                                                 = $ba
previous_bytes                                      = $bb
previous_bytes1                                     = $bc
previous_bytes2                                     = $bd
previous_bytes3                                     = $be
size_in_bytes_minus_one                             = $bf
nybble_offset                                       = $c0
temp_test_for_direction                             = $c1
temp_old_position                                   = $c2
temp_rope                                           = $c3
enemy_sprite_to_decompress                          = $c4
palette_loop_counter                                = $c5
blocks_to_copy                                      = $c6
temp_addr_low                                       = $c7
temp_addr_high                                      = $c8
sprite_address_low1                                 = $c9
sprite_address_high1                                = $ca
tmp2                                                = $cb
packed_byte1                                        = $cc
packed_byte2                                        = $cd

; melody variables
note_number                                         = $cf       ; }
note_number1                                        = $d0       ; }
note_number2                                        = $d1       ; }
note_length                                         = $d2       ; }
note_length1                                        = $d3       ; }
note_length2                                        = $d4       ; } per channel
note_volume                                         = $d5       ; }
note_volume1                                        = $d6       ; }
note_volume2                                        = $d7       ; }
note_decay_amount                                   = $d8       ; }
note_decay_amount1                                  = $d9       ; }
note_decay_amount2                                  = $da       ; }
tune_number                                         = $db
tune_speed                                          = $dc
music_timer                                         = $dd
pre_tune_delay                                      = $de
room_item_sprite                                    = $df       ; 16 bytes: $df - $ee

screen_memory_start                                 = $5600
text_message_address                                = screen_memory_start + 20 * $0200  ; row 20

* = $0208

; ***************************************************************************************
initialise_room
    jsr initialise_room_data                        ;
    jsr initialise_enemies                          ;
    jsr initialise_arrows                           ;
    jsr calculate_screen_address_of_conveyor        ;
    jsr plot_enemies                                ; [not really needed, but may be useful for screenshots]
    rts                                             ;

; ***************************************************************************************
initialise_room_data
    lda #0                                          ;
    sta room_data_offset                            ;
    sta bits_remaining_in_room_data_byte            ;
    sta player_rope_pixel                           ;
    sta game_timer                                  ;
    ldx player_room                                 ;
    jsr calculate_room_data_address                 ;
    ldy #>($7e00-screen_memory_start)               ;
    jsr clear_screen_y                              ;
    jsr initialise_room_items_and_exits             ;
    jsr initialise_room_background_tiles_and_title  ;
    lda #$ee                                        ;
    sta rope_position                               ;
    lda #$ff                                        ;
    sta item_number                                 ;
    sta rope_velocity_relative_to_centre            ;
    sta rope_position_relative_to_centre            ;
    lda #1                                          ;
    sta player_not_plotted                          ; Mark player as not needing to be unplotted
    lda out_of_time                                 ;
    sta player_killed                               ;
    lda player_horizontal_speed                     ; Store how player entered room
    sta entry_horizontal_speed                      ;
    lda player_jump_timer                           ;
    sta entry_jump_timer                            ;
    lda player_x_in_enemies                         ;
    sta entry_x                                     ;
    lda player_y_in_enemies                         ;
!if (* != $0256) {
    !if (* != $0257) {
        !error "Error setting break effect byte $0258, wrong position!"
    }
}
    bit $0303                                       ; set $0258 to 3. This value is normally set by *FX 200,3 to clear memory on break
                                                    ; This ensures a clean CTRL-Break
    sta entry_y                                     ;
    sta where_player_fell_from                      ;
    lda player_is_jumping                           ;
    sta entry_is_jumping                            ;
    jsr reset_tile_xy                               ;
    lda #0                                          ;
    sta tile_type                                   ;
    jsr wipe_tile_table                             ;
initialise_background_scenery_loop
    ldy #$ff                                        ;
calculate_routine_number_loop                       ; Reading two bits at a time, count 11 as meaning +3
    iny                                             ;
    ldx #2                                          ;
    jsr get_x_bits_of_room_data                     ;
    cmp #3                                          ;
    beq calculate_routine_number_loop               ;
    sta mod_three                                   ;
    sty times_three                                 ;
    tya                                             ;
    asl                                             ;
    asl                                             ;
    adc mod_three                                   ;
    sec                                             ;
    sbc times_three                                 ;
    cmp #6                                          ;
    beq finish_up_tiles                             ;
    asl                                             ;
    tax                                             ;
    lda background_initialisation_routines_address_table,X      ;
    sta background_initialisation_routine_address_low           ;
    lda background_initialisation_routines_address_table + 1,X  ;
    sta background_initialisation_routine_address_high          ;

background_initialisation_routine_address_low = * + 1
background_initialisation_routine_address_high = * + 2
    jsr $ffff                                       ; [overwritten before use]
    jmp initialise_background_scenery_loop          ;

finish_up_tiles
    ; Set item graphic
    ldx #15                                         ;
-
    lda unpacked_background_sprite,X                ;
    sta room_item_sprite,X                          ;
    dex                                             ;
    bpl -                                           ;

null_routine
leave8
    rts                                             ;

; ***************************************************************************************
get_x_bits_of_room_data
    sty tmp                                         ;
    lda #0                                          ;
    sta value                                       ;
get_x_bits_of_room_data_loop
    dec bits_remaining_in_room_data_byte            ;
    bpl bits_still_remaining                        ;
    lda #7                                          ;
    sta bits_remaining_in_room_data_byte            ;
    ldy room_data_offset                            ;
    lda (room_data_address),Y                       ;
    sta room_data_byte                              ;
    inc room_data_offset                            ;
bits_still_remaining
    lsr room_data_byte                              ;
    rol value                                       ;
    dex                                             ;
    bne get_x_bits_of_room_data_loop                ;
    ldy tmp                                         ;
    lda value                                       ;
    rts                                             ;

; ***************************************************************************************
background_initialisation_routines_address_table
    !word set_tile_type                             ; 0 00
    !word set_tile_x_and_y                          ; 1 01
    !word add_straight_line_of_tiles                ; 2 10
    !word add_block_of_tiles                        ; 3 11 00
    !word add_series_of_tiles                       ; 4 11 01
    !word add_diagonal_line_of_tiles                ; 5 11 10
    !word null_routine                              ; 6 11 11 00
    !word null_routine                              ; 7 11 11 01 - [unused]
    !word add_triangle_of_tiles                     ; 8 11 11 10

; ***************************************************************************************
set_tile_type
    ldx #3                                          ; Get three bits of room data for tile type
    jsr get_x_bits_of_room_data                     ;
    sta tile_type                                   ;
    rts                                             ;

; ***************************************************************************************
set_tile_x_and_y
    ldx #5                                          ; Get five bits of room data for x position
    jsr get_x_bits_of_room_data                     ;
    sta tile_x                                      ;
    ldx #4                                          ; Get four bits of room data for y position
    jsr get_x_bits_of_room_data                     ;
    sta tile_y                                      ;
    rts                                             ;

; ***************************************************************************************
add_straight_line_of_tiles
    lda #1                                          ; Add first and last tiles
    ldx #0                                          ; Get one bit of room data for direction
    ldy #5                                          ; Get five bits of room data for length of run
    jmp add_line_of_tiles                           ;

; ***************************************************************************************
add_diagonal_line_of_tiles
    lda tile_type                                   ;
    sta previous_tile_type                          ;
    lda #2                                          ; SLOPE
    sta tile_type                                   ;
    lda #1                                          ; Add first and last tiles
    ldx #8                                          ; Get one bit of room data for diagonal direction
    ldy #4                                          ; Get four bits of room data
    jsr add_line_of_tiles                           ;
    lda previous_tile_type                          ;
    sta tile_type                                   ;
    lda tile_x                                      ;
    clc                                             ;
    adc x_delta                                     ;
    sta tile_x                                      ;
    rts                                             ;

; ***************************************************************************************
add_series_of_tiles
    ldx #4                                          ;
    jsr get_x_bits_of_room_data                     ; Get four bits of room data for number of tiles
    sta length1                                     ;
add_series_of_tiles_loop                            ; For each tile,
    ldx #5                                          ;
    jsr get_x_bits_of_room_data                     ; Get five bits of room data for x co-ordinate
    sta tile_x                                      ;
    ldx #4                                          ;
    jsr get_x_bits_of_room_data                     ; Get four bits of room data for y co-ordinate
    sta tile_y                                      ;
    jsr add_background_tile                         ;
    dec length1                                     ;
    bpl add_series_of_tiles_loop                    ;
reset_tile_xy
    lda #0                                          ;
    sta tile_x                                      ;
    sta tile_y                                      ;
    rts                                             ;

; ***************************************************************************************
add_block_of_tiles
    ldx #5                                          ;
    jsr get_x_bits_of_room_data                     ; Get five bits of room data for width of block
    sta width                                       ;
    lda tile_x                                      ;
    sta start_x                                     ;
    lda tile_y                                      ;
    sta height1                                     ;
    ldx #4                                          ;
    jsr get_x_bits_of_room_data                     ; Get four bits of room data for y end
    sta tile_y                                      ;
    lda height1                                     ;
    sec                                             ;
    sbc tile_y                                      ;
    ldx #1                                          ;
    bcs skip_inversion2                             ;
    eor #$ff                                        ;
    adc #1                                          ;
    ldx #$ff                                        ;
skip_inversion2
    sta height1                                     ;
    stx block_y_delta                               ;
add_block_of_tiles_loop
    lda #0                                          ; Add tiles from left to right
    sta direction                                   ;
    lda width                                       ;
    sta length2                                     ;
    lda start_x                                     ;
    sta tile_x                                      ;
    lda #1                                          ; Add first and last tiles
    ldx #$80                                        ; Use previous direction
    jsr add_line_of_tiles                           ;
    lda tile_y                                      ;
    clc                                             ;
    adc block_y_delta                               ;
    sta tile_y                                      ;
    dec height1                                     ;
    bpl add_block_of_tiles_loop                     ;
    lda tile_y                                      ;
    sec                                             ;
    sbc block_y_delta                               ;
    sta tile_y                                      ;
    lda tile_x                                      ;
    clc                                             ;
    adc x_delta                                     ;
    sta tile_x                                      ;
    rts                                             ;

; ***************************************************************************************
add_triangle_of_tiles
    lda tile_x                                      ;
    sta previous_x                                  ;
    lda tile_y                                      ;
    sta previous_y1                                 ;
    ldx #1                                          ;
    jsr get_x_bits_of_room_data                     ; Get one bit of room data for triangle direction
    ldx #1                                          ;
    stx do_triangle_ends                            ;
    sta triangle_direction                          ;
    tay                                             ;
    beq skip_x_inversion                            ;
    ldx #$ff                                        ;
skip_x_inversion
    stx x_skip                                      ;
    ldx #4                                          ;
    jsr get_x_bits_of_room_data                     ; Get four bits of room data for triangle height
    sta row_length                                  ;
    sta triangle_length                             ;
    sec                                             ;
    sbc tile_y                                      ;
    sta height2                                     ;
    bcs skip_y_inversion                            ;
    eor #$ff                                        ;
    adc #1                                          ;
    sta height2                                     ;
    dec do_triangle_ends                            ;
    lda row_length                                  ;
    ldx tile_y                                      ;
    sta tile_y                                      ;
    stx row_length                                  ;
    jmp add_triangle_of_tiles_loop                  ;
skip_y_inversion
    ldx height2                                     ;
    lda x_skip                                      ;
    eor #$ff                                        ;
    adc #0                                          ;
    sta x_skip                                      ;
    bmi +                                           ;
    txa                                             ;
    eor #$ff                                        ;
    tax                                             ;
    inx                                             ;
+
    txa                                             ;
    clc                                             ;
    adc tile_x                                      ;
    sta tile_x                                      ;
add_triangle_of_tiles_loop
    lda #1                                          ; Add tiles from right to left
    sta direction                                   ;
    lda row_length                                  ;
    sta length2                                     ;
    lda tile_y                                      ;
    sta previous_y2                                 ;
    lda #1                                          ; Add first and last tiles
    ldx #$80                                        ; Use previous direction
    jsr add_line_of_tiles                           ;
    lda previous_y2                                 ;
    sta tile_y                                      ;
    lda tile_x                                      ;
    clc                                             ;
    adc x_skip                                      ;
    sta tile_x                                      ;
    dec row_length                                  ;
    dec height2                                     ;
    bpl add_triangle_of_tiles_loop                  ;
    lda previous_x                                  ;
    sta tile_x                                      ;
    lda previous_y1                                 ;
    sta tile_y                                      ;
    lda triangle_direction                          ;
    sta direction                                   ;
    lda triangle_length                             ;
    sta length2                                     ;
    lda tile_type                                   ;
    sta previous_tile_type                          ;
    lda #2                                          ; WALL
    sta tile_type                                   ;
    lda triangle_direction                          ; Determine whether to add first and last tiles
    eor slope_direction                             ; based on whether triangle faces same as room slope
    eor do_triangle_ends                            ;
    ldx #$88                                        ; Use previous diagonal direction
    jsr add_line_of_tiles                           ;
    lda previous_tile_type                          ;
    sta tile_type                                   ;
    lda tile_x                                      ;
    clc                                             ;
    adc x_delta                                     ;
    sta tile_x                                      ;
    rts                                             ;

; ***************************************************************************************
;
; On Entry:
;   X is the base direction
;
; Directions are:
;   0 = right
;   1 = up
;   2 = left
;   3 = down
;   8 = right and up diagonal
;   9 = left and up diagonal
;  10 = right and down diagonal
;  11 = left and down diagonal
;
; ***************************************************************************************
add_line_of_tiles
    sta add_first_and_last                          ;
    stx direction_base                              ;
    txa                                             ;
    bmi use_previous_direction                      ;
    ldx #1                                          ;
    jsr get_x_bits_of_room_data                     ;
    sta direction                                   ;
    tya                                             ;
    tax                                             ;
    jsr get_x_bits_of_room_data                     ;
    sta length2                                     ;
use_previous_direction
    lda direction_base                              ;
    ldx tile_y                                      ;
    and #$7f                                        ;
    clc                                             ;
    adc direction                                   ;
    sta direction                                   ;
    bne vertical_line                               ;
    ldx tile_x                                      ;
vertical_line
    lda length2                                     ;
    stx tmp                                         ;
    sec                                             ;
    sbc tmp                                         ;
    bcs skip_inversion3                             ;
    eor #$ff                                        ;
    clc                                             ;
    adc #1                                          ;
    inc direction                                   ;
    inc direction                                   ;
skip_inversion3
    sta length2                                     ;
    beq add_last_tile                               ;
    ldx direction                                   ;
    lda directions_x,X                              ;
    sta x_delta                                     ;
    lda directions_y,X                              ;
    sta y_delta                                     ;
add_line_of_tiles_loop
    lda add_first_and_last                          ;
    beq skip_first                                  ;
    jsr add_background_tile                         ;
skip_first
    lda tile_x                                      ;
    clc                                             ;
    adc x_delta                                     ;
    sta tile_x                                      ;
    lda tile_y                                      ;
    clc                                             ;
    adc y_delta                                     ;
    sta tile_y                                      ;
    dec length2                                     ;
    bne add_line_of_tiles_loop                      ;
add_last_tile
    lda add_first_and_last                          ;
    beq skip_last                                   ;
    jsr add_background_tile                         ;
skip_last
    rts                                             ;

; ***************************************************************************************
add_background_tile
    ldy tile_type                                   ;
    lda background_tiles_sprites,Y                  ;
    pha                                             ;
    ldx background_tiles_colours_fg,Y               ;
    lda background_tiles_colours_bg,Y               ;
    tay                                             ;
    pla                                             ;
    jsr plot_background_sprite                      ;
    jmp set_tile_table_for_background               ;

directions_x
    !byte $01, $00, $ff, $00                        ;
directions_y
    !byte $00, $01, $00, $ff                        ;
diagonal_directions_x
    !byte $01, $ff, $01, $ff                        ;
diagonal_directions_y
    !byte $01, $01, $ff, $ff                        ;

; ***************************************************************************************
unpack_enemy_sprites
    lda #<unpacked_enemy_sprites                    ;
    sta unpacked_sprite_address_low                 ;
    lda #>unpacked_enemy_sprites                    ;
    sta unpacked_sprite_address_high                ;

    lda #8                                          ; The player sprite has 8 frames
    sta unpacked_sprite_offset                      ; skip over the player sprites
    lda enemies_on_screen                           ;
    sta enemy_to_consider1                          ;
    beq leave9                                      ; if (no enemies) then branch (return)

unpack_enemy_sprites_loop
    ldx enemy_to_consider1                          ; which enemy index to look at
    cpx enemies_on_screen                           ;
    beq first_enemy                                 ; If (first enemy) then branch

    ; check to see if we have already done this sprite
    ldy enemies_on_screen                           ; loop counter
check_if_enemy_already_unpacked                     ; has its sprite already been used?
    lda enemies_sprite,Y                            ;
    cmp enemies_sprite,X                            ;
    bne different_sprite                            ;
    lda enemies_unpacked_sprite_offset,Y            ;
    sta enemies_unpacked_sprite_offset,X            ;
    bpl consider_next_enemy1                        ;

different_sprite
    dey                                             ;
    cpy enemy_to_consider1                          ;
    bne check_if_enemy_already_unpacked             ;

first_enemy                                         ;
    ; unpack sprite: first get sprite address
    ldy enemies_sprite,X                            ;
    lda unpacked_sprite_offset                      ;
    sta enemies_unpacked_sprite_offset,X            ; store enemy sprite number
    lda enemy_sprites_frames,Y                      ;
    sta should_reflect                              ; top bit set if reflection required
    php                                             ;
    and #$7f                                        ;
    sta number_of_frames                            ; store number of frames for this enemy
    plp                                             ;
    bpl +                                           ;
    asl                                             ;
+
    clc                                             ;
    adc unpacked_sprite_offset                      ;
    sta unpacked_sprite_offset                      ; unpacked_sprite_offset += number of frames

    lda enemy_sprites_frame_offsets,Y               ;
    sta enemy_sprite_to_decompress                  ;
    ; unpack each sprite in a loop
unpack_frames_loop
    lda enemy_sprite_to_decompress                  ;
    inc enemy_sprite_to_decompress                  ;
    ldx #0                                          ;
    jsr decompress_sprite_xa_and_set_sprite_address ;

    jsr unpack_enemy_sprite                         ;
    dec number_of_frames                            ; unpack a frame each time round this loop
    bne unpack_frames_loop                          ;

    lda should_reflect                              ;
    bmi reflect                                     ;

consider_next_enemy1
    dec enemy_to_consider1                          ;
    bne unpack_enemy_sprites_loop                   ;

leave9
    rts                                             ;

decompressed_sprite
    !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

; ***************************************************************************************
update_temp_address
    lda temp_address_low                            ; }
    sec                                             ; }
    sbc #64                                         ; } temp_address -= 64
    sta temp_address_low                            ; }
    bcs +                                           ; }
    dec temp_address_high                           ; }
+
    rts                                             ;

; ***************************************************************************************
reflect
    lda unpacked_sprite_address_low                 ;
    sta temp_address_low                            ; temp_address = unpacked_sprite_address
    lda unpacked_sprite_address_high                ;
    sta temp_address_high                           ;

    lda #4                                          ;
    sta num_sprites_remaining                       ;
    ldx #0                                          ; destination offset
    stx reflect_destination_offset                  ; }
reflect_sprites_loop
    jsr update_temp_address                         ;
    lda #16                                         ; copy 16 rows
    sta num_rows_remaining                          ;

    ; read four bytes, reverse them and store them
reflect_rows_loop
    ldy #3                                          ; loop counter
-
    sty temp_reflectY                               ;
    lda (temp_address_low),Y                        ;
    jsr reverse_each_nybble                         ;
    ldy reflect_destination_offset                  ;
    sta (unpacked_sprite_address_low),Y             ; store byte
    inc reflect_destination_offset                  ; increment destination offset
    ldy temp_reflectY                               ;
    dey                                             ;
    bpl -                                           ;

    ; move to next row
    lda temp_address_low                            ; }
    clc                                             ; }
    adc #4                                          ; } add 4 to temp_address
    sta temp_address_low                            ; }
    bcc +                                           ; }
    inc temp_address_high                           ; }
+
    dec num_rows_remaining                          ;
    bne reflect_rows_loop                           ;

    ; go on to next sprite
    jsr update_temp_address                         ;
    dec num_sprites_remaining                       ;
    bne reflect_sprites_loop                        ;

    ; move high byte on one. Assumes 4 sprites
    inc unpacked_sprite_address_high                ;

    jmp consider_next_enemy1                        ;

; ***************************************************************************************
;
; On entry: A = bit pattern: abcdefgh
; On exit:  A = bit pattern: dcbahgfe
;
; 19 instructions, 28 bytes, 46 cycles (assuming temp_reverse is in zero page, and including RTS).
;
; ***************************************************************************************
reverse_each_nybble
    tax                                             ; X = abcdefgh
    and #$AA                                        ; A = a0c0e0g0
    lsr                                             ; A = 0a0c0e0g
    sta temp_reverse                                ; t = 0a0c0e0g
    txa                                             ; A = abcdefgh
    asl                                             ; A = bcdefgh0
    and #$AA                                        ; A = b0d0f0h0
    ora temp_reverse                                ; A = badcfehg
    tax                                             ; X = badcfehg
    and #$33                                        ; A = 00dc00hg
    asl                                             ; A = 0dc00hg0
    asl                                             ; A = dc00hg00
    sta temp_reverse                                ; t = dc00hg00
    txa                                             ; A = badcfehg
    lsr                                             ; A = 0badcfeh
    lsr                                             ; A = 00badcfe
    and #$33                                        ; A = 00ba00fe
    ora temp_reverse                                ; A = dcbahgfe
    rts                                             ;

; ***************************************************************************************
unpack_enemy_sprite
    ldy #0                                          ; loop counter for target (increments)
    ldx #31                                         ; loop counter for source (decrementing)
unpack_enemy_sprite_loop
    sty tempY                                       ; remember Y
    txa                                             ;
    tay                                             ; Y = X
    lda (sprite_address_low1),Y                     ; get byte from 1bpp sprite
    jsr unpack_byte_of_sprite_data                  ; unpack into two bytes of 2bpp data
    ldy unpacked_byte_two                           ; }
    sta unpacked_byte_two                           ; } swap A and unpacked_byte_two
    tya                                             ; }
tempY = * + 1
    ldy #$ff                                        ; recall Y
    sta (unpacked_sprite_address_low),Y             ; store first of two bytes
    iny                                             ;
    lda unpacked_byte_two                           ;
    sta (unpacked_sprite_address_low),Y             ; store second of two bytes
    iny                                             ;
    dex
    bpl unpack_enemy_sprite_loop                    ;

    lda sprite_address_low1                         ;
    clc                                             ;
    adc #32                                         ;
    sta sprite_address_low1                         ; add 32 to source address
    bcc +                                           ;
    inc sprite_address_high1                        ;
+
    lda unpacked_sprite_address_low                 ;
    clc                                             ;
    adc #64                                         ;
    sta unpacked_sprite_address_low                 ; add 64 to destination address
    bcc +                                           ;
    inc unpacked_sprite_address_high                ;
+
    rts                                             ;

; ***************************************************************************************
unpack_byte_of_sprite_data
    sta packed_byte1                                ;
    and #$f0                                        ;
    sta tmp2                                        ;
    lsr                                             ;
    lsr                                             ;
    lsr                                             ;
    lsr                                             ;
    ora tmp2                                        ;
    sta unpacked_byte_two                           ;
    lda packed_byte1                                ;
    and #$0f                                        ;
    sta tmp2                                        ;
    asl                                             ;
    asl                                             ;
    asl                                             ;
    asl                                             ;
    ora tmp2                                        ;
    rts                                             ;

; ***************************************************************************************
;
; On Entry:
;  A holds the X coordinate in pixels
;  X holds the Y coordinate in pixels
;
; ***************************************************************************************
calculate_screen_address
    and #$fc                                        ; lose the lower two bits
    asl                                             ; shift up
    sta screen_address_low                          ; store
    rol screen_address_high                         ; carry into high byte

    txa                                             ;
    and #7                                          ;
    clc                                             ;
    adc screen_address_low                          ;
    sta screen_address_low                          ;

    txa                                             ;
    lsr                                             ;
    lsr                                             ;
    and #%11111110                                  ;
    ror screen_address_high                         ;
    adc #>screen_memory_start                       ;

    sta screen_address_high                         ;
    rts                                             ;

!if (<screen_memory_start != 0) {
    !error "Screen memory should be page aligned"
}

; ***************************************************************************************
;
; On Entry:
;  A holds the X coordinate in pixels
;  X holds the Y coordinate in pixels
;  plot_sprite_address_low/high
;
; ***************************************************************************************
plot_sprite
    jsr calculate_screen_address                    ;
    ldx sprite_size_in_bytes                        ;
plot_sprite_group_loop
    ldy sprite_width                                ;
    sec                                             ;

plot_sprite_loop
plot_sprite_address_low = * + 1
plot_sprite_address_high = * + 2
    lda $ffff,X                                     ; [address overwritten before use: LDA plot_sprite_address,X]
    and sprite_colour                               ;
    sta (screen_address_low),Y                      ;
    dex                                             ;
    tya                                             ;
    sbc #8                                          ;
    tay                                             ;
    bcs plot_sprite_loop                            ;

    txa                                             ;
    bmi leave10                                     ;
plot_sprite_skipping_first_column
    inc screen_address_low                          ;
    lda screen_address_low                          ;
    bit seven                                       ;
    bne plot_sprite_group_loop                      ;
    sec                                             ;
    sbc #8                                          ;
    sta screen_address_low                          ;
    inc screen_address_high                         ;
    inc screen_address_high                         ;
    bpl plot_sprite_group_loop                      ;
leave10
    rts                                             ;

; ***************************************************************************************
decompress_background_sprite
    ldx #0                                          ;
    clc                                             ;
    adc #num_enemy_sprites                          ;
    bcc +                                           ;
    inx                                             ;
+
decompress_sprite_xa_and_set_sprite_address
    jsr decompress_sprite_xa                        ;
    lda #<decompressed_sprite                       ;
    sta sprite_address_low1                         ;
    lda #>decompressed_sprite                       ;
    sta sprite_address_high1                        ;
    rts                                             ;

; ***************************************************************************************
add_to_decoded_bytes
    ldy decoded                                     ;
    sta decompressed_sprite,Y                       ;
    inc decoded                                     ; decoded++
    cmp previous_bytes + 3                          ;
    beq +                                           ;

    tay                                             ;
    lda previous_bytes + 1                          ;
    sta previous_bytes                              ;
    lda previous_bytes + 2                          ;
    sta previous_bytes + 1                          ;
    lda previous_bytes + 3                          ;
    sta previous_bytes + 2                          ;
    sty previous_bytes + 3                          ;
+
    rts                                             ;

; ***************************************************************************************
get_next_nybble
    ldy #0                                          ;
    lda nybble_offset                               ;
    beq get_low_nybble                              ;
    dec nybble_offset                               ;
    lda (compressed_data_low),Y
    lsr                                             ;
    lsr                                             ;
    lsr                                             ;
    lsr                                             ;
    inc compressed_data_low                         ;
    beq +                                           ;
    rts                                             ;
+
    inc compressed_data_high                        ;
    rts                                             ;

get_low_nybble
    inc nybble_offset                               ;
    lda (compressed_data_low),Y                     ;
    and #15                                         ;
    rts                                             ;

; ***************************************************************************************
previous_decompressed_low
    !byte 255
previous_decompressed_high
    !byte 255

; ***************************************************************************************
decompress_sprite_xa
    cmp previous_decompressed_low                   ;
    bne +                                           ;
    cpx previous_decompressed_high                  ;
    bne +                                           ;
    rts                                             ;

+
    sta previous_decompressed_low                   ;
    stx previous_decompressed_high                  ;

    ldy #num_enemy_sprites                          ;
    sty enemy_sprite_counter                        ; enemy_sprite_counter = 0
    ldy #0                                          ;
    sty shortcut_table_entry                        ;
--
    cpx #0                                          ;
    bne +                                           ;
    cmp #shortcut_interval                          ;
    bcc got_offset                                  ;
+
    ldy #shortcut_interval-1
-
    dec enemy_sprite_counter                        ;
    dey                                             ;
    bpl -                                           ;
    inc shortcut_table_entry                        ;
    sec                                             ;
    sbc #shortcut_interval                          ;
    bcs --                                          ;
    dex                                             ;
    jmp --                                          ;
got_offset
    sta sprite_counter_low                          ;
    stx sprite_counter_high                         ; sprite_counter = XA
    ldy shortcut_table_entry                        ;
    lda shortcut_table_low,Y                        ;
    sta compressed_data_low                         ;
    lda shortcut_table_high,Y                       ;
    and #%01111111                                  ;
    sta compressed_data_high                        ;
    ldx #0
    lda shortcut_table_high,Y                       ;
    bpl +                                           ;
    ldx #1                                          ;
+
    stx nybble_offset                               ;
    ldx #32                                         ;
    cpy #(num_enemy_sprites + shortcut_interval - 1)/shortcut_interval        ;
    bcc +                                           ;
    lda #0                                          ;
    sta enemy_sprite_counter                        ;
    ldx #8                                          ;
+
    stx size_in_bytes                               ; size_in_bytes = 32
    dex                                             ;
    stx size_in_bytes_minus_one                     ;

    lda #0                                          ;
    sta decoded                                     ; decoded = 0

;    lda #<sprite_data                               ;
;    sta compressed_data_low                         ;
;    lda #>sprite_data                               ;
;    sta compressed_data_high                        ;
find_sprite_loop
    lda size_in_bytes_minus_one                     ;
    and decoded                                     ;
    sta is_start_of_sprite                          ;
    bne done_start_of_sprite_code                   ; if (not start of sprite) then branch
    lda enemy_sprite_counter                        ;
    bne +                                           ; if (enemy_sprite_counter != 0) then branch
    lda #8                                          ;
    sta size_in_bytes                               ; size_in_bytes = 8
    lda #7                                          ;
    sta size_in_bytes_minus_one                     ;

+
    lda sprite_counter_low                          ;
    ora sprite_counter_high                         ;
    beq found_sprite                                ; if (sprite_counter == 0) then branch

    lda sprite_counter_low                          ; }
    bne +                                           ; }
    dec sprite_counter_high                         ; } sprite_counter--
+                                                   ; }
    dec sprite_counter_low                          ; }

    lda enemy_sprite_counter                        ; }
    beq done_start_of_sprite_code                   ; } if (enemy_sprite_counter > 0) enemy_sprite_counter--
    dec enemy_sprite_counter                        ; }
done_start_of_sprite_code
    jsr get_next_nybble                             ;
    inc decoded                                     ; decoded++
    cmp #4                                          ;
    bcc handle_skip_repeat                          ;
    cmp #10                                         ;
    bcc find_sprite_loop                            ;

handle_skip_multi_nybble
    cmp #15                                         ;
    bne +                                           ;
    jsr get_next_nybble                             ;
+
    jsr get_next_nybble                             ;
    jmp find_sprite_loop                            ;

handle_skip_repeat
    lda is_start_of_sprite                          ;
    bne find_sprite_loop                            ; if (not start of sprite) then branch
    dec decoded                                     ;
    lda compressed_data_low
    clc
    adc size_in_bytes                               ;
    sta compressed_data_low                         ;
    bcc +                                           ;
    inc compressed_data_high                        ;
+
    jmp find_sprite_loop                            ;


found_sprite
    lda #0                                          ;
    ldx #3                                          ;
-
    sta previous_bytes,X                            ;
    dex                                             ;
    bpl -                                           ;
    sta decoded                                     ;
    lda #255                                        ;
    sta is_start_of_sprite                          ;
decode_sprite_loop
    jsr get_next_nybble                             ;
    cmp #4                                          ;
    bcc handle_repeat                               ;
    cmp #10                                         ;
    bcc handle_commonmost                           ;
    cmp #15                                         ;
    bcc handle_common                               ;
    beq handle_raw                                  ; ALWAYS branch

after_handler
    inc is_start_of_sprite                          ;
    lda decoded                                     ;
    cmp size_in_bytes                               ;
    bcc decode_sprite_loop                          ;
    rts                                             ;

handle_repeat
    bit is_start_of_sprite                          ;
    bpl real_repeat                                 ; if (not start of sprite) then branch
    ldx size_in_bytes                               ;
-
    jsr get_next_nybble                             ;
    sta val                                         ;
    jsr get_next_nybble                             ;
    asl                                             ;
    asl                                             ;
    asl                                             ;
    asl                                             ;
    ora val                                         ;
    jsr add_to_decoded_bytes                        ;
    dex                                             ;
    bne -                                           ;
    beq after_handler                               ; ALWAYS branch

real_repeat
    tax                                             ;
    lda previous_bytes,X                            ;
store_and_continue
    jsr add_to_decoded_bytes                        ;
    jmp after_handler                               ;

handle_commonmost
    sec                                             ;
    sbc #4                                          ;
look_up_store_and_continue
    tax                                             ;
    lda sprite_decode_table,X                       ;
    jmp store_and_continue                          ;

handle_common
    sec                                             ; } [use a table here instead?]
    sbc #10                                         ; }
    asl                                             ; }
    asl                                             ; } A = ((A-10) * 16)
    asl                                             ; }
    asl                                             ; }
    sta val                                         ;
    jsr get_next_nybble                             ;
    ora val                                         ;
    clc                                             ;
    adc #6                                          ;
    jmp look_up_store_and_continue                  ;

handle_raw
    jsr get_next_nybble                             ;
    sta val                                         ;
    jsr get_next_nybble                             ;
    asl                                             ;
    asl                                             ;
    asl                                             ;
    asl                                             ;
    ora val                                         ;
    jmp store_and_continue                          ;

; ***************************************************************************************
unpack_small_sprite
    ldy #7                                          ;
unpack_background_sprite_loop
    lda (sprite_address_low1),Y                     ;
    jsr unpack_byte_of_sprite_data                  ;
    sta unpacked_background_sprite + 8,Y            ;
    lda unpacked_byte_two                           ;
    sta unpacked_background_sprite,Y                ;
    dey                                             ;
    bpl unpack_background_sprite_loop               ;
    rts                                             ;

; ***************************************************************************************
;
; Plot an 8x8 background sprite
;
; On Entry:
;
;   A is background sprite to draw
;   X is the foreground colour
;   Y is the background colour
;
; ***************************************************************************************
plot_background_sprite
    pha                                             ;
    lda colour_mask_values,X                        ;
    sta sprite_colour                               ;
    lda colour_mask_values,Y                        ;
    sta sprite_colour_eor                           ;
    eor sprite_colour                               ;
    sta sprite_colour                               ;
    pla                                             ;
    jsr decompress_background_sprite                ;

plot_decompressed_sprite
    jsr unpack_small_sprite                         ;
    lda #$0f                                        ;
    sec                                             ;
    sbc tile_y                                      ;
    asl                                             ;
    asl                                             ;
    asl                                             ;
    tax                                             ;
    lda tile_x                                      ;
    asl                                             ;
    asl                                             ;
    asl                                             ;
    jsr calculate_screen_address                    ;

raw_plot_small_sprite
    ldy #$0f                                        ;
plot_background_sprite_loop
    lda unpacked_background_sprite,Y                ;
    and sprite_colour                               ;
    eor sprite_colour_eor                           ;
    sta (screen_address_low),Y                      ;
    dey                                             ;
    bpl plot_background_sprite_loop                 ;
    rts                                             ;

; ***************************************************************************************
plot_font_sprite
    pha                                             ;
    lda text_colour_mask                            ; text drawn on colour 0
    sta sprite_colour                               ;
    lda #0                                          ;
    sta sprite_colour_eor                           ;
    pla                                             ;

    ldx #>first_sprite_of_font                      ;
    clc                                             ;
    adc #<first_sprite_of_font                      ;
    bcc +                                           ;
    inx                                             ;
+
    jsr decompress_sprite_xa_and_set_sprite_address ;
    jsr unpack_small_sprite                         ;

    lda screen_address_low                          ;
    sta temp_addr_low                               ;
    lda screen_address_high                         ; remember screen address
    sta temp_addr_high                              ;

    lda text_screen_low                             ;
    sta screen_address_low                          ;
    lda text_screen_high                            ; set screen address and plot
    sta screen_address_high                         ;
    jsr raw_plot_small_sprite                       ;

    lda temp_addr_low                               ;
    sta screen_address_low                          ;
    lda temp_addr_high                              ; restore screen address
    sta screen_address_high                         ;

    rts                                             ;

; ***************************************************************************************
;
; On Entry:
;   X is the sprite number
;
; ***************************************************************************************
calculate_enemy_sprite_address
    ldy enemies_sprite,X                            ;
    cpy #$12                                        ;
    bne not_candelabra                              ;
    lda enemies_unpacked_sprite_offset,X            ;
    eor #1                                          ; Make candelabra flicker without moving
    sta enemies_unpacked_sprite_offset,X            ;
not_candelabra
    cpy #21                                         ;
    bne not_monk_in_chapel                          ; if (not monk) then branch
    lda player_room                                 ;
    cmp #29                                         ;
    bne not_monk_in_chapel                          ; if (not in the Chapel) then branch
    lda #4
    bne +
not_monk_in_chapel
    lda enemy_sprites_frames,Y                      ;
    bpl +                                           ;
    asl                                             ; if (top bit set, i.e. sprite is reverse also) then twice as many frames
+
    sta sprite_frames                               ;
    lda enemies_direction,X                         ;
    bne enemy_moving_vertically                     ;

    ; Enemy moving horizontally                     ; For horizontally moving enemies,
    lda enemies_x,X                                 ; use the horizontal position to calculate frame
    and #7                                          ;
    lsr                                             ;
    ldy enemies_speed,X                             ;
    bmi calculate_frame                             ;
    clc                                             ;
    adc #4                                          ;
    bpl calculate_frame                             ;
enemy_moving_vertically                             ; For vertically moving enemies,
    lda game_timer                                  ;
    ldy enemies_speed,X                             ;
    bmi skip_inversion4                             ;
    eor #$ff                                        ;
    clc                                             ;
    adc #1                                          ;
skip_inversion4
    ldy enemies_sprite,X                            ;
    cpy #10                                         ; razor blades spin fast
    beq +                                           ;
    lsr                                             ; slow non-razor blades down
+
    and #7                                          ;
calculate_frame
    dec sprite_frames                               ;
    and sprite_frames                               ;
    clc                                             ;
    adc enemies_unpacked_sprite_offset,X            ;
    lsr                                             ;
    ror sprite_frames                               ;
    lsr                                             ;
    ror sprite_frames                               ;
    sta plot_sprite_address_high                    ;
    lda sprite_frames                               ;
    and #$c0                                        ;
    clc                                             ;
    adc #<unpacked_sprites                          ;
    sta plot_sprite_address_low                     ;
    lda plot_sprite_address_high                    ;
    adc #>unpacked_sprites                          ;
    sta plot_sprite_address_high                    ;

    ldy enemies_colour,X                            ;
    lda colour_mask_values,Y                        ;
    sta sprite_colour                               ;
    txa                                             ;
    tay                                             ;
    ldx enemies_y,Y                                 ;
    rts                                             ;

; ***************************************************************************************
move_enemy
    lda enemy_to_consider2                          ;
    ldy enemies_direction,X                         ;
    beq enemy_moving_horizontally1                  ;
    clc                                             ;
    adc #9                                          ; Use vertical variables for vertically moving enemies
enemy_moving_horizontally1
    tay                                             ;
    lda enemies_x,Y                                 ;
    sta temp_old_position                           ;
    lda enemies_speed,X                             ;
    sta temp_test_for_direction                     ;
    sta enemies_previous_speed,X                    ;
    clc                                             ;
    adc enemies_x,Y                                 ;
    sta enemies_x,Y                                 ;
check_extents
    cmp enemies_minimum,X                           ;
    bcc make_speed_positive                         ; if (new pos < minimum) then branch
    beq flip_direction                              ;
    cmp enemies_maximum,X                           ;
    bcc leave30                                     ; if (new pos < maximum) then branch (leave)

make_speed_negative
    bit temp_test_for_direction                     ;
    bmi leave30                                     ; if (moving in the correct direction) then branch (leave)

    ; restore previous position, flip direction and try again
    lda temp_old_position                           ;
    sta enemies_x,Y                                 ; restore old position
    jsr flip_direction                              ;
    lda enemies_maximum,X                           ; check that the minimum and maximum are not the same
    cmp enemies_minimum,X                           ;
    bne move_enemy                                  ; try again in the new direction
leave30
    rts                                             ;

flip_direction
    lda enemies_speed,X                             ;
    eor #$ff                                        ;
    sec                                             ;
    adc #0                                          ;
    sta enemies_speed,X                             ;
    rts                                             ;

make_speed_positive
    bit temp_test_for_direction                     ;
    bpl leave30                                     ; if (moving in the correct direction) then branch (leave)
    lda enemies_minimum,X                           ;
    sta enemies_x,Y                                 ; set position to the minimum
    jmp flip_direction                              ;


; ***************************************************************************************
plot_or_unplot_player_sprite
    ldy plot_sprite_address_low                     ;
    sty sprite_address_for_restore_lda_low          ;
    sty sprite_address_for_copy_and_low             ;
    sty sprite_address_for_copy_ora_low             ;
    ldy plot_sprite_address_high                    ;
    sty sprite_address_for_restore_lda_high         ;
    sty sprite_address_for_copy_and_high            ;
    sty sprite_address_for_copy_ora_high            ;
plot_or_unplot_previous_player_sprite
    jsr calculate_screen_address                    ;
    ldx #$3f                                        ;
plot_player_sprite_outer_loop
    ldy #$18                                        ;
    sec                                             ;
plot_player_sprite_loop
plot_player_sprite_mode
    bcc restore_background                          ; also BCS restore_background [self modifying code]

copy_background                                     ; If BCC, copy screen memory to buffer
    lda (screen_address_low),Y                      ;
sprite_address_for_copy_and_low = * + 1
sprite_address_for_copy_and_high = * + 2
    and $1111,X                                     ; actually AND sprite_address,X
    sta player_background_buffer,X                  ;
    lda (screen_address_low),Y                      ;
sprite_address_for_copy_ora_low = * + 1
sprite_address_for_copy_ora_high = * + 2
    ora $1111,X                                     ; actually ORA sprite_address,X
                                                    ; adding player sprite
    sta (screen_address_low),Y                      ;
    bcs continue_with_next_byte                     ;
restore_background                                  ; If BCS, copy buffer to screen memory
sprite_address_for_restore_lda_low = * + 1
sprite_address_for_restore_lda_high = * + 2
    lda $1111,X                                     ; actually LDA sprite_address,X
    eor #$ff                                        ;
    and (screen_address_low),Y                      ; using player sprite as mask
    ora player_background_buffer,X                  ;
    sta (screen_address_low),Y                      ;
continue_with_next_byte
    dex                                             ;
    tya                                             ;
    sbc #8                                          ;
    tay                                             ;
    bcs plot_player_sprite_loop                     ;
    txa                                             ;
    bmi leave12                                     ;
    inc screen_address_low                          ;
    lda screen_address_low                          ;
    bit seven                                       ;
    bne plot_player_sprite_outer_loop               ;
    sec                                             ;
    sbc #8                                          ;
    sta screen_address_low                          ;
    inc screen_address_high                         ;
    inc screen_address_high                         ;
    bpl plot_player_sprite_outer_loop               ;
leave12
    rts                                             ;

;
; Keys
;
keyCodeZ                           = $61
keyCodeX                           = $42
keyCodeReturn                      = $49
keyCodeSpace                       = $62
keyCodeS                           = $51
keyCodeQ                           = $10
keyCodeEscape                      = $70
keyCodeShift                       = $00
keyCodeColon                       = $48

; ***************************************************************************************
keysToTest
    !byte keyCodeZ
    !byte keyCodeX
    !byte keyCodeReturn
    !byte keyCodeSpace
    !byte keyCodeS
    !byte keyCodeQ
    !byte keyCodeEscape
    !byte keyCodeShift
keysToTestEnd

; ***************************************************************************************
; Read keyboard, avoiding the time when the music may update
read_keys
    lda irq_counter                                 ;
    cmp #12*3                                       ;
    bcs read_keys                                   ;

    lda #3                                          ;
    sta systemVIARegisterB                          ; Disable keyboard auto scanning
    lda #$7F                                        ;
    sta systemVIADataDirectionRegisterA             ; Set System VIA Port A to output on bits 0-6, and input on bit 7

    ldx #keysToTestEnd - keysToTest - 1             ;
readKeyLoop
;    lda keyStates,X                                 ; Remember previous key states
;    sta previousKeyStates,X                         ; Remember previous key states
    lda keysToTest,X                                ;
    sta systemVIARegisterANoHandshake               ; Say which key we are interested in (write to System VIA Port A)
    lda systemVIARegisterANoHandshake               ; Read key state (read from System VIA Port A)
    and #$80                                        ; just the top bit reflects key state
                                                    ; 0 means up, $80 means down
    beq +                                           ;
    lda #$ff                                        ;
+
    sta keyStates,X                                 ; Record results
;    lda previousKeyStates,X                         ; Remember previous key states
;    eor #$ff                                        ; Remember previous key states
;    and keyStates,X                                 ; Remember previous key states
;    sta justPressedKeyStates,X                      ; Remember previous key states
    dex                                             ;
    bpl readKeyLoop                                 ;

    lda #$ff                                        ;
    sta systemVIADataDirectionRegisterA             ; Set System VIA Port A to output on all bits 0-7
    lda #11                                         ; Enable keyboard auto scanning
    sta systemVIARegisterB                          ;
    rts                                             ;

; ***************************************************************************************
handle_player_keys
    lda player_conveyor_direction                   ;
    beq player_not_conveyed                         ;
    lda #0                                          ;
    sta player_conveyor_direction                   ; Mark player as not being conveyed
    beq check_for_jump                              ;
player_not_conveyed
    lda keyStateZ
    and #$fe                                        ; 'Z'
    sta player_horizontal_speed                     ;
    lda keyStateX                                   ; 'X'
    and #2                                          ;
    clc                                             ;
    adc player_horizontal_speed                     ;
    sta player_horizontal_speed                     ;
check_for_jump
    lda keyStateReturn                              ; 'Return'
    sta player_started_jump                         ;
leave28
    rts                                             ;

; ***************************************************************************************
update_animated_scenery
    lda game_timer                                  ;
    and #3                                          ;
    bne leave28                                     ;
    ldy #255                                        ;
    lda player_room                                 ;
    cmp #28                                         ;
    bne +                                           ; if (not first landing) then branch
    ldy #122                                        ;
    sty animated_sprite_to_draw                     ;
    ldy #0                                          ;
+
    cmp #10                                         ; if (not under the roof) then branch
    bne +                                           ;
    ldy #185                                        ;
    sty animated_sprite_to_draw                     ;
    ldy #1                                          ;
+
    cmp #2                                          ; if (not nomen luni) then branch
    bne +                                           ;
    ldy #211                                        ;
    sty animated_sprite_to_draw                     ;
    ldy #2                                          ;
+
    cmp #58                                         ;
    bne +                                           ;
    ldy #92                                         ;
    sty animated_sprite_to_draw                     ;
    ldy #3                                          ;
+
    tya                                             ;
    bmi leave28                                     ;
    jmp animate_scenery                             ;

; ***************************************************************************************
animate_scenery
    lda start_of_animation_offset + 1,Y             ;
    sta final_strip_offset                          ;
    lda start_of_animation_offset,Y                 ;
    tay                                             ;
-
    sty anim_index                                  ;
    lda first_landing_scenery,Y                     ;
    sta tile_x                                      ;
    lda first_landing_scenery + 1,Y                 ;
    sta tile_y                                      ;
    lda first_landing_scenery + 2,Y                 ;
    sta scenery_len                                 ;
scenery_strip_loop
    lda game_timer                                  ;
    and #4                                          ;
    beq +
    ldx #2                                          ; colours to use
    ldy #1                                          ;
    bne ++
+
    ldx #1                                          ; opposite colours to use
    ldy #2                                          ;
++
animated_sprite_to_draw = * + 1
    lda #$ff                                        ; sprite to draw
    jsr plot_background_sprite                      ;
    lda scenery_len                                 ;
    bmi vertical
    inc tile_x                                      ;
next_tile
    dec scenery_len                                 ;
    lda scenery_len                                 ;
    and #$7f                                        ;
    bne scenery_strip_loop                          ;
    ldy anim_index                                  ;
    iny                                             ;
    iny                                             ;
    iny                                             ;
    cpy final_strip_offset                          ;
    bcc -                                           ;
    rts                                             ;

vertical
    dec tile_y                                      ;
    jmp next_tile                                   ;

; ***************************************************************************************
start_of_animation_offset
    !byte 0
    !byte under_the_roof_scenery - first_landing_scenery
    !byte nomen_luni_scenery - first_landing_scenery
    !byte entrance_to_hades - first_landing_scenery
    !byte end_of_scenery - first_landing_scenery

first_landing_scenery
    !byte 29,12,$80 + 5
    !byte 28,11,3
under_the_roof_scenery
    !byte 12,15,18
    !byte 16,14,1
    !byte 19,14,4
    !byte 25,14,1
    !byte 15,13,3
    !byte 19,13,4
    !byte 24,13,3
    !byte 20,12,2
nomen_luni_scenery
    !byte 18,10, 6
    !byte 18, 9, 6
    !byte 20, 8, $80 + 7
    !byte 21, 8, $80 + 7
    !byte 30, 6, 2
    !byte 29, 5, 3
    !byte 26, 4, 6
    !byte 25, 3, 1
    !byte 31, 3, $80 + 4
    !byte 30, 2, 1
    !byte 12, 1, 18
    !byte 12, 0, 18
entrance_to_hades
    !byte 13, 13, 3
    !byte 18, 13, $80 + 5
    !byte 20, 13, 4
    !byte 13, 12, $80 + 4
    !byte 16, 12, $80 + 3
    !byte 20, 12, $80 + 4
    !byte 21, 11, 2
    !byte 14, 9, 2
    !byte 21, 9, 3
    !byte  7, 6, $80 + 5
    !byte 11, 6, $80 + 5
    !byte 14, 6, 1
    !byte 17, 6, $80 + 5
    !byte 18, 6, 1
    !byte 21, 6, 3
    !byte 26, 6, 1
    !byte 29, 6, $80 + 5
    !byte  8, 5, 1
    !byte 10, 5, 1
    !byte 13, 5, $80 + 3
    !byte 15, 5, $80 + 3
    !byte 19, 5, 1
    !byte 22, 5, $80 + 4
    !byte 25, 5, $80 + 4
    !byte 27, 5, $80 + 4
    !byte  9, 4, 1
    !byte 18, 4, 1
    !byte 19, 3, $80 + 2
    !byte 26, 3, 1
    !byte 14, 2, 1
    !byte 30, 2, 2
end_of_scenery

; ***************************************************************************************
update_game
    jsr read_keys                                   ;
    lda player_rope_pixel                           ;
    bne consider_keys                               ; player can jump when on the rope
    lda player_is_jumping                           ;
    ora player_jump_timer                           ;
    bne skip_keys                                   ; Player can't start jump or move when jumping
consider_keys
    jsr handle_player_keys                          ;
skip_keys
    jsr handle_rope_time_and_events                 ;
    jsr handle_player_jumping                       ;
    lda player_horizontal_speed                     ;
    beq player_isnt_moving                          ;
    cmp player_speed                                ;
    beq player_already_moving                       ; Is the player already facing in direction of move?
    sta player_speed                                ; If not, make them face that direction, but don't move
    bne player_isnt_moving                          ;
player_already_moving
    clc                                             ;
    adc player_x_in_enemies                         ;
    sta player_x_in_enemies                         ;
player_isnt_moving
    jsr check_player_move_for_walls                 ;
    beq player_can_move                             ;
    lda player_x_in_enemies                         ;
    sec                                             ;
    sbc player_horizontal_speed                     ;
    sta player_x_in_enemies                         ;
player_can_move
    ldx #0                                          ; player
    jsr calculate_tile_address_for_enemy_X          ;
    jsr see_if_player_should_start_jump             ;
    jsr check_player_jump_for_walls                 ;
    lda player_jump_timer                           ;
    cmp #7                                          ;
    bcs player_falling_after_jump                   ;
    lda player_on_slope                             ;
    beq not_jumping_along_slope                     ;
    lda player_horizontal_speed                     ;
    beq not_jumping_along_slope                     ;
    ldx slope_direction                             ;
    cmp slope_speeds,X                              ;
    beq not_jumping_along_slope                     ;
    inc enemies_y                                   ; Make player move down to follow slope
    inc player_y_in_enemies                         ;
not_jumping_along_slope
    ldx #0                                          ; player
    stx player_on_slope                             ;
    jsr calculate_tile_address_for_enemy_X          ;
    jsr consider_tiles_under_player                 ;
    ldx slope_direction                             ;
    lda player_x_in_enemies                         ;
    and #7                                          ;
    cmp slope_checks,X                              ;
    bne not_slope1                                  ;
    ldy slope_values,X                              ;
    lda (tile_address_low1),Y                       ;
    cmp #3                                          ; SLOPE
    bne not_slope1                                  ;
    lda player_horizontal_speed                     ;
    cmp slope_speeds,X                              ;
    bne not_slope1                                  ;
    lda player_y_in_enemies                         ;
    sec                                             ;
    sbc #2                                          ; If player moving up slope, move them upwards
    sta player_y_in_enemies                         ;
player_falling_after_jump
not_slope1
    jsr check_for_q_and_s_keys                      ;
    jsr update_conveyor                             ;
    jsr update_enemies                              ;
    ldx #0                                          ; player
    jsr calculate_tile_address_for_enemy_X          ;
    jsr mark_enemies_that_overlap_player            ;
    jsr update_animated_scenery                     ;

-
    lda vsync_counter                               ; wait most of the frames
    cmp #2                                          ;
    bcc -

    jsr plot_enemies                                ; draw enemies that don't overlap player

    ; wait one more frame
-
    lda vsync_counter                               ;
    cmp #3                                          ;
    bcc -                                           ;
    lda #0                                          ;
    sta vsync_counter                               ;

    ; restore cached background to screen from cache, thereby unplotting the player
    lda #$b0                                        ; 'BCS' opcode ; Set to restore background
    sta plot_player_sprite_mode                     ;
    dec player_not_plotted                          ;
    beq skip_unplot                                 ;

    ; unplot player
    lda player_x                                    ;
    ldx player_y                                    ;
    jsr plot_or_unplot_previous_player_sprite       ; Unplot player

skip_unplot
    jsr plot_enemies                                ; draw enemies that overlap with the player tiles
                                                    ; this is done separately from the other enemies
                                                    ; so we minimise the time between unplot
                                                    ; and plot of the player, while still capturing
                                                    ; collision information with the enemies that
                                                    ; we can collide with.
    ; Update arrows and room items
    jsr update_arrows
    jsr plot_room_items
    jsr plot_room_items
    jsr plot_room_items
    jsr plot_room_items
    jsr plot_room_items

    ; copy background tiles at player position on screen to cache, and plot player
    lda #$90                                        ; 'BCC' opcode ; Set to copy background
    sta plot_player_sprite_mode                     ;
    dec player_not_plotted                          ;
    bpl skip_plot                                   ;
    ldx #0                                          ; get sprite address of player
    jsr calculate_enemy_sprite_address              ;
    lda player_x_in_enemies                         ;
    and #$f8                                        ;
    sta player_x                                    ;
    stx player_y                                    ;
    ldx player_y                                    ;
    bmi skip_plot                                   ;
    jsr plot_or_unplot_player_sprite                ; Copy screen background to cache, plot player

skip_plot

    ldx #0                                          ; plot and unplot player as normal
    stx player_not_plotted                          ;

    ; check for collisions with enemies, arrows, items
    jsr calculate_tile_address_for_enemy_X          ;
    jsr check_for_player_touching_tiles             ;

    jsr check_for_player_leaving_room               ;
    lda player_killed                               ;
    beq leave13                                     ;

    ; death
    ldx #4                                          ; player dying sounds
    jsr start_sound_x                               ;
    ldx #5                                          ;
    jsr start_sound_x                               ;

    dec player_lives                                ;
    lda entry_horizontal_speed                      ; Set player back to where they entered the room
    sta player_horizontal_speed                     ;
    lda entry_jump_timer                            ;
    sta player_jump_timer                           ;
    lda entry_x                                     ;
    sta player_x_in_enemies                         ;
    lda entry_y                                     ;
    sta player_y_in_enemies                         ;
    lda entry_is_jumping                            ;
    sta player_is_jumping                           ;
    jsr remove_collected_items_from_room_data       ;
leave13
    rts                                             ;

; ***************************************************************************************
initialise_enemies
    ldx #3                                          ;
    jsr get_x_bits_of_room_data                     ; Get three bits of room data for number of enemies
    sta enemies_on_screen                           ;
    tay                                             ;
    beq no_enemies                                  ;
initialise_enemies_loop                             ; For each enemy,
    ldx #6                                          ; Get six bits of room data for sprite
    jsr get_x_bits_of_room_data                     ;
    sta enemies_sprite,Y                            ;
    ldx #5                                          ; Get five bits of room data for x position
    jsr get_x_bits_of_room_data_multiplied_by_eight ;
    sta enemies_x,Y                                 ;
    ldx #4                                          ; Get four bits of room data for y position
    jsr get_x_bits_of_room_data_multiplied_by_eight ;
    sta enemies_y,Y                                 ;
    ldx #5                                          ; Get five bits of room data for minimum position
    jsr get_x_bits_of_room_data_multiplied_by_eight ;
    sta enemies_minimum,Y                           ;
    ldx #5                                          ; Get five bits of room data for maximum position
    jsr get_x_bits_of_room_data_multiplied_by_eight ;
    sta enemies_maximum,Y                           ;
    ldx #1                                          ; Get one bit of room data for direction
    jsr get_x_bits_of_room_data                     ; (0 = horizontal, 1 = vertical)
    asl                                             ;
    beq not_zero                                    ;
    lda #$ff                                        ;
not_zero
    sta enemies_direction,Y                         ;
    ldx #1                                          ; Get one bit of room data for direction
    jsr get_x_bits_of_room_data                     ; (0 = left/up, 1=right/down)
    sta invert                                      ;
    ldx #3                                          ; Get three bits of room data for speed
    jsr get_x_bits_of_room_data                     ;
    sta enemies_speed,Y                             ;
    ldx invert                                      ;
    bne skip_inversion5                             ;
    eor #$ff                                        ;
    clc                                             ;
    adc #1                                          ;
    sta enemies_speed,Y                             ;
skip_inversion5
    ldx #2                                          ; Get two bits of room data for colour
    jsr get_x_bits_of_room_data                     ;
    sta enemies_colour,Y                            ;
    lda #0                                          ;
    sta enemies_previous_speed,Y                    ;
    sta enemies_previous_tile_address_low,Y         ;
    dey                                             ;
    bne initialise_enemies_loop                     ;
no_enemies
    jmp unpack_enemy_sprites                        ;

; ***************************************************************************************
get_x_bits_of_room_data_multiplied_by_eight
    jsr get_x_bits_of_room_data                     ;
    asl                                             ;
    asl                                             ;
    asl                                             ;
    rts                                             ;

; ***************************************************************************************
wipe_tile_table
    ldy #0                                          ;
    lda #$80                                        ;
wipe_tile_table_loop
    sta tile_table,Y                                ;
    sta tile_table + $100,Y                         ;
    iny                                             ;
    bne wipe_tile_table_loop                        ;
    rts                                             ;

; ***************************************************************************************
calculate_tile_address_for_enemy_X
    lda #0                                          ;
    sta tile_address_high1                          ;
    lda enemies_y,X                                 ;
    sec                                             ;
    sbc #8                                          ;
    bcs +                                           ;
    dec tile_address_high1                          ;
+
    asl                                             ;
    asl                                             ;
    rol tile_address_high1                          ;
    and #$e0                                        ;
    sta tmp                                         ;
    lda enemies_x,X                                 ;
    lsr                                             ;
    lsr                                             ;
    lsr                                             ;
    clc                                             ;
    adc tmp                                         ;
    clc                                             ;
    adc #<tile_table                                ;
    sta tile_address_low1                           ;

    lda tile_address_high1                          ;
    adc #>tile_table                                ;
    sta tile_address_high1                          ;

    ; return with the low byte in the accumulator
    lda tile_address_low1                           ;
    rts                                             ;

cycle_item_colours
    !byte 1,2,3,1,2,3,1,2,3,1,2,3

; ***************************************************************************************
free_before_nmi = $0d00 - *

!if (* > $0d00) {
    !error "RTI not in correct position at $0d00", *
}
    * = $0d00
    rti

; ***************************************************************************************
set_tile_table_for_background
    ldy #0                                          ;
    sty tile_address_high1                          ;
    lda #$0f                                        ;
    sec                                             ;
    sbc tile_y                                      ;
    asl                                             ;
    asl                                             ; tile_address = tile_table + (15-tile_y) * 32 + tile_x
    asl                                             ;
    asl                                             ;
    asl                                             ;
    rol tile_address_high1                          ;
    adc tile_x                                      ;
    bcc +                                           ;
    inc tile_address_high1                          ;
    clc                                             ;
+
    adc #<tile_table                                ;
    sta tile_address_low1                           ;
    lda tile_address_high1                          ;
    adc #>tile_table                                ;
    sta tile_address_high1                          ;

    lda tile_type                                   ;
    adc #1                                          ;
    cmp #5                                          ;
    beq not_item                                    ; if (DEADLY) then store that
    cmp #6                                          ; store (tile type + 1) in tile_table for PLATFORM, WALL, SLOPE, CONVEYOR
    bcc set_tile_table                              ;
    beq scenery                                     ; if (SCENERY) skip else it's ITEM
    inc item_number                                 ; If this tile is an item, store its details
    ldx item_number                                 ;
    lda screen_address_low                          ;
    sta items_screen_address_low,X                  ;
    lda screen_address_high                         ;
    sta items_screen_address_high,X                 ;
    lda tile_address_low1                           ;
    sta items_tile_address_low,X                    ;
    lda tile_address_high1                          ;
    sta items_tile_address_high,X                   ;
    txa                                             ;
    ora #$10                                        ; Mark as item
not_item
    ora #$c0                                        ; Mark as not enemy, nor background
set_tile_table
    ldy #0                                          ;
    sta (tile_address_low1),Y                       ;
scenery
    rts                                             ;

; ***************************************************************************************
consider_tiles_under_player                         ; There are two tiles beneath the player's feet ; one
    ldx slope_direction                             ; which may have a slope, and one which does not
    ldy slope_tile_offsets,X                        ;
    lda (tile_address_low1),Y                       ; Consider tile beneath player's feet (with slope)
    beq is_space                                    ;
    bpl isnt_space                                  ;
is_space
    inx                                             ;
    ldy slope_tile_offsets,X                        ;
    lda (tile_address_low1),Y                       ; Consider tile beneath player's feet (without slope)
    beq player_in_midair                            ; If both are empty, the player falls
    bmi player_in_midair                            ;
isnt_space
    cmp #3                                          ; SLOPE
    bne not_slope2                                  ;
    jsr consider_slope_effect                       ; If one is a slope, see how that affects the player
    beq player_in_midair                            ;
    bpl check_for_conveyor                          ;
not_slope2
    sta tile2                                       ;
    lda player_y_in_enemies                         ;
    and #7                                          ;
    cmp #3                                          ;
    bcs player_in_midair                            ;
    lda tile2                                       ;
check_for_conveyor
    cmp #4                                          ; CONVEYOR
    bne not_conveyor                                ;
    jsr consider_conveyor_effect                    ;
not_conveyor
    lda player_is_jumping                           ;
    beq align_player_with_tile                      ;
    lda player_entered_room_falling_too_far         ;
    bne player_fell_too_far                         ;
    lda player_y_in_enemies                         ;
    sec                                             ;
    sbc where_player_fell_from                      ;
    bmi player_didnt_fall_too_far                   ;
    cmp #$21                                        ; Has the player fallen more than four tiles?
    bcc player_didnt_fall_too_far                   ;
player_fell_too_far
    inc player_killed                               ; Kill the player if they hit after falling too far
player_didnt_fall_too_far
    lda #0                                          ;
    sta player_jump_timer                           ;
    sta player_is_jumping                           ;
align_player_with_tile
    lda player_on_slope                             ;
    bne leave14                                     ;
    lda player_y_in_enemies                         ;
    and #$f8                                        ;
    sta player_y_in_enemies                         ;
leave14
    rts                                             ;
player_in_midair
    lda player_jump_timer                           ;
    bne leave15                                     ;
    lda player_is_jumping                           ;
    bne skip_noting_fall                            ;
    lda player_y_in_enemies                         ;
    sta where_player_fell_from                      ;
    sta player_is_jumping                           ;
skip_noting_fall
    lda #0                                          ;
    sta player_horizontal_speed                     ;
    lda player_y_in_enemies                         ;
    clc                                             ;
    adc #4                                          ;
    sta player_y_in_enemies                         ;
leave15
    rts                                             ;

; ***************************************************************************************
update_enemies
    lda enemies_on_screen                           ;
    beq leave16                                     ;
    sta enemy_to_consider2                          ;
update_enemies_loop
    ldx enemy_to_consider2                          ;
    jsr move_enemy                                  ;
    lda #1                                          ;
    sta enemies_need_replot,X                       ;
    lda #0                                          ;
    sta enemy_has_moved,X                           ;
    jsr calculate_tile_address_for_enemy_X          ;
    ldy enemies_previous_tile_address_low,X         ;
    sty previous_tile_address_low                   ;
    cmp enemies_previous_tile_address_low,X         ;
    beq consider_next_enemy2                        ;
    inc enemy_has_moved,X                           ;
    sta enemies_previous_tile_address_low,X         ;
    txa                                             ;
    ora #$80                                        ;
    ldy #$20                                        ; Mark enemy in four tiles
    sta (tile_address_low1),Y                       ;
    iny                                             ;
    sta (tile_address_low1),Y                       ;
    ldy #$40                                        ;
    sta (tile_address_low1),Y                       ;
    iny                                             ;
    sta (tile_address_low1),Y                       ;
    lda previous_tile_address_low                   ;
    beq consider_next_enemy2                        ;
    lda enemies_previous_speed,X                    ;
    beq consider_next_enemy2                        ; If the enemy is moving,
    asl                                             ;
    lda enemies_direction,X                         ;
    and #2                                          ;
    adc #0                                          ;
    tax                                             ;
    ldy direction_tile_offsets_one,X                ;
    lda space_tile                                  ;
    sta (tile_address_low1),Y                       ; Remove enemy from previously occupied tiles
    ldy direction_tile_offsets_two,X                ;
    sta (tile_address_low1),Y                       ;
    ldx enemy_to_consider2                          ;
consider_next_enemy2
    dec enemy_to_consider2                          ;
    bne update_enemies_loop                         ;
leave16
    rts                                             ;

; ***************************************************************************************
wipe_space_vacated_by_enemy
    ldx enemy_to_consider2                          ;
    lda enemy_has_moved,X                           ;
    beq leave17                                     ;
    lda enemies_direction,X                         ;
    bne leave17                                     ; Leave if this enemy is moving vertically.
    lda #8                                          ;
    sta sprite_width                                ; Set sprite size to be 16x2 pixels
    lda #$1f                                        ;
    sta sprite_size_in_bytes                        ;
    lda #$f8                                        ;
    ldy enemies_previous_speed,X                    ;
    bpl enemy_moving_right                          ;
enemy_moving_left
    lda #$0c                                        ;
enemy_moving_right
    clc                                             ;
    adc enemies_x,X                                 ;
    sta enemy_x                                     ;
    lda #<space_sprite                              ;
    sta plot_sprite_address_low                     ;
    lda #>space_sprite                              ;
    sta plot_sprite_address_high                    ;
    lda enemies_y,X                                 ;
    tax                                             ;
    lda enemy_x                                     ;
    jsr plot_sprite                                 ;
    lda #$18                                        ; Restore sprite size to 16x16 pixels
    sta sprite_width                                ;
    lda #$3f                                        ;
    sta sprite_size_in_bytes                        ;
    ldx enemy_to_consider2                          ;
leave17
    rts                                             ;

; ***************************************************************************************
direction_tile_offsets_one
    !byte $1f, $22, $00, $60

direction_tile_offsets_two
    !byte $3f, $42, $01, $61

; ***************************************************************************************
plot_enemy
    lda enemies_direction,Y                         ;
    beq enemy_moving_horizontally2                  ;

    ; moving vertically
    lda enemies_previous_speed,Y                    ;
    bmi enemy_moving_up                             ;
enemy_moving_down                                   ; If this enemy is moving down,
    ldx enemies_sprite,Y                            ;
    cpx #$21                                        ;
    beq enemy_is_skull_mouth                        ; The skull mouth will be overwritten by the skull top
    sta previous_speed                              ; Otherwise,
    asl                                             ;
    asl                                             ;
    sbc #0                                          ;
    sta sprite_size_in_bytes                        ; Set sprite to be section previously occupied
    lda plot_sprite_address_low                     ;
    sta previous_sprite_address_low                 ;
    lda #<space_sprite                              ;
    sta plot_sprite_address_low                     ;
    lda plot_sprite_address_high                    ;
    sta previous_sprite_address_high                ;
    lda #>space_sprite                              ;
    sta plot_sprite_address_high                    ;
    lda enemies_y,Y                                 ;
    sec                                             ;
    sbc previous_speed                              ;
    tax                                             ;
    lda enemies_x,Y                                 ;
    jsr plot_sprite                                 ; Wipe previous position of sprite
    lda previous_sprite_address_high                ;
    sta plot_sprite_address_high                        ;
    lda #$3f                                        ; Set sprite to be 16x16 pixels
    sta sprite_size_in_bytes                        ;
    lda previous_sprite_address_low                 ;
    sta plot_sprite_address_low                     ; Plot sprite
    jmp into_plot_sprite_with_skip                  ;

enemy_is_skull_mouth
    ldx enemies_y,Y                                 ;
enemy_moving_horizontally2
    lda enemies_x,Y                                 ;
    and #$f8                                        ;
    jmp plot_sprite                                 ;

enemy_moving_up                                     ; If the enemy is moving up,
    lda enemies_x,Y                                 ;
    jsr plot_sprite                                 ; Plot sprite
    lda #<space_sprite                              ;
    sta plot_sprite_address_low                     ;
    ldy enemy_to_consider2                          ;
    lda #>space_sprite                              ;
    sta plot_sprite_address_high                    ;
    lda enemies_previous_speed,Y                    ;
    eor #$ff                                        ;
    clc                                             ;
    adc #1                                          ;
    asl                                             ;
    asl                                             ;
    sbc #0                                          ;
    sta sprite_size_in_bytes                        ; Set sprite to be section previously occupied
    jsr into_plot_sprite_with_skip                  ; Wipe previous position of sprite
    lda #$3f                                        ;
    sta sprite_size_in_bytes                        ; Restore sprite to 16x16 pixels
    rts                                             ;

; ***************************************************************************************
into_plot_sprite_with_skip
    ldx sprite_size_in_bytes                        ;
    jmp plot_sprite_skipping_first_column           ;

check_player_move_for_walls
    ldx #0                                          ; player
    stx walls                                       ;
    jsr calculate_tile_address_for_enemy_X          ;
    ldy #$20                                        ;
    lda player_horizontal_speed                     ;
    beq leave_with_result                           ; No walls hit if player not moving
    bmi player_moving_left                          ;
player_moving_right
    iny                                             ;
player_moving_left
    jsr check_tile_for_wall                         ; Check top of player
    jsr check_tile_for_wall                         ; Check middle/bottom of player
    lda player_y_in_enemies                         ;
    and #7                                          ;
    beq leave_with_result                           ;
    jsr check_tile_for_wall                         ; Check bottom of player if not aligned
leave_with_result
    lda walls                                       ;
    rts                                             ;

; ***************************************************************************************
check_tile_for_wall
    lda (tile_address_low1),Y                       ;
    cmp #2                                          ; WALL
    bne not_wall                                    ;
    inc walls                                       ;
not_wall
    tya                                             ;
    clc                                             ;
    adc #$20                                        ;
    tay                                             ;
    rts                                             ;

; ***************************************************************************************
see_if_player_should_start_jump
    lda player_started_jump                         ;
    beq leave18                                     ;
    inc player_is_jumping                           ;
    lda #$12                                        ;
    sta player_jump_timer                           ;
    inc player_started_jump                         ;
    lda player_y_in_enemies                         ;
    sec                                             ;
    sbc #8                                          ;
    sta where_player_fell_from                      ;
    jsr check_player_jump_for_walls                 ;
    beq leave18                                     ;
    ldx #0                                          ;
    jsr start_sound_x                               ; Player jump sound
    jsr handle_player_jumping                       ;
leave18
    rts                                             ;

; ***************************************************************************************
check_player_jump_for_walls
    lda player_y_in_enemies                         ;
    and #7                                          ;
    bne leave19                                     ;
    ldy #0                                          ; Consider tile above player's left
    lda (tile_address_low1),Y                       ;
    eor #2                                          ; WALL
    beq cant_jump                                   ;
    iny                                             ; Consider tile above player's right
    lda (tile_address_low1),Y                       ;
    eor #2                                          ; WALL
    bne leave19                                     ;
cant_jump
    jsr handle_player_jumping                       ; Conclude any existing jump
    lda #0                                          ; If either is a wall, player can't jump
    sta player_jump_timer                           ;
leave19
    rts                                             ;

; ***************************************************************************************
check_for_player_touching_tiles
    lda player_y_in_enemies                         ;
    and #7                                          ;
    eor #7                                          ;
    sta rows_to_check                               ;
    ldy #$20                                        ; Consider tile at top left of player
    lda #$3d                                        ;
    jsr check_for_player_touching_tile              ;
    ldy #$21                                        ; Consider tile at top right of player
    lda #$3f                                        ;
    jmp check_for_player_touching_tile              ;

; ***************************************************************************************
check_for_player_touching_tile
    sta buffer_offset                               ;
    ldx rows_to_check                               ;
    jsr check_rows_of_player_against_tile1          ; Check top of player (aligned to tile boundaries)
    ldx #7                                          ;
    jsr check_rows_of_player_against_tile1          ; Check middle of player
    lda #7                                          ;
    sec                                             ;
    sbc rows_to_check                               ;
    beq leave20                                     ;
    tax                                             ;
    dex                                             ;
    jsr check_rows_of_player_against_tile1          ; Check bottom of player
leave20
    rts                                             ;

; ***************************************************************************************
check_rows_of_player_against_tile1
    tya                                             ;
    clc                                             ;
    adc #$20                                        ;
    sta next_tile_offset                            ; Consider tile immediately below when next called
    lda (tile_address_low1),Y                       ;
    sta tile1                                       ;
    bpl tile_is_background                          ;
    ldy buffer_offset                               ; If this tile is an enemy or an item,
check_rows_of_player_against_tile2                  ; for each row of the player within the tile,
    lda player_background_buffer,Y                  ;
    beq not_part_of_player_left                     ; is there part of the player there?
    jsr player_is_touching_tile                     ; If so, consider the interaction
not_part_of_player_left
    dey                                             ;
    lda player_background_buffer,Y                  ; Check again on right-hand side
    beq not_part_of_player_right                    ;
    jsr player_is_touching_tile                     ;
not_part_of_player_right
    dey                                             ;
    dey                                             ;
    dey                                             ;
    dex                                             ;
    bpl check_rows_of_player_against_tile2          ;
    sty buffer_y                                    ;
    ldy next_tile_offset                            ;
    rts                                             ;
tile_is_background                                  ; If this tile is just background,
    inx                                             ; set things up for the next check
    txa                                             ;
    asl                                             ;
    asl                                             ;
    eor #$ff                                        ;
    sec                                             ;
    adc buffer_offset                               ;
    sta buffer_offset                               ;
    ldy next_y                                      ;
    rts                                             ;

; ***************************************************************************************
player_is_touching_tile
    stx x1                                          ;
    sty y                                           ;
    lda #0                                          ;
    sta player_background_buffer,Y                  ;
    lda tile1                                       ;
    and #$7f                                        ;
    beq tile_is_space                               ;
    cmp #$4e                                        ;
    bcs tile_is_item                                ;
    cmp #2                                          ;
    bne not_bathroom_toilet                         ; Is this the bathroom toilet? (room $15, slot 2)
    lda player_room                                 ;
    cmp #$15                                        ; The Bathroom
    beq leave_with_initial_x_and_y                  ; If so, it isn't deadly.
not_bathroom_toilet
    inc player_killed                               ; Otherwise, kill the player
leave_with_initial_x_and_y
    ldx x1                                          ;
    ldy y                                           ;
    rts                                             ;

tile_is_item                                        ; If the tile is an item,
    and #$0f                                        ;
    tax                                             ;
    lda items_colour,X                              ;
    beq leave_with_initial_x_and_y                  ; has it been collected?
    lda #0                                          ;
    sta items_colour,X                              ; If not, remove it from the screen
    stx item_number                                 ;
    jsr collect_item                                ;
    jmp leave_with_initial_x_and_y                  ;
tile_is_space
    lda room_contains_rope                          ;
    bne leave_with_initial_x_and_y                  ;
    inc player_killed                               ; Player has been hit by an arrow or moving enemy
    bne leave_with_initial_x_and_y                  ; ALWAYS branch

; ***************************************************************************************
plot_room_items
    ldx items_in_room_minus_one                     ;
    bmi leave21                                     ;
    cpx item_number                                 ;
    bcc skip_item                                   ;

    ldx item_number                                 ;
    lda items_screen_address_low,X                  ;
    sta screen_address_low                          ;
    lda items_screen_address_high,X                 ;
    sta screen_address_high                         ;

    ldy items_colour,X                              ;
    beq item_collected1                             ;
    dec items_colour,X                              ;
    bne skip_reset_colour                           ;
    lda #3                                          ;
    sta items_colour,X                              ;
skip_reset_colour
    ldy items_colour,X                              ;
item_collected1
    lda colour_mask_values,Y                        ;
    sta sprite_colour                               ;

    ldy #$0f                                        ; loop counter
plot_item_loop
    lda room_item_sprite,Y                          ;
    and sprite_colour                               ;
    sta (screen_address_low),Y                      ;
    dey                                             ;
    bpl plot_item_loop                              ;

    lda items_tile_address_low,X                    ;
    sta tile_address_low2                           ;
    lda items_tile_address_high,X                   ;
    sta tile_address_high2                          ;
    txa                                             ;
    ora #$e0                                        ;
    ldy #0                                          ;
    sta (tile_address2),Y                           ;
skip_item
    dec item_number                                 ;
    bpl leave21                                     ;
    lda #$0b                                        ; maximum number of items in a room
    sta item_number                                 ;
leave21
    rts                                             ;

; ***************************************************************************************
consider_slope_effect
    ldx slope_direction                             ;
    tya                                             ; Y is a tile offset of tile beneath player with slope
    cmp slope_tile_offsets,X                        ;
    bne leave_with_minus_one                        ;
player_is_climbing_slope
    inc player_on_slope                             ;
    lda player_y_in_enemies                         ;
    and #7                                          ;
    sta player_y_fraction                           ;
    lda player_x_in_enemies                         ;
    and #7                                          ;
    eor slope_climb_eors,X                          ;
    sec                                             ;
    adc slope_climb_adds,X                          ;
    bmi player_not_climbing_slope                   ;
    cmp player_y_fraction                           ;
    bcc player_not_climbing_slope                   ;
    dec enemies_y                                   ; Make player move up to follow slope
    dec player_y_in_enemies                         ;
    bcs leave_with_zero                             ;
player_not_climbing_slope
    clc                                             ;
    adc #4                                          ;
    cmp player_y_fraction                           ;
    bcc leave_with_zero                             ;
    sbc #2                                          ;
    sta player_y_fraction                           ;
    lda player_y_in_enemies                         ;
    and #$f8                                        ;
    ora player_y_fraction                           ;
    sbc #1                                          ;
    sta player_y_in_enemies                         ;
    lda #1                                          ;
    ldx player_room                                 ;
    cpx #$16                                        ; The slopes in "Halfway up the East Wall"
    beq leave_with_four                             ;
    cpx #$1d                                        ; and "The Chapel" are treated as conveyors
    bne leave_with_one                              ;
leave_with_four
    lda #4                                          ; CONVEYOR
leave_with_one
    tax                                             ; 1 = PLATFORM
    rts                                             ;
leave_with_zero
    lda #0                                          ; SPACE
    rts                                             ;
leave_with_minus_one
    lda #$ff                                        ; Treat tile as though not a slope
    rts                                             ;

; ***************************************************************************************
slope_climb_eors
    !byte $ff, $00

slope_climb_adds
    !byte $05, $fe

slope_checks
    !byte $00, $06

slope_values
    !byte $41, $40

slope_speeds
    !byte $02, $fe

slope_tile_offsets
    !byte $61, $60, $61

; ***************************************************************************************
consider_conveyor_effect
    lda player_horizontal_speed                     ; Is the player moving?
    beq start_conveying_player                      ;
    cmp conveyor_direction                          ; If not, or they're moving in the conveyor's direction,
    bne leave22                                     ;
start_conveying_player
    lda conveyor_direction                          ; move them with the conveyor
    sta player_horizontal_speed                     ;
    sta player_conveyor_direction                   ; (preventing them from changing direction)
leave22
    rts                                             ;

; ***************************************************************************************
check_for_player_leaving_room
    ldy #0                                          ;
    lda player_x_in_enemies                         ;
    beq player_at_left_edge_of_room                 ;
    iny                                             ;
    cmp #$f6                                        ;
    beq player_at_right_edge_of_room                ;
    iny                                             ;
    ldx #$68                                        ;
    lda player_y_in_enemies                         ;
    bmi player_at_top_or_bottom_edge_of_room        ;
    iny                                             ;
    ldx #1                                          ;
    cmp #$71                                        ;
    bcc leave23                                     ;
    lda player_is_jumping                           ;
    beq player_at_top_or_bottom_edge_of_room        ;
    lda player_y_in_enemies                         ;
    sec                                             ;
    sbc where_player_fell_from                      ;
    cmp #$22                                        ;
    bcc player_at_top_or_bottom_edge_of_room        ;
    sta player_entered_room_falling_too_far         ;
    jmp player_at_top_or_bottom_edge_of_room        ;
player_at_right_edge_of_room
    lda #6                                          ; new position on left edge of next screen
store_new_x
    sta player_x_in_enemies                         ;
    jmp change_room                                 ;
player_at_top_or_bottom_edge_of_room
    stx player_y_in_enemies                         ;
    lda #0                                          ;
    sta player_horizontal_speed                     ;
change_room
    lda exit_rooms,Y                                ;
goto_room
    sta player_room                                 ;
    jsr remove_collected_items_from_room_data       ;
    jsr initialise_room                             ;
leave23
    rts                                             ;
player_at_left_edge_of_room
    lda #$f0                                        ; new position on right edge of next screen
    bne store_new_x                                 ; ALWAYs branch

; ***************************************************************************************
initialise_room_items_and_exits
    ldx #4                                          ; Get four bits of room data for number of items in room
    jsr get_x_bits_of_room_data                     ;
    tay                                             ;
    dey                                             ;
    sty items_in_room_minus_one                     ;
    bmi no_items                                    ;
set_items_loop                                      ; For each item,
    ldx #1                                          ; get one bit of room data for its state
    jsr get_x_bits_of_room_data                     ; (0 = collected, 1 = uncollected)
    beq +
    lda cycle_item_colours,Y                        ;
+
    sta items_colour,Y                              ;
    dey                                             ;
    bpl set_items_loop                              ;
no_items
    ldy #0                                          ;
set_exits_loop                                      ; For each of four directions
    ldx #6                                          ; get six bits of room data for the room exited to
    jsr get_x_bits_of_room_data                     ;
    sta exit_rooms,Y                                ;
    iny                                             ;
    cpy #4                                          ;
    bne set_exits_loop                              ;
    ldx #1                                          ; Get one bit of room data for conveyor direction
    jsr get_x_bits_of_room_data                     ; (0 = left, 1 = right)
    asl                                             ;
    asl                                             ;
    sec                                             ;
    sbc #2                                          ;
    sta conveyor_direction                          ;
    ldx #1                                          ; Get one bit of room data for slope direction
    jsr get_x_bits_of_room_data                     ; (0 = /, 1 = \)
    sta slope_direction                             ;
    ldx #1                                          ; Get one bit of room data for rope
    jsr get_x_bits_of_room_data                     ; (1 = room contains rope)
    sta room_contains_rope                          ;
    rts                                             ;

; ***************************************************************************************
remove_collected_items_from_room_data
    ldy #0                                          ;
    ldx items_in_room_minus_one                     ;
    bmi leave24                                     ;
    lda #4                                          ;
    sta bit_for_item                                ;
remove_collected_items_from_room_data_loop
    dec bit_for_item                                ;
    bpl skip_new_byte                               ;
    lda #7                                          ;
    sta bit_for_item                                ;
    iny                                             ;
skip_new_byte
    lda items_colour,X                              ;
    beq item_collected2                             ;
    lda #$ff                                        ;
item_collected2
    sta item_state                                  ;
    stx x2                                          ;
    ldx bit_for_item                                ;
    lda inverse_of_bits,X                           ;
    eor #$ff                                        ;
    and item_state                                  ;
    sta item_state                                  ;
    lda (room_data_address),Y                       ;
    and inverse_of_bits,X                           ;
    ora item_state                                  ;
    sta (room_data_address),Y                       ;
    ldx x2                                          ;
    dex                                             ;
    bpl remove_collected_items_from_room_data_loop  ;
leave24
    rts                                             ;

; ***************************************************************************************
inverse_of_bits
    !byte $7f, $bf, $df, $ef, $f7, $fb, $fd, $fe

; ***************************************************************************************
reset_items
    ldy #$0b                                        ;
    lda #1                                          ;
mark_all_items_as_uncollected_loop
    sta items_colour,Y                              ;
    dey                                             ;
    bpl mark_all_items_as_uncollected_loop          ;
    lda #$3c                                        ;
    sta room                                        ;
reset_items_room_loop
    ldx room                                        ;
    jsr calculate_room_data_address                 ;
    ldx #4                                          ;
    jsr get_x_bits_of_room_data                     ;
    sta items_in_room_minus_one                     ;
    dec items_in_room_minus_one                     ;
    jsr remove_collected_items_from_room_data       ;
    dec room                                        ;
    bne reset_items_room_loop                       ;
    rts                                             ;

; ***************************************************************************************
calculate_room_data_address
    lda #0                                          ;
    sta room_data_offset                            ;
    sta bits_remaining_in_room_data_byte            ;
    lda room_data_address_low_table,X               ;
    sta room_data_address_low                       ;
    lda room_data_address_high_table,X              ;
    sta room_data_address_high                      ;
    rts                                             ;

; ***************************************************************************************
update_conveyor
    lda pages_of_tile_table_remaining_when_finding_conveyor ;
    beq leave25                                     ; Is there a conveyor in this room? If not, leave
    lda game_timer                                  ;
    and #7                                          ;
    tax                                             ;
    lda conveyor_length                             ;
    sta conveyor_sections_remaining_to_update       ;
    lda conveyor_screen_address_low                 ;
    sta screen_address_low                          ;
    lda conveyor_screen_address_high                ;
    sta screen_address_high                         ;
    ldy #0                                          ;
    clc                                             ;
update_conveyor_loop
    lda unpacked_conveyor_sprite,X                  ;
    sta (screen_address_low),Y                      ;
    iny                                             ;
    iny                                             ;
    lda unpacked_conveyor_sprite + 8,X              ;
    sta (screen_address_low),Y                      ;
    tya                                             ;
    adc #6                                          ;
    tay                                             ;
    lda unpacked_conveyor_sprite + 16,X             ;
    sta (screen_address_low),Y                      ;
    iny                                             ;
    iny                                             ;
    lda unpacked_conveyor_sprite + 24,X             ;
    sta (screen_address_low),Y                      ;
    tya                                             ;
    adc #6                                          ;
    tay                                             ;
    bne +                                           ;
    inc screen_address_high                         ;
    clc                                             ;
+
    dec conveyor_sections_remaining_to_update       ;
    bne update_conveyor_loop                        ;
leave25
    rts                                             ;

; ***************************************************************************************
calculate_screen_address_of_conveyor
    ldy #<tile_table                                ;
    sty tile_address_low1                           ;
    lda #>tile_table                                ;
    sta tile_address_high1                          ;
    lda #0                                          ;
    sta temp_high                                   ;
    lda #2                                          ;
    sta pages_of_tile_table_remaining_when_finding_conveyor ;
    ldy #0                                          ;
find_start_of_conveyor_loop
    jsr check_if_tile_is_conveyor                   ;
    bne find_start_of_conveyor_loop                 ;
    sty conveyor_screen_address_low                 ;
    lda temp_high                                   ;
    and #1                                          ;
    asl conveyor_screen_address_low                 ;
    rol                                             ;
    asl conveyor_screen_address_low                 ;
    rol                                             ;
    asl conveyor_screen_address_low                 ;
    rol                                             ;
    asl conveyor_screen_address_low                 ;
    rol                                             ;
    adc #>screen_memory_start                       ;
    sta conveyor_screen_address_high                ;
    ldx #0                                          ;
    inc pages_of_tile_table_remaining_when_finding_conveyor ;
find_end_of_conveyor_loop
    inx                                             ;
    jsr check_if_tile_is_conveyor                   ;
    beq find_end_of_conveyor_loop                   ;
    stx conveyor_length                             ;
    jmp prepare_conveyor_sprites                    ;

check_if_tile_is_conveyor
    iny                                             ;
    bne compare_tile_with_four                      ;
    inc tile_address_high1                          ;
    inc temp_high                                   ;
    dec pages_of_tile_table_remaining_when_finding_conveyor ;
    bne compare_tile_with_four                      ;
    pla                                             ; Leave calculate_screen_address_of_conveyor at end of
    pla                                             ; tile table
    rts                                             ;
compare_tile_with_four
    lda (tile_address_low1),Y                       ;
    cmp #4                                          ; CONVEYOR
    rts                                             ;

; ***************************************************************************************
prepare_conveyor_sprites
    lda background_tiles_sprites + 3                ;
    jsr decompress_background_sprite                ;
    ldx background_tiles_colours_fg + 3             ;
    lda colour_mask_values,X                        ;
    sta conveyor_colour                             ;
    ldx background_tiles_colours_bg + 3             ;
    lda colour_mask_values,X                        ;
    sta conveyor_colour_eor                         ;
    eor conveyor_colour                             ;
    sta conveyor_colour                             ;
    ldy #0                                          ;
    lda conveyor_direction                          ;
    bmi prepare_top_of_left_conveyor                ;
prepare_top_of_right_conveyor
    ldx #0                                          ; Prepare top of conveyor
    jsr prepare_right_conveyor_bytes                ;
    bmi prepare_conveyor_bottom                     ;
prepare_top_of_left_conveyor
    ldx #7                                          ;
    jsr prepare_left_conveyor_bytes                 ;
prepare_conveyor_bottom
    ldy #2                                          ;
    lda conveyor_direction                          ;
    bmi prepare_bottom_of_left_conveyor             ;
prepare_bottom_of_right_conveyor
    ldx #$0f                                        ; Prepare bottom of conveyor
    jsr prepare_left_conveyor_bytes                 ;
    bmi leave26                                     ;
prepare_bottom_of_left_conveyor
    ldx #8                                          ;
    jsr prepare_right_conveyor_bytes                ;
leave26
    rts                                             ;

; ***************************************************************************************
prepare_right_conveyor_bytes
    lda (sprite_address_low1),Y                     ;
    sta packed_byte2                                ;
    lda #7                                          ;
    sta count                                       ;
prepare_right_conveyor_bytes_loop
    jsr rotate_and_store_conveyor_byte              ;
    inx                                             ;
    dec count                                       ;
    bpl prepare_right_conveyor_bytes_loop           ;
    rts                                             ;

prepare_left_conveyor_bytes
    lda (sprite_address_low1),Y                     ;
    sta packed_byte2                                ;
    lda #7                                          ;
    sta count                                       ;
prepare_left_conveyor_bytes_loop
    jsr rotate_and_store_conveyor_byte              ;
    dex                                             ;
    dec count                                       ;
    bpl prepare_left_conveyor_bytes_loop            ;
    rts                                             ;

; ***************************************************************************************
rotate_and_store_conveyor_byte
    lda packed_byte2                                ; }
    cmp #$80                                        ; } rotate 8 bits
    rol                                             ; }
    sta packed_byte2                                ; }

    jsr unpack_byte_of_sprite_data                  ;
    and conveyor_colour                             ;
    eor conveyor_colour_eor                         ;
    sta unpacked_conveyor_sprite,X                  ;

    lda unpacked_byte_two                           ;
    and conveyor_colour                             ;
    eor conveyor_colour_eor                         ;
    sta unpacked_conveyor_sprite + 16,X             ;
    rts                                             ;

; ***************************************************************************************
animate_game_over_boot
    lda #0                                          ;
    sta melody_active                               ; Disable melody
    jsr silence_tune                                ;
    ldx #0                                          ; Room 0 is the Game Over screen
    jsr calculate_room_data_address                 ;
    jsr initialise_enemies                          ;
    lda #1                                          ;
    sta enemies_unpacked_sprite_offset + 2          ; Set second barrel to use player sprite
    sta enemies_need_replot + 1                     ; Mark all enemies as needing plotting
    sta enemies_need_replot + 2                     ;
    sta enemies_need_replot + 3                     ;
    jsr plot_enemies                                ;
    lda #>(unpacked_enemy_sprites + $40)            ;
    sta plot_sprite_address_high                    ;
    lda #<(unpacked_enemy_sprites + $40)            ;
    sta plot_sprite_address_low                     ;
    ldx #3                                          ; Play game over sound
    jsr start_sound_x                               ;
animate_game_over_boot_loop
    lda enemies_x + 1                               ;
    ldx enemies_y + 1                               ;
    jsr plot_sprite                                 ; Plot boot
    ldx #$0f                                        ;
    jsr delay                                       ;
    inc enemies_y + 1                               ;
    lda enemies_y + 1                               ;
    cmp #$61                                        ;
    bne animate_game_over_boot_loop                 ;
    rts                                             ;

; ***************************************************************************************
delay
    ldy #0                                          ;
delay_loop
    dey                                             ;
    bne delay_loop                                  ;
    dex                                             ;
    bne delay_loop                                  ;
    rts                                             ;

; ***************************************************************************************
handle_player_jumping
    lda player_jump_timer                           ;
    beq leave27                                     ;
    tax                                             ;
    lda player_y_in_enemies                         ;
    clc                                             ;
    adc jump_parabola_table,X                       ;
    sta player_y_in_enemies                         ;
    dec player_jump_timer                           ;
    bne leave27                                     ;
    and #$fc                                        ; when jump finishes, align to a 4 pixel boundary in Y
    sta player_y_in_enemies                         ;
leave27
    rts                                             ;

; ***************************************************************************************
set_text_position
    ; Screen address = screen_start + (Y * 512 + 16 * X)
    lda #0                                      ;
    sta text_screen_high                        ;
    txa                                         ;
    asl                                         ;
    asl                                         ;
    asl                                         ;
    asl                                         ;
    rol text_screen_high                        ;
    sta text_screen_low                         ;
    tya                                         ;
    asl                                         ;
    clc                                         ;
    adc text_screen_high                        ;
    adc #>screen_memory_start                   ;
    sta text_screen_high                        ;
    rts                                         ;

; ***************************************************************************************
; Write character A at current character position
; Text Source address = character_set_definitions_start + (8 * A)
; Preserves A,X,Y
write_char
    sta temp3                                           ;
    stx temp4                                           ;
    sty temp5                                           ;

    cmp #charTab                                        ;
    beq move_to_next_screen_cell                        ;

    jsr plot_font_sprite                                ;

move_to_next_screen_cell
    lda text_screen_low                                 ;
    clc                                                 ;
    adc #16                                             ;
    sta text_screen_low                                 ; move to next character cell
    bcc +                                               ;
    inc text_screen_high                                ;
+
finish_up_write_char
    ldy temp5                                           ;
    ldx temp4                                           ;
    lda temp3                                           ;
    rts                                                 ;

; ***************************************************************************************
;
; Send byte to sound chip
;
; On Entry:
;   A = byte to send
;
; On Exit:
;   Preserves X
;
; Notes:
; To write pitch P (10 bit integer) to channel C (0-2, or 3=noise) and set volume V:
;
; write first byte:   128 + 32*C + top four bits of pitch P (0-15)
; write second byte:  lower 6 bits of pitch P
;
; To set volume V (0-15) on channel C (0-2, or 3=noise):
; write volume byte:  128 + 32*C + 16 + volume (0-15, 0 = loudest)
;
; ***************************************************************************************
send_to_sound_chip
    sty sound_temp_y                                    ;
    ldy #$ff                                            ; }
    sty systemVIADataDirectionRegisterA                 ; } set data direction to all outputs
    sta systemVIARegisterANoHandshake                   ; send data byte to sound chip
    iny                                                 ; Y=0
    sty systemVIARegisterB                              ; set the write enable line low (active)
                                                        ; to let the sound chip know there
                                                        ; is data
    jsr +                                               ; execute a short delay (this is to
                                                        ; keep the write enable line low for
                                                        ; at least 8 us, 16 cycles. This is
                                                        ; required by the sound chip hardware)
    ldy #8                                              ; }
    sty systemVIARegisterB                              ; } pull the write enable line high (inactive)
    ldy sound_temp_y                                    ;
+
    rts                                                 ;

; ***************************************************************************************
tile_table
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

; ***************************************************************************************
space_sprite
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

player_background_buffer
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

; ***************************************************************************************
sprite_arrow_left                                   ; 2 bits per pixel, 8x8, stored in screen order
    !byte $00, $00                                  ; ........
    !byte $44, $ff                                  ; ........
    !byte $44, $00                                  ; .#....##
    !byte $00, $00                                  ; #######.
    !byte $00, $00                                  ; .#....##
    !byte $33, $ee                                  ; ........
    !byte $33, $00                                  ; ........
    !byte $00, $00                                  ; ........

sprite_arrow_right
    !byte $00, $00                                  ; ........
    !byte $cc, $77                                  ; ........
    !byte $cc, $00                                  ; ##....#.
    !byte $00, $00                                  ; .#######
    !byte $00, $00                                  ; ##....#.
    !byte $22, $ff                                  ; ........
    !byte $22, $00                                  ; ........
    !byte $00, $00                                  ; ........

; ***************************************************************************************
unpacked_conveyor_sprite
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

unpacked_background_sprite
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

; ***************************************************************************************
;
; clear screen memory from $5600-$7fff
;
; ***************************************************************************************
clear_screen
    ldy #>($8000-screen_memory_start)               ;
clear_screen_y
    lda #>screen_memory_start                       ;
    sta clear_screen_loop + 2                       ;
    ldx #0                                          ;
    txa                                             ;
clear_screen_loop
    sta screen_memory_start,x                       ;
    inx                                             ;
    bne clear_screen_loop                           ;
    inc clear_screen_loop + 2                       ;
    dey                                             ;
    bne clear_screen_loop                           ;
    rts                                             ;

; ***************************************************************************************
;
; Map
;                                 $01
;                         $02 3 4 $05 6 7 $08
;                     $09 $0A $0B $0C $0D $0E
;             $0F $10 $11 $12 $13 $14 $15 $16
;             $17 $18 $19 $1A $1B $1C $1D $1E         $29 $2A
;             $1F $20 $21 $22 $23 $24 $25 $26 $27 $28 $2B $2C $2D
; $2E $2F $30 $31 $32                         $33 $34 $35 $36 $37 $38 $39
;                                                 $3A $3B $3C
;
!src "definitions.a"

; ***************************************************************************************
unpacked_sprites                                    ; 2 bits per pixel, 16x16, vertically inverted
player_sprite_left_frame_0
    !byte $33, $11, $cc, $00                        ; ....####........
    !byte $77, $00, $cc, $00                        ; ....####........
    !byte $55, $bb, $88, $00                        ; ...######.......
    !byte $11, $ff, $00, $00                        ; ....#.##........
    !byte $66, $ff, $66, $00                        ; ...#####........
    !byte $77, $ff, $ee, $00                        ; ....####........
    !byte $33, $ff, $cc, $00                        ; .....##.........
    !byte $11, $ff, $88, $00                        ; ....####........
    !byte $00, $ff, $00, $00                        ; ...######.......
    !byte $00, $66, $00, $00                        ; ..########......
    !byte $00, $ff, $00, $00                        ; .##########.....
    !byte $11, $ff, $00, $00                        ; .##.####.##.....
    !byte $00, $bb, $00, $00                        ; ...#####........
    !byte $11, $ff, $88, $00                        ; .#.##.###.......
    !byte $00, $ff, $00, $00                        ; .###....##......
    !byte $00, $ff, $00, $00                        ; ..##...###......

player_sprite_left_frame_1
    !byte $00, $ee, $ee, $00                        ; ......####......
    !byte $00, $77, $66, $00                        ; ......####......
    !byte $00, $66, $ee, $00                        ; .....######.....
    !byte $00, $33, $cc, $00                        ; ......#.##......
    !byte $00, $dd, $ff, $00                        ; .....#####......
    !byte $00, $ee, $ff, $00                        ; ......####......
    !byte $00, $77, $ee, $00                        ; .......##.......
    !byte $00, $77, $ee, $00                        ; ......####......
    !byte $00, $33, $cc, $00                        ; .....######.....
    !byte $00, $11, $88, $00                        ; .....######.....
    !byte $00, $33, $cc, $00                        ; ....###.####....
    !byte $00, $77, $cc, $00                        ; ....##.#####....
    !byte $00, $22, $cc, $00                        ; ......####......
    !byte $00, $77, $ee, $00                        ; .....##.###.....
    !byte $00, $33, $cc, $00                        ; .....###.##.....
    !byte $00, $33, $cc, $00                        ; ....###.###.....

player_sprite_left_frame_2
    !byte $00, $00, $ee, $00                        ; ........####....
    !byte $00, $00, $66, $00                        ; ........####....
    !byte $00, $00, $66, $00                        ; .......######...
    !byte $00, $00, $ff, $00                        ; ........#.##....
    !byte $00, $11, $bb, $88                        ; .......#####....
    !byte $00, $11, $dd, $88                        ; ........####....
    !byte $00, $11, $dd, $88                        ; .........##.....
    !byte $00, $11, $dd, $88                        ; ........####....
    !byte $00, $00, $ff, $00                        ; .......###.##...
    !byte $00, $00, $66, $00                        ; .......###.##...
    !byte $00, $00, $ff, $00                        ; .......###.##...
    !byte $00, $11, $ff, $00                        ; .......##.###...
    !byte $00, $00, $bb, $00                        ; ........####....
    !byte $00, $11, $ff, $88                        ; .........##.....
    !byte $00, $00, $ff, $00                        ; .........##.....
    !byte $00, $00, $ff, $00                        ; ........###.....

player_sprite_left_frame_3
    !byte $00, $00, $ee, $ee                        ; ..........####..
    !byte $00, $00, $77, $66                        ; ..........####..
    !byte $00, $00, $66, $ee                        ; .........######.
    !byte $00, $00, $33, $cc                        ; ..........#.##..
    !byte $00, $00, $dd, $ff                        ; .........#####..
    !byte $00, $00, $ee, $ff                        ; ..........####..
    !byte $00, $00, $77, $ee                        ; ...........##...
    !byte $00, $00, $77, $ee                        ; ..........####..
    !byte $00, $00, $33, $cc                        ; .........######.
    !byte $00, $00, $11, $88                        ; .........######.
    !byte $00, $00, $33, $cc                        ; ........###.####
    !byte $00, $00, $77, $cc                        ; ........##.#####
    !byte $00, $00, $22, $cc                        ; ..........####..
    !byte $00, $00, $77, $ee                        ; .........##.###.
    !byte $00, $00, $33, $cc                        ; .........###.##.
    !byte $00, $00, $33, $cc                        ; ........###.###.

player_sprite_right_frame_0
    !byte $77, $77, $00, $00                        ; ..####..........
    !byte $66, $ee, $00, $00                        ; ..####..........
    !byte $77, $66, $00, $00                        ; .######.........
    !byte $33, $cc, $00, $00                        ; ..##.#..........
    !byte $ff, $bb, $00, $00                        ; ..#####.........
    !byte $ff, $77, $00, $00                        ; ..####..........
    !byte $77, $ee, $00, $00                        ; ...##...........
    !byte $77, $ee, $00, $00                        ; ..####..........
    !byte $33, $cc, $00, $00                        ; .######.........
    !byte $11, $88, $00, $00                        ; .######.........
    !byte $33, $cc, $00, $00                        ; ####.###........
    !byte $33, $ee, $00, $00                        ; #####.##........
    !byte $33, $44, $00, $00                        ; ..####..........
    !byte $77, $ee, $00, $00                        ; .###.##.........
    !byte $33, $cc, $00, $00                        ; .##.###.........
    !byte $33, $cc, $00, $00                        ; .###.###........

player_sprite_right_frame_1
    !byte $00, $77, $00, $00                        ; ....####........
    !byte $00, $66, $00, $00                        ; ....####........
    !byte $00, $66, $00, $00                        ; ...######.......
    !byte $00, $ff, $00, $00                        ; ....##.#........
    !byte $11, $dd, $88, $00                        ; ....#####.......
    !byte $11, $bb, $88, $00                        ; ....####........
    !byte $11, $bb, $88, $00                        ; .....##.........
    !byte $11, $bb, $88, $00                        ; ....####........
    !byte $00, $ff, $00, $00                        ; ...##.###.......
    !byte $00, $66, $00, $00                        ; ...##.###.......
    !byte $00, $ff, $00, $00                        ; ...##.###.......
    !byte $00, $ff, $88, $00                        ; ...###.##.......
    !byte $00, $dd, $00, $00                        ; ....####........
    !byte $11, $ff, $88, $00                        ; .....##.........
    !byte $00, $ff, $00, $00                        ; .....##.........
    !byte $00, $ff, $00, $00                        ; .....###........

player_sprite_right_frame_2
    !byte $00, $77, $77, $00                        ; ......####......
    !byte $00, $66, $ee, $00                        ; ......####......
    !byte $00, $77, $66, $00                        ; .....######.....
    !byte $00, $33, $cc, $00                        ; ......##.#......
    !byte $00, $ff, $bb, $00                        ; ......#####.....
    !byte $00, $ff, $77, $00                        ; ......####......
    !byte $00, $77, $ee, $00                        ; .......##.......
    !byte $00, $77, $ee, $00                        ; ......####......
    !byte $00, $33, $cc, $00                        ; .....######.....
    !byte $00, $11, $88, $00                        ; .....######.....
    !byte $00, $33, $cc, $00                        ; ....####.###....
    !byte $00, $33, $ee, $00                        ; ....#####.##....
    !byte $00, $33, $44, $00                        ; ......####......
    !byte $00, $77, $ee, $00                        ; .....###.##.....
    !byte $00, $33, $cc, $00                        ; .....##.###.....
    !byte $00, $33, $cc, $00                        ; .....###.###....

player_sprite_right_frame_3
    !byte $00, $33, $88, $cc                        ; ........####....
    !byte $00, $33, $00, $ee                        ; ........####....
    !byte $00, $11, $dd, $aa                        ; .......######...
    !byte $00, $00, $ff, $88                        ; ........##.#....
    !byte $00, $66, $ff, $66                        ; ........#####...
    !byte $00, $77, $ff, $ee                        ; ........####....
    !byte $00, $33, $ff, $cc                        ; .........##.....
    !byte $00, $11, $ff, $88                        ; ........####....
    !byte $00, $00, $ff, $00                        ; .......######...
    !byte $00, $00, $66, $00                        ; ......########..
    !byte $00, $00, $ff, $00                        ; .....##########.
    !byte $00, $00, $ff, $88                        ; .....##.####.##.
    !byte $00, $00, $dd, $00                        ; ........#####...
    !byte $00, $11, $ff, $88                        ; .......###.##.#.
    !byte $00, $00, $ff, $00                        ; ......##....###.
    !byte $00, $00, $ff, $00                        ; ......###...##..

; ***************************************************************************************
unpacked_enemy_sprites
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

next_index
    !byte 1, 2, 0
colour_array
    !byte $f0, $ff, $0f

; ***************************************************************************************
arrow_timers_table
    ;      0    1    2    3    4
    !byte $d0, $16, $1e, $26, $7f                   ; [Third value unused]

; ***************************************************************************************
palette_changes
    !byte $ff                                       ; row 0
    !byte $ff                                       ; row 1
    !byte $ff                                       ; row 2
    !byte $ff                                       ; row 3
    !byte $ff                                       ; row 4
    !byte $ff                                       ; row 5
    !byte $ff                                       ; row 6
    !byte $ff                                       ; row 7
    !byte $ff                                       ; row 8
    !byte $ff                                       ; row 9
    !byte $ff                                       ; row 10
    !byte $ff                                       ; row 11
    !byte $ff                                       ; row 12
    !byte $ff                                       ; row 13
    !byte $ff                                       ; row 14
    !byte $ff                                       ; row 15

; ***************************************************************************************
start_of_palettes
room_palette
    !byte black                                     ; logical colour 0
    !byte black                                     ; logical colour 1
    !byte black                                     ; logical colour 2
    !byte black                                     ; logical colour 3
footer_palette
    !byte black                                     ; logical colour 0
    !byte magenta                                   ; logical colour 1
    !byte cyan                                      ; logical colour 2
    !byte yellow                                    ; logical colour 3
title_palette
    !byte black                                     ; logical colour 0
    !byte red                                       ; logical colour 1
    !byte green                                     ; logical colour 2
    !byte white                                     ; logical colour 3
game_over_palette
    !byte black
    !byte yellow
    !byte white
    !byte blue

; ***************************************************************************************
paletteLookupTable
    !byte $00, $20, $80, $a0

; ***************************************************************************************
; This commented out data is what the jump parabola should be, but the engine has trouble
; with odd Y increments it seems. See West of Kitchen jumping up into The Banyan Tree; In
; Tree Root, jumping onto the yellow platform can cause problems. And other cases too.
;
;jump_parabola_table
;    !byte $00, $04, $04, $03, $03, $02, $02, $01, $01, $00, $00, $ff, $ff, $fe, $fe, $fd, $fd
;    !byte $fc, $fc

jump_parabola_table
    !byte $00, $04, $04, $04, $04, $02, $02, $02, $00, $00, $00, $00, $fe, $fe, $fe, $fe, $fc
    !byte $fc, $fc

; ***************************************************************************************
handle_rope_time_and_events
    lda room_contains_rope                          ;
    beq no_rope                                     ;

    ; wait until the electron beam has passed by the rope
-
    lda irq_counter                                 ;
    cmp #11                                         ;
    bcc -
    jsr unplot_rope                                 ;
    lda #0                                          ;
    sta rope_pixel_touched                          ;
    sta rope_end_y                                  ;
    lda #$80                                        ; centre rope on screen
    ldx player_room                                 ;
    cpx #48                                         ; "The Beach"
    bne +                                           ;
    lda #$70                                        ; The rope on 'The Beach' is further left
+
    sta rope_end_x                                  ;
    ldx rope_position                               ;
    lda #$20                                        ;
    sta rope_pixel_to_consider                      ;
update_rope_pixels_loop
    jsr update_rope_pixel                           ;
    dec rope_pixel_to_consider                      ;
    bpl update_rope_pixels_loop                     ;
    lda rope_velocity_relative_to_centre            ;
    asl                                             ;
    clc                                             ;
    adc rope_position                               ;
    tay                                             ; Y is the new rope position
    cmp #$d4                                        ;
    bne rope_didnt_change_sides                     ;
    lda rope_position_relative_to_centre            ;
    eor #$ff                                        ;
    sta rope_position_relative_to_centre            ;
    lda #10                                         ;
rope_didnt_change_sides
    cmp #10                                         ;
    bne rope_didnt_reach_end                        ;
    lda rope_velocity_relative_to_centre            ;
    eor #$ff                                        ;
    sta rope_velocity_relative_to_centre            ;
    inc rope_velocity_relative_to_centre            ;
rope_didnt_reach_end
    sty rope_position                               ;
    jsr check_for_player_contact_with_rope          ;
no_rope
    jsr handle_time                                 ;
    jmp handle_endgame                              ;

; ***************************************************************************************
update_rope_pixel
    stx rope_pixel_position                         ;
    lda rope_pixel_to_consider                      ;
    cmp #$20                                        ;
    bne +                                           ;
    ldx #2 + rope_x_delta_table_end - rope_x_delta_table    ;
+
    ; update pixel position
    txa                                             ;
    bpl skip_floor1                                 ; if (current offset within sliding window of rope values is positivie) then branch
    ldx #rope_x_delta_table_end - rope_x_delta_table; use the final but one value
    cmp #$f4                                        ;
    bcs skip_floor1                                 ; if (near the actual array of offsets start) then branch (use offset 54, value one)
    ldx #1 + rope_x_delta_table_end - rope_x_delta_table ; else use offset 55 (value zero)
skip_floor1
    lda rope_x_delta_table,X                        ;
    cmp rope_position_relative_to_centre            ;
    bcc skip_inversion1                             ; if (heading towards centre) then branch
    eor #$ff                                        ;
skip_inversion1
    adc rope_end_x                                  ;
    sta rope_end_x                                  ;
    lda rope_end_y                                  ;
    clc                                             ;
    adc rope_y_delta_table,X                        ;
    cmp #$60                                        ; }
    bcc +                                           ; } Make sure the rope doesn't trail in 'Swimming Pool' water.
    lda #$5f                                        ; }
+                                                   ; }
    sta rope_end_y                                  ;
    ldy rope_pixel_to_consider                      ;
    sta rope_pixels_y,Y                             ;
    tax                                             ;
    lda rope_end_x                                  ;
    sta rope_pixels_x,Y                             ;

    ; plot pixel
    jmp plot_rope_pixel                             ;


; ***************************************************************************************
plot_rope_pixel
    sta rope_pixel_x                                ;
    jsr calculate_screen_address                    ;
    lda rope_pixel_x                                ;
    and #3                                          ;
    tax                                             ;
    lda rope_bit_table,X                            ;
    sta temp_rope                                   ;

    ldy #0                                          ;
    lda (screen_address_low),Y                      ;
    lsr                                             ; check for white pixels only
    lsr                                             ; fixes bug where rope touching the enemies
    lsr                                             ; causes the player to attach to the rope
    lsr                                             ;
    and (screen_address_low),Y                      ;
    and temp_rope                                   ;
    beq rope_not_touching_player                    ;

    lda rope_pixel_to_consider                      ;
    sta rope_pixel_touched                          ;
rope_not_touching_player
    lda rope_pixel_values_table,X                   ;
    ora (screen_address_low),Y                      ;
    sta (screen_address_low),Y                      ;

    ; remember address (to unplot later)
    lda rope_pixel_values_table,X                   ;
    eor #$ff                                        ;
    ldx rope_pixel_to_consider                      ;
    sta rope_pixels_mask_table,X                    ;
    lda screen_address_low                          ;
    sta rope_pixels_screen_address_low_table,X      ;
    lda screen_address_high                         ;
    sta rope_pixels_screen_address_high_table,X     ;

    ldx rope_pixel_position                         ;
    inx                                             ;
    rts                                             ;

rope_pixel_values_table
    !byte $88, $44, $22, $11

rope_bit_table
    !byte $08, $04, $02, $01

; ***************************************************************************************
unplot_rope
    ldx #$20                                        ;
    ldy #0                                          ;
unplot_rope_loop
    lda rope_pixels_screen_address_low_table,X      ;
    sta rope_pixels_screen_address_low              ;
    lda rope_pixels_screen_address_high_table,X     ;
    sta rope_pixels_screen_address_high             ;
    lda (rope_pixels_screen_address_low),Y          ;
    and rope_pixels_mask_table,X                    ;
    sta (rope_pixels_screen_address_low),Y          ;
    dex                                             ;
    bpl unplot_rope_loop                            ;
    rts                                             ;

; ***************************************************************************************
check_for_player_contact_with_rope
    ldx player_rope_pixel                           ;
    bne player_already_on_rope                      ;
    lda rope_pixel_touched                          ;
    beq leave1                                      ;

    ; player is now on the rope
    ldx #0                                          ;
    stx player_entered_room_falling_too_far         ;
    lda player_y_in_enemies                         ;
    clc                                             ;
    adc #4                                          ;
check_y_loop
    inx                                             ;
    cmp rope_pixels_y,X                             ;
    bcc check_y_loop                                ;
    cpx #2                                          ;
    bcc remove_player_from_rope                     ;
    stx player_rope_pixel                           ;
player_already_on_rope
    lda player_jump_timer                           ;
    cmp #$0e                                        ;
    bcs remove_player_from_rope                     ;
    lda #0                                          ;
    sta player_is_jumping                           ;
    sta player_jump_timer                           ;
    lda rope_pixels_x,X                             ;
    sec                                             ;
    sbc #4                                          ;
    and #$fe                                        ;
    sta player_x_in_enemies                         ;
    lda rope_pixels_y,X                             ;
    sec                                             ;
    sbc #8                                          ;
    bpl skip_floor2                                 ;
    lda #$c0                                        ;
skip_floor2
    sta player_y_in_enemies                         ;
    lda player_horizontal_speed                     ;
    beq leave1                                      ;
    lda rope_position_relative_to_centre            ;
    eor rope_velocity_relative_to_centre            ;
    inx                                             ;
    eor player_horizontal_speed                     ;
    bpl player_moving_up_rope                       ;
player_moving_down_rope
    dex                                             ;
    dex                                             ;
player_moving_up_rope
    stx player_rope_pixel                           ;
    cpx #3                                          ;
    bcs leave1                                      ;
    lda player_y_in_enemies                         ; Make player fall off bottom of rope
    adc #4                                          ;
    sta player_y_in_enemies                         ;
remove_player_from_rope
    lda player_y_in_enemies                         ;
    and #$fc                                        ;
    sta player_y_in_enemies                         ;
    lda #0                                          ;
    sta player_rope_pixel                           ;
leave1
    rts                                             ;

; ***************************************************************************************
write_status_line
    ldx #0                                              ;
    ldy #20                                             ;
    jsr set_text_position                               ;
    ldx #$ff                                            ;
write_items_collected_loop
    inx                                                          ;
    lda items_collected_string,X                                 ;
    jsr write_char                                               ;
    cpx #items_collected_string_end - items_collected_string - 1 ;
    bne write_items_collected_loop                      ;
    jsr write_items_collected                           ;
    jmp write_time                                      ;

items_collected_string
    !convtab "string_table.bin" {
        !text "Items collected 000 Time  7:00am"    ;
    }
items_collected_string_end

; ***************************************************************************************
collect_item
    ldx #2                                          ; Play sound for collecting item
    jsr start_sound_x                               ;
    inc items_collected_low                         ;
    lda items_collected_low                         ;
    cmp #$0a                                        ;
    bcc write_items_collected                       ;
    inc items_collected_high                        ;
    lda #0                                          ;
    sta items_collected_low                         ;
    lda items_collected_high                        ;
    cmp #8                                          ;
    bcc write_items_collected                       ;
    inc house_clear                                 ; 80 items needed to clear house
write_items_collected
    ldx #17                                         ;
    ldy #20                                         ;
    jsr set_text_position                           ;
    lda items_collected_high                        ;
    jsr write_digit_a                               ;
    lda items_collected_low                         ;
    jmp write_digit_a                               ;

; ***************************************************************************************
write_digit_a
    clc                                             ;
    adc #char0                                      ;
    jmp write_char                                  ;

; ***************************************************************************************
handle_time
    dec game_timer                                  ;
    lda game_timer                                  ;
    and #$7f                                        ;
    bne leave2                                      ;
    inc time_fraction                               ;
    lda time_fraction                               ;
    cmp #3                                          ;
    bne leave2                                      ;

    ; increment clock by one minute
    ldy #0                                          ;
    sty time_fraction                               ;

    ; minutes
    inc minutes_low                                 ;
    lda minutes_low                                 ;
    cmp #10                                         ;
    bcc write_time                                  ;
    sty minutes_low                                 ;
    inc minutes_high                                ;
    lda minutes_high                                ;
    cmp #6                                          ;
    bcc write_time                                  ;
    sty minutes_high                                ;

    ; hours
    inc hours                                       ;
    lda hours                                       ;
    cmp #12                                         ;
    bcc check_for_out_of_time                       ;
    cmp #13                                         ;
    bcc toggle_am_pm                                ;
    lda #1                                          ; 13 o'clock becomes 1 o'clock
    sta hours                                       ;

check_for_out_of_time
    lda hours                                       ;
    cmp #1                                          ;
    bne write_time                                  ; if (not 1 o'clock) then branch
    lda hours_am                                    ;
    cmp #chara                                      ; if (not am) then branch
    bne write_time                                  ;

    ; out of time
    inc out_of_time                                 ;
    inc player_killed                               ;
write_time
    ldx #$19                                        ;
    ldy #20                                         ;
    jsr set_text_position                           ;

    ldy #0                                          ;
    lda hours                                       ;
    cmp #10                                         ;
    bcc +                                           ;
    iny                                             ;
    sec                                             ;
    sbc #10                                         ;
+
    sta hours_low                                   ;
    tya                                             ;
    bne +                                           ;
    lda #charSpace                                  ;
    jsr write_char                                  ;
    jmp skip_hours_high                             ;
+
    jsr write_digit_a                               ;
skip_hours_high
hours_low = * + 1
    lda #$ff                                        ;
    jsr write_digit_a                               ;
    lda #charTab                                    ;
    jsr write_char                                  ;
    lda minutes_high                                ;
    jsr write_digit_a                               ;
    lda minutes_low                                 ;
    jsr write_digit_a                               ;
    lda hours_am                                    ;
    jsr write_char                                  ;
leave2
    rts                                             ;

toggle_am_pm
    lda hours_am                                    ;
    eor #(charp XOR chara)                          ;
    sta hours_am                                    ;
    jmp write_time                                  ;

; ***************************************************************************************
reset_game
    ldy #0                                          ;
    jsr start_tune_y                                ; Start 'If I Were a Rich Man'
    lda #0                                          ;
    sta replay_timer                                ;
    sta time_fraction                               ;
    sta player_entered_room_falling_too_far         ;
    sta items_collected_low                         ;
    sta items_collected_high                        ;
    sta minutes_low                                 ;
    sta minutes_high                                ;
    sta house_clear                                 ;
    sta out_of_time                                 ;
    sta player_is_jumping                           ;
    sta player_jump_timer                           ;
    sta swimming_pool_item_collected                ;
    lda #2                                          ;
    sta player_speed                                ; face right
    lda #7                                          ;
    sta hours                                       ; Game starts at 7:00am
    lda #chara                                      ;
    sta hours_am                                    ;
    lda #7                                          ; Player starts with 7 lives
    sta player_lives                                ;
    lda #player_start_y                             ;
    sta player_y_in_enemies                         ;
    lda #player_start_x                             ;
    sta player_x_in_enemies                         ;
    lda #player_start_room                          ; Player starts in "The Bathroom"
    sta player_room                                 ;
    jsr reset_items                                 ;
    jsr clear_screen                                ;
    jmp write_status_line                           ;

; ***************************************************************************************
handle_endgame
    lda player_room                                 ;
    cmp #$13                                        ; Master Bedroom
    bne not_master_bedroom                          ;
    lda player_y_in_enemies                         ;
    cmp #$67                                        ;
    bcs below_maria                                 ;
    ldx #$0a                                        ;
    cmp #$60                                        ;
    bcs set_maria_offset                            ;
    ldx #$0b                                        ; Make Maria raise her arm when Willy in line of sight
    bne set_maria_offset                            ;
below_maria
    lda enemies_unpacked_sprite_offset + 1          ;
    and #9                                          ;
    eor #1                                          ;
    sta enemies_unpacked_sprite_offset + 1          ;
    tax                                             ;
set_maria_offset
    stx enemies_unpacked_sprite_offset + 1          ;
not_master_bedroom
    cmp #$15                                        ; The Bathroom
    bne not_the_bathroom                            ;
    lda game_timer                                  ;
    and #1                                          ;
    bne not_the_bathroom                            ;
    lda enemies_unpacked_sprite_offset + 2          ;
    eor #1                                          ; Make the toilet flap its lid
    sta enemies_unpacked_sprite_offset + 2          ;
not_the_bathroom
    lda house_clear                                 ;
    beq leave4                                      ; Has the player collected all the items?
    bmi dash_for_toilet                             ; If so, are they dashing for the toilet?
check_for_pillow
    lda player_room                                 ;
    cmp #$13                                        ; Master Bedroom
    bne leave4                                      ;
    lda #0                                          ;
    sta enemies_colour + 1                          ; Hide Maria if all items have been collected
    lda player_x_in_enemies                         ;
    cmp #$18                                        ;
    bne leave4                                      ; Is the player about to touch the pillow?
    lda #$ff                                        ; If so, make them dash for the toilet
    sta house_clear                                 ;
    rts                                             ;

; ***************************************************************************************
dash_for_toilet
    lda #2                                          ;
    sta player_horizontal_speed                     ; Make the player move right.
    lda #0                                          ;
    sta player_started_jump                         ;
    lda player_room                                 ;
    cmp #$14                                        ; Top Landing ; Is the player in Top Landing?
    bne not_top_landing                             ;
    lda player_x_in_enemies                         ;
    cmp #$88                                        ; Jump over hole
    beq force_jump                                  ;
    cmp #$b0                                        ; Jump over enemy
    bne leave3                                      ;
force_jump
    inc player_started_jump                         ;
leave3
    rts                                             ;
not_top_landing
    bcc leave4                                      ; Is the player in The Bathroom?
    lda player_x_in_enemies                         ;
    cmp #$d8                                        ;
    bcc leave4                                      ; Is the player about to touch the toilet?
    lda #$0a                                        ;
    ora enemies_unpacked_sprite_offset + 2          ;
    sta enemies_unpacked_sprite_offset + 2          ; Set the toilet to contain the player's legs.
    lda #2                                          ;
    sta player_not_plotted                          ; Set the player to be unplotted, but not plotted
leave4
    rts                                             ;

; ***************************************************************************************
mark_enemies_that_overlap_player                    ; Called with tile_address_low1 of the player
    ldy #0                                          ;
    jsr check_tiles_for_enemy                       ;
    ldy #$20                                        ;
    jsr check_tiles_for_enemy                       ;
    lda player_y_in_enemies                         ;
    and #7                                          ;
    beq leave5                                      ;
    ldy #$60                                        ;
check_tiles_for_enemy
    jsr check_tile_for_enemy                        ;
    iny                                             ;
check_tile_for_enemy
    lda (tile_address_low1),Y                       ;
    bpl leave5                                      ; Is there an enemy in this tile?
    cmp #$8a                                        ;
    bcs leave5                                      ;
    and #$0f                                        ;
    tax                                             ;
    lda #2                                          ;
    sta enemies_need_replot,X                       ; Set enemy to not need plotting once (enemy overlaps player, will be plotted slightly later that the other enemies)
leave5
    rts                                             ;

; ***************************************************************************************
update_arrows
    ldy #1                                          ;
update_arrows_loop
    ldx arrow_timer,Y                               ;
    bmi update_active_arrow                         ;
    beq consider_next_arrow1                        ;
    lda game_timer                                  ;
    and #1                                          ;
    bne consider_next_arrow1                        ;
    dex                                             ;
    bne no_new_arrow                                ;
    lda #$ff                                        ;
    sta arrow_timer,Y                               ;
    lda arrow_initial_x_positions,Y                 ;
    sta arrow_x,Y                                   ;
    jmp arrow_still_active                          ;

no_new_arrow
    txa                                             ;
    sta arrow_timer,Y                               ;
    cmp #3                                          ;
    bne consider_next_arrow1                        ;
    ldx #1                                          ; Play sound for arrow firing
    jsr start_sound_x                               ;
consider_next_arrow1
    dey                                             ;
    bpl update_arrows_loop                          ;
    rts                                             ;

; ***************************************************************************************
update_active_arrow
    jsr plot_arrow                                  ; Unplot arrow
    lda arrow_x,Y                                   ;
    clc                                             ;
    adc arrow_speeds,Y                              ;
    sta arrow_x,Y                                   ;
    cmp arrow_initial_x_positions,Y                 ;
    bne arrow_still_active                          ;
    lda #$7f                                        ;
    sta arrow_timer,Y                               ;
    bpl consider_next_arrow1                        ;
arrow_still_active
    jsr plot_arrow                                  ;
    ldx #8                                          ; Use enemy slot 8 for arrow
    jsr calculate_tile_address_for_enemy_X          ;
    ldy #$20                                        ;
    lda (tile_address_low1),Y                       ;
    ldy arrow                                       ;
    sta arrow_active,Y                              ;
    jmp consider_next_arrow1                        ;

plot_arrow
    sty arrow                                       ;
    lda arrow_x,Y                                   ;
    sta enemies_x + 8                               ;
    ldx arrow_y,Y                                   ;
    stx enemies_y + 8                               ;
    jsr calculate_screen_address                    ;
    lda arrow_sprite_offsets_low,Y                  ;
    sta arrow_sprite_address_low                    ;
    lda arrow_sprite_offsets_high,Y                 ;
    sta arrow_sprite_address_high                   ;
    lda arrow_active,Y                              ;
    bmi unplot_arrow                                ;
    ldy #$0f                                        ;
plot_arrow_loop
arrow_sprite_address_low = * + 1
arrow_sprite_address_high = * + 2
    lda $ffff,Y                                     ; [address is overwritten before use]
    eor (screen_address_low),Y                      ;
    sta (screen_address_low),Y                      ;
    dey                                             ;
    bne plot_arrow_loop                             ;
    ldy arrow                                       ;
    rts                                             ;
unplot_arrow
    lda #0                                          ;
    sta arrow_active,Y                              ;
    ldy #$0f                                        ;
wipe_arrow_loop
    sta (screen_address_low),Y                      ;
    dey                                             ;
    bne wipe_arrow_loop                             ;
    ldy arrow                                       ;
    rts                                             ;

; ***************************************************************************************
arrow_sprite_offsets_low
    !byte <sprite_arrow_right, <sprite_arrow_left
arrow_sprite_offsets_high
    !byte >sprite_arrow_right, >sprite_arrow_left

arrow_initial_x_positions
    !byte $00, $f8

arrow_speeds
    !byte $08, $f8

arrow_x
    !byte $00, $00

arrow_active
    !byte $00, $00

; ***************************************************************************************
update_lives
    lda game_timer                                  ;
    and #3                                          ;
    bne leave6                                      ;
life_sprite_address_low = * + 1
    lda #$00                                        ;
    clc                                             ;
    adc #64                                         ;
    sta life_sprite_address_low                     ;
    clc                                             ;
    adc #<player_sprite_right_frame_0               ;
    sta plot_sprite_address_low                     ;
    lda #>player_sprite_right_frame_0               ;
    adc #0                                          ;
    sta plot_sprite_address_high                    ;
    lda #3                                          ;
    sta life_colour                                 ;
    lda #$f0                                        ;
    sta life_x                                      ;
    lda player_lives                                ;
    beq leave6                                      ;
    sta lives_remaining_to_plot                     ;
update_lives_loop
    ldx life_colour                                 ;
    dex                                             ;
    bne skip_floor3                                 ;
    ldx #3                                          ;
skip_floor3
    stx life_colour                                 ;
    lda life_colours,X                              ;
    sta sprite_colour                               ;
    lda life_x                                      ;
    clc                                             ;
    adc #$10                                        ;
    sta life_x                                      ;
    ldx life_y                                      ;
    jsr plot_sprite                                 ;
    dec lives_remaining_to_plot                     ;
    bne update_lives_loop                           ;
leave6
    rts                                             ;

; ***************************************************************************************
initialise_room_background_tiles_and_title
    ldy #5                                          ; For each of six tile types
set_tile_colours_loop
    ldx #2                                          ;
    jsr get_x_bits_of_room_data                     ; Get two bits of room data for each tile colour
    sta background_tiles_colours_fg,Y               ;
    ldx #2                                          ;
    jsr get_x_bits_of_room_data                     ; Get two bits of room data for each tile colour (background)
    sta background_tiles_colours_bg,Y               ;
    dey                                             ;
    bpl set_tile_colours_loop                       ;

    ldy #6                                          ; For each of seven tile types
set_tile_sprites_loop
    ldx #8                                          ; Get eight bits of room data for each tile sprite
    jsr get_x_bits_of_room_data                     ;
    sta background_tiles_sprites,Y                  ;
    dey                                             ;
    bpl set_tile_sprites_loop                       ;

    ldy #3                                          ; For each of four screen colours
set_screen_colours_loop
    ldx #3                                          ;
    jsr get_x_bits_of_room_data                     ; Get three bits of room data for each screen colour
    sta room_palette,Y                              ;
    dey                                             ;
    bpl set_screen_colours_loop                     ;

    jsr clear_room_palette_changes                  ;

    ldx #4
    jsr get_x_bits_of_room_data                     ; Get four bits of room data for number of palette changes
    beq +                                           ;
    sta palette_loop_counter                        ;
-
    ldx #4                                          ;
    jsr get_x_bits_of_room_data                     ; Get four bits of room data for row of palette change
    tay
    ldx #5                                          ;
    jsr get_x_bits_of_room_data                     ; Get five bits of room data for palette change value
    sta palette_changes,Y                           ;
    dec palette_loop_counter                        ;
    bne -                                           ;

+
    lda #1                                          ; First word is uppercase
    sta start_of_word                               ;

    ldx #4                                          ; Get four bits of room data for position of room title
    jsr get_x_bits_of_room_data                     ;
    tax
    ldy #$10                                        ;
    jsr set_text_position                           ; TAB to start of room title

    ; get title length
    ldx #5                                          ; Get five bits of room data for title length - 1
    jsr get_x_bits_of_room_data                     ;
    clc                                             ;
    adc #1                                          ;
    sta title_length                                ;
write_room_title_loop
    dec title_length                                ;
    bmi leave6                                      ;
    ldx #5                                          ; Get five bits of room data for each character of title
    jsr get_x_bits_of_room_data                     ;
    cmp #$1a                                        ;
    bcs is_non_letter                               ;
    jsr write_letter                                ; $00 to $1a writes "a" to "z"
    jmp write_room_title_loop                       ;

; ***************************************************************************************
is_non_letter
    beq is_caps                                     ;
    cmp #$1c                                        ;
    bcc is_apostrophe_char                          ;
    beq is_full_stop_char                           ;
    cmp #$1e                                        ;
    bcc is_space_char                               ;
    beq is_space_char_with_caps                     ;
is_the
    lda #$13                                        ; "t" ; $1f writes "The"
    jsr write_letter                                ;
    lda #charh                                      ;
    jsr write_char                                  ;
    lda #chare                                      ;
    bne write_char_and_continue                     ; ALWAYS branch

; ***************************************************************************************
is_caps
    inc start_of_word                               ;
    bne write_room_title_loop                       ; ALWAYS branch

; ***************************************************************************************
is_full_stop_char
    lda #charFullStop                               ;
    bne write_char_and_continue                     ; ALWAYS branch

; ***************************************************************************************
is_apostrophe_char
    lda #charApostrophe                             ; $1b writes apostrophe
write_char_and_continue
    jsr write_char                                  ;
    jmp write_room_title_loop                       ;

; ***************************************************************************************
is_space_char_with_caps
    inc start_of_word                               ; $1e writes " ", resetting case
is_space_char
    lda #charSpace                                  ; $1d writes " ", keeping lower case
    bne write_char_and_continue                     ; ALWAYS branch

; ***************************************************************************************
write_letter
    clc                                             ;
    adc #chara                                      ;
    ldy start_of_word                               ;
    beq lower_case                                  ;
    sec                                             ;
    sbc #chara - charA                              ; convert to upper case
    ldx #0                                          ;
    stx start_of_word                               ;
lower_case
    jmp write_char                                  ;

; ***************************************************************************************
initialise_arrows
    ldy #1                                          ; For each of two arrows
initialise_arrows_loop
    lda #0                                          ;
    sta arrow_active,Y                              ;
    sta arrow_timer,Y                               ;
    ldx #1                                          ; Get one bit of room data for presence of arrow
    jsr get_x_bits_of_room_data                     ;
    tax                                             ;
    beq consider_next_arrow2                        ; If arrow present
    ldx #4                                          ; Get four bits of room data for arrow_y
    jsr get_x_bits_of_room_data                     ;
    tax                                             ;
    beq consider_next_arrow2                        ;
    asl                                             ;
    asl                                             ;
    asl                                             ;
    eor #$78                                        ;
    sta arrow_y,Y                                   ;
    ldx #3                                          ; Get three bits of room data for arrow timing
    jsr get_x_bits_of_room_data                     ;
    tax                                             ;
    lda arrow_timers_table,X                        ;
    sta arrow_timer,Y                               ;
    sta arrow_x,Y                                   ;
    sta arrow_active,Y                              ;
consider_next_arrow2
    dey                                             ;
    bpl initialise_arrows_loop                      ;

handle_room_tweaks_on_entry
    lda #0                                          ;
    ldy #$80                                        ;
    ldx player_room                                 ;
    cpx #$19                                        ; Swimming Pool
    bne fill_space_sprite                           ; Is this the Swimming Pool?
    lda swimming_pool_item_collected                ;
    bne already_collected_item                      ;
    inc swimming_pool_item_collected                ; If so, collect item on first visit
    jsr collect_item                                ;
already_collected_item
    ldx #0                                          ;
fill_enemy_with_water_loop
    lda #$f0                                        ; Set background of enemy sprite to be colour 2 (cyan)
    ora unpacked_enemy_sprites,X                    ;
    sta unpacked_enemy_sprites,X                    ;
    lda #$f0                                        ;
    ora unpacked_enemy_sprites + $100,X             ;
    sta unpacked_enemy_sprites + $100,X             ;
    dex                                             ;
    bne fill_enemy_with_water_loop                  ;
    lda #$f0                                        ; Set background of space sprite (used to unplot enemy
    ldy #1                                          ; after movement) to be the same. Use tile 1 for space
fill_space_sprite                                   ; so player can stand on swimming pool water.
    sty space_tile                                  ;
    ldx #$1f                                        ;
fill_space_sprite_loop
    sta space_sprite,X                              ;
    dex                                             ;
    bpl fill_space_sprite_loop                      ;

    ldx #0                                          ;
    lda player_room                                 ;
    cmp #$1b                                        ; Is this The Nightmare Room?
    bne not_nightmare_room                          ;
    lda #$10                                        ;
    sta enemies_unpacked_sprite_offset + 7          ; If so, change left-most enemy to use Maria sprite.
    lda #3                                          ; It is originally a pig, setting up the sprite for:
    sta enemies_sprite + 7                          ;
    ldx #8                                          ; Use pig for player sprite.
not_nightmare_room
    stx enemies_unpacked_sprite_offset              ; (otherwise use player)
    rts                                             ;

; ***************************************************************************************
real_entry_point
    jsr title_screen                                ;
    jsr reset_game                                  ;
new_life_loop
    jsr initialise_room                             ;
game_loop
    inc replay_timer                                ;
    jsr update_lives                                ;
    jsr update_game                                 ;
    jsr check_for_game_exit                         ;
    lda player_killed                               ;
    beq game_loop                                   ;
    lda player_lives                                ;
    bpl new_life_loop                               ;
game_over
    ldy #>($7600-screen_memory_start)               ;
    jsr clear_screen_y                              ;
    jsr clear_room_palette_changes                  ;
    lda #game_over_palette - start_of_palettes      ;
    jsr set_full_room_palette                       ;
    lda #3 + 4 * white                              ; Set logical colour 3 to white
    sta palette_changes + 12                        ;
    lda #1 + 4 * red                                ; Set logical colour 1 to red
    sta palette_changes + 14                        ;

    lda #0                                          ;
    jsr fill_space_sprite                           ; Ensure space sprite is black
    jsr animate_game_over_boot                      ;
    ldx #50                                         ;
    stx game_over_timer                             ;
game_over_loop
-
    lda vsync_counter                               ;
    cmp #5                                          ;
    bcc -
    ldy #0                                          ; loop counter
    sty vsync_counter                               ;

    ldx #11                                         ;
    ldy #8                                          ;
    jsr set_text_position                           ;

    ldy #0                                          ; loop counter
write_game_over_loop
colour_index = * + 1
    ldx #0                                          ;
    lda next_index,x                                ;
    sta colour_index                                ;
    tax                                             ;
    lda colour_array,x                              ;
    sta text_colour_mask                            ;
    lda game_over_string,Y                          ;
    jsr write_char                                  ;
    iny                                             ;
    cpy #game_over_string_end - game_over_string    ;
    bne write_game_over_loop                        ;

    dec game_over_timer                             ;
    bne game_over_loop                              ;
    jmp real_entry_point                            ;

check_for_game_exit
    lda keyStateShift                               ;
    beq leave7                                      ;
    lda keyStateEscape                              ;
    beq leave7                                      ;
    pla                                             ; Remove check_for_game_exit from stack
    pla                                             ;
    jmp real_entry_point                            ;
leave7
    rts                                             ;

; ***************************************************************************************
game_over_string
    !convtab "string_table.bin" {
        !text "Game"                            ;
        !byte charTab                           ;
        !byte charTab                           ;
        !text "Over"                            ;
    }
game_over_string_end

; ***************************************************************************************
start_sound_x
    txa                                         ;
    tay                                         ; Y = X
    lda channel_for_sound_x,X                   ;
    tax                                         ;
    lda initial_pitch_low_for_sound_x,Y         ;
    sta pitch_low,X                             ;
    lda initial_pitch_high_for_sound_x,Y        ;
    sta pitch_high,X                            ;
    lda #1                                      ;
    sta sound_counters,X                        ;
    lda duration_for_sound_x,Y                  ;
    sta sound_duration_for_channel_x,X          ;
    lda pitch_increment_for_sound_x,Y           ;
    sta pitch_increment_for_channel_x,X         ;
return1
    rts                                         ;

; ***************************************************************************************
update_channel_x
    lda sound_counters,X                        ;
    beq return1                                 ;
    lda pitch_low,X                             ;
    sec                                         ;
    sbc pitch_increment_for_channel_x,X         ;
    sta pitch_low,X                             ;
    bcs +                                       ;
    dec pitch_high,X                            ;
+                                               ;
    inc sound_counters,X                        ;
    lda sound_counters,X                        ;
    cmp sound_duration_for_channel_x,X          ;
    bne +                                       ;
    lda #0                                      ;
    sta sound_counters,X                        ;
    lda #0                                      ;
    jmp set_volume                              ;
+
    ; calculate bytes to send to sound chip
    lda pitch_low,X                             ;
    and #$0f                                    ;
    ora first_byte_upper,X                      ; 'OR' in upper nybble of the first byte
    sta first_sound_byte                        ;

    lda pitch_high,X                            ;
    asl                                         ;
    asl                                         ;
    asl                                         ;
    asl                                         ;
    sta temp_sound_byte                         ;
    lda pitch_low,X                             ;
    lsr                                         ;
    lsr                                         ;
    lsr                                         ;
    lsr                                         ;
temp_sound_byte = * + 1
    ora #$ff                                    ;
    sta second_sound_byte                       ;

    ; send bytes to sound chip
    lda first_sound_byte                        ;
    jsr send_to_sound_chip                      ;
    cpx #0                                      ;
    beq +                                       ;
    lda second_sound_byte                       ;
    jsr send_to_sound_chip                      ;
+

    ; check for fade in
    lda sound_counters,X                        ; time sound has been playing
    asl                                         ;
    cmp sound_volume_for_channel,X              ;
    bcc set_volume                              ;

    ; check for end of sound, to fade out
    sec                                         ;
    sbc sound_duration_for_channel_x,X          ;
    sbc sound_duration_for_channel_x,X          ;
    clc                                         ;
    adc #8                                      ;
    cmp #8                                      ;
    bcs full_volume                             ;
    sta diff                                    ;
    lda sound_volume_for_channel,X              ;
    sec                                         ;
diff = * + 1
    sbc #$ff                                    ;
set_volume
    eor volume_byte_for_channel,X               ;
    jmp send_to_sound_chip                      ;

full_volume
    lda sound_volume_for_channel,X              ;
    jmp set_volume                              ;

; ***************************************************************************************
update_sound
    ldx #3                                      ;
-
    stx temp_channel_x                          ;
    jsr update_channel_x                        ;
temp_channel_x = * + 1
    ldx #$ff                                    ;
    dex                                         ;
    bpl -                                       ;
    rts                                         ;

; ***************************************************************************************
scroll_scrolltext
    ldx #>(text_message_address - $10)              ;
    stx target_address_high                         ; Target: $57f0 = $5800 - $10
    ldx #>(text_message_address + 8 - $10)          ; Source: $57f8 = $5808 - $10
    stx source_address_high                         ;
    ldy #$10                                        ;
    lda #2                                          ;
    sta blocks_to_copy                              ;
    ldx #$f8                                        ;
scroll_scrolltext_loop
source_address_high = * + 2
    lda text_message_address + 8 - $10,Y            ;
target_address_high = * + 2
    sta text_message_address - $10,Y                ;
    iny                                             ;
    bne +                                           ;
    inc target_address_high                         ;
    inc source_address_high                         ;
+
    dex                                             ;
    bne scroll_scrolltext_loop                      ;
    dec blocks_to_copy                              ;
    bne scroll_scrolltext_loop                      ;

    lda #0                                          ;
    ldx #7                                          ;
-
    sta text_message_address + $1f8,x               ;
    dex                                             ;
    bpl -                                           ;
    rts                                             ;

; ***************************************************************************************
plot_title_screen_logo
    ldx #2                                          ;
    ldy #15                                         ;
    jsr set_text_position                           ; TAB
    ldy #0                                          ;
-
    lda title_message,Y                             ;
    jsr write_char                                  ;
    iny                                             ;
    cpy #title_message_end - title_message          ;
    bne -                                           ;

    ldx #0                                          ;
    ldy #1                                          ; TAB
    jsr set_text_position                           ;

    ldx #0                                          ;

plot_title_screen_logo_loop
    lda title_screen_logo,X                         ;
    sta blocks_to_copy                              ;
    ldy #7                                          ; loop counter
unpack_byte_loop
    asl blocks_to_copy                              ;
    bcc skip_block                                  ;

    ; draw block
    lda #charFuzzy                                  ;
next_byte
    jsr write_char                                  ;
    dey                                             ;
    bpl unpack_byte_loop                            ;
    inx                                             ;
    cpx #title_screen_logo_end - title_screen_logo  ;
    bne plot_title_screen_logo_loop                 ;

    rts                                             ;

skip_block
    lda #charTab                                    ;
    jmp next_byte                                   ;

title_message
    !convtab "string_table.bin" {
        !text "2021 Edition by TobyLobster"
    }
title_message_end


; ***************************************************************************************
clear_room_palette_changes
    ldy #15                                         ;
    lda #$ff                                        ;
-
    sta palette_changes, Y                          ;
    dey                                             ;
    bpl -                                           ;
    rts                                             ;

; ***************************************************************************************
set_full_room_palette
    clc                                             ;
    adc #3                                          ;
    tax                                             ;
    ldy #3                                          ;
-
    lda room_palette,X                              ;
    sta room_palette,Y                              ;
    dex                                             ;
    dey                                             ;
    bpl -                                           ;
    rts                                             ;

colour_cycler
    !byte 1

colour_cycles
    !byte magenta, yellow, red, cyan, blue, green

; ***************************************************************************************
update_colour_cycler
    sty temp_y_value                                ;
    ldy colour_cycler                               ;
    lda colour_cycles - 1,Y                         ;
temp_y_value = * + 1
    ldy #$ff                                        ;
    sta colour_cycler                               ;
    rts                                             ;

; ***************************************************************************************
title_change_palette
    lda game_timer                                  ;
    and #1                                          ;
    bne skip_title_colour_change                    ;

    ldy #1                                          ; loop counter
-
    jsr update_colour_cycler                        ;

    asl                                             ;
    asl                                             ;
    clc                                             ;
    adc #2                                          ;
    sta palette_changes, Y                          ;
    iny                                             ;
    cpy #13                                         ;
    bne -                                           ;

    ; move colour cycler on
    ldx #5                                          ;
-
    jsr update_colour_cycler                        ;
    dex                                             ;
    bne -                                           ;

skip_title_colour_change
    rts                                             ;

; ***************************************************************************************
start_tune_y
    lda #40                                         ;
    sta pre_tune_delay                              ;
    ldx #0                                          ;
    sty tune_number                                 ;
    cpy #0                                          ;
    beq +                                           ;
    ldx #255                                        ;
+
    stx tune_speed                                  ;
    lda #0                                          ;
    sta melody_active                               ; Temporarily make melody inactive
    jsr silence_tune                                ; while we change everything

    ldx #2                                          ;
-
    lda #1                                          ;
    sta note_length,X                               ;
    lda #0                                          ;
    sta note_number,X                               ;
    dex                                             ;
    bpl -                                           ;

    lda #1                                          ; Make melody active again
    sta melody_active                               ;
    rts                                             ;

; ***************************************************************************************
title_screen
    lda #$88                                        ;
    sta life_y                                      ;

    ldy #1                                          ;
    jsr start_tune_y                                ; Start Moonlight Sonata
    lda #16                                         ; Title screen has full line of lives
    sta player_lives                                ;
    jsr clear_screen                                ;

    jsr clear_room_palette_changes                  ;
    lda #2 + 4 * green                              ;
    sta palette_changes + 13                        ;

    lda #title_palette - start_of_palettes          ;
    jsr set_full_room_palette                       ;

    lda #$f0                                        ;
    sta text_colour_mask                            ; colour 3
    jsr plot_title_screen_logo                      ;
    lda #$ff                                        ;
    sta text_colour_mask                            ; Use colour 3 for scrolltext

    lda #>title_screen_press_space                  ;
    sta scrolltext_address_high                     ;
    lda #<title_screen_press_space                  ;
    sta scrolltext_address_low                      ;
    lda #0                                          ;
    sta title_delay_before_restart                  ;

    jmp scroll_the_message                          ;

restart_scrolltext
    lda #>title_screen_scrolltext                   ;
    sta scrolltext_address_high                     ;
    lda #<title_screen_scrolltext                   ;
    sta scrolltext_address_low                      ;
    lda #0                                          ;
    sta title_delay_before_restart                  ;

scroll_the_message
    ldy #0                                          ;
    sty scrolltext_offset                           ;
title_screen_loop
    inc replay_timer                                ;
    lda title_delay_before_restart                  ; are we delaying?
    beq +                                           ;
    dec title_delay_before_restart                  ;
    beq restart_scrolltext                          ;
    bne wait_for_vsyncs                             ; ALWAYS branch
+
    ldx #31                                         ;
    ldy #20                                         ; TAB(30,20)
    jsr set_text_position                           ;

    lda game_timer                                  ;
    and #1                                          ;
    bne wait_for_vsyncs                             ;
    ldy scrolltext_offset                           ;
    lda (scrolltext_address_low),Y                  ; Write character of scrolltext
    cmp #255                                        ;
    beq end_of_scrolltext                           ;
    jsr write_char                                  ;
    inc scrolltext_offset                           ;
    bne ++                                          ; move on to next character
    inc scrolltext_address_high                     ;
++

wait_for_vsyncs
    lda vsync_counter                               ;
    cmp #2                                          ;
    bcs +                                           ;
    jsr check_for_space_bar                         ;
    jmp wait_for_vsyncs                             ;
+
    lda #0                                          ;
    sta vsync_counter                               ;

    ; --- delay ---
    ldx #2                                          ;
    jsr delay                                       ;

    jsr title_change_palette                        ;
    lda title_delay_before_restart                  ; are we delaying?
    bne +                                           ;
    jsr scroll_scrolltext                           ;
+
    inc game_timer                                  ;
    jsr update_lives                                ; Animate lives
    jsr check_for_space_bar                         ;
    jsr check_for_q_and_s_keys                      ;
    jmp title_screen_loop                           ;

; ***************************************************************************************
end_of_scrolltext
    lda #$80                                        ;
    sta title_delay_before_restart                  ;
    jmp title_screen_loop                           ;

check_for_space_bar
    jsr read_keys                                   ;
    lda keyStateSpace                               ;
    beq leave                                       ;
    lda #$8c                                        ;
    sta life_y                                      ;
    pla                                             ; Leave title_screen when SPACE pressed
    pla                                             ;
leave
    rts                                             ;

; ***************************************************************************************
title_screen_scrolltext
    !convtab "string_table.bin" {
        !text "...Jet Set Willy was written for the BBC Micro by Chris Robson..."
        !text "...Jet Set Willy was prepared by Tynesoft under licence from Software Projects "
        !text "and is copyright to Software Projects..."
        !text "...You must guide Willy to collect all the items around the house before "
        !text "midnight so that Maria will let you go to bed..."
title_screen_press_space
        !text "  ++++ Press SPACE to start ++++"
    }
title_screen_scrolltext_end
    !byte 255

; ***************************************************************************************
title_screen_logo
    !be32 %....###.###.###..###.###.###....
    !be32 %.....#..#....#...#...#....#.....
    !be32 %.....#..###..#...###.###..#.....
    !be32 %.....#..#....#.....#.#....#.....
    !be32 %....##..###..#...###.###..#.....
    !be32 %................................
    !be32 %................................
    !be32 %......#...#.#.#...#..#...#......
    !be32 %......#...#.#.#...#..#...#......
    !be32 %......#.#.#.#.#...#..#####......
    !be32 %......#.#.#.#.#...#....#........
    !be32 %......#####.#.###.###..#........

title_screen_logo_end

moonlight1_table
    +note cs5, 1        ; measure 1
    +note fs5, 1
    +note a5, 1
    +note cs5, 1
    +note fs5, 1
    +note a5, 1
    +note cs5, 1
    +note fs5, 1
    +note a5, 1
    +note cs5, 1
    +note fs5, 1
    +note a5, 1
    +note cs5, 1        ; measure 2
    +note fs5, 1
    +note a5, 1
    +note cs5, 1
    +note fs5, 1
    +note a5, 1
    +note cs5, 1
    +note fs5, 1
    +note a5, 1
    +note cs5, 1
    +note fs5, 1
    +note a5, 1
    +note d5, 1        ; measure 3
    +note fs5, 1
    +note a5, 1
    +note d5, 1
    +note fs5, 1
    +note a5, 1
    +note d5, 1
    +note g5, 1
    +note b5, 1
    +note d5, 1
    +note g5, 1
    +note b5, 1
    +note cs5, 1        ; measure 4
    +note es5, 1
    +note b5, 1
    +note cs5, 1
    +note fs5, 1
    +note a5, 1
    +note cs5, 1
    +note fs5, 1
    +note gs5, 1
    +note b4, 1
    +note es5, 1
    +note gs5, 1
    +note a4, 1         ; measure 5
    +note cs5, 1
    +note fs5, 1
    +note cs5, 1
    +note fs5, 1
    +note a5, 1
    +note cs5, 1
    +note fs5, 1
    +note a5, 1
    +note cs5, 1
    +note fs5, 1
    +note a5, 1
    +note cs5, 1         ; measure 6
    +note gs5, 1
    +note b5, 1
    +note cs5, 1
    +note gs5, 1
    +note b5, 1
    +note cs5, 1
    +note gs5, 1
    +note b5, 1
    +note cs5, 1
    +note gs5, 1
    +note b5, 1
    +note cs5, 1        ; measure 7
    +note fs5, 1
    +note a5, 1
    +note cs5, 1
    +note fs5, 1
    +note a5, 1
    +note d5, 1
    +note fs5, 1
    +note b5, 1
    +note d5, 1
    +note fs5, 1
    +note b5, 1
    +note cs5, 1        ; measure 8
    +note e5, 1
    +note a5, 1
    +note cs5, 1
    +note e5, 1
    +note a5, 1
    +note d5, 1
    +note e5, 1
    +note gs5, 1
    +note d5, 1
    +note e5, 1
    +note gs5, 1
    +note cs5, 12        ; measure 9
    +note non, 12        ; measure 10
    +end_melody

moonlight2_table
    +note fs4, 12        ; measure 1
    +note e4,  12        ; measure 2
    +note d4,  6         ; measure 3
    +note b3,  6
    +note cs4, 6         ; measure 4
    +note cs4, 6
    +note fs3, 12        ; measure 5
    +note es3, 12        ; measure 6
    +note fs3, 6         ; measure 7
    +note b2, 6
    +note e3, 6          ; measure 8
    +note e3, 6
    +note a3, 12         ; measure 9
    +note non, 12        ; measure 10
    +end_melody

moonlight3_table
    +note fs3, 12        ; measure 1
    +note e3,  12        ; measure 2
    +note d3,  6         ; measure 3
    +note b2,  6
    +note cs3, 6         ; measure 4
    +note cs3, 6
    +note non, 9         ; measure 5
    +note cs6, 2
    +note cs6, 1
    +note cs6, 9         ; measure 6
    +note cs6, 2
    +note cs6, 1
    +note cs6, 6         ; measure 7
    +note d6, 6
    +note cs6, 6         ; measure 8
    +note b5, 3
    +note e6, 3
    +note a5, 12         ; measure 9
    +note non, 12        ; measure 10
    +end_melody
moonlight_table_end

; ***************************************************************************************
channels_in_each_tune
    !byte 0
    !byte 2

channel_pitch_adjust
    !byte 0
    !byte 32
    !byte 64

duration_table
    !byte 1*18,2*18,3*18,4*18,6*18,7*18,9*18,12*18

tune_addresses_low
    !byte <rich_man_table                           ;
    !byte <moonlight1_table                         ;
    !byte <moonlight2_table                         ;
    !byte <moonlight3_table                         ;
tune_addresses_high
    !byte >rich_man_table                           ;
    !byte >moonlight1_table                         ;
    !byte >moonlight2_table                         ;
    !byte >moonlight3_table                         ;

; ***************************************************************************************
silence_tune
    ldy #2                                          ;
-
    jsr play_silence_on_channel_y                   ;
    dey                                             ;
    bpl -                                           ;
    rts                                             ;

; ***************************************************************************************
update_music
    dec music_timer                                 ;
    lda melody_active                               ;
    beq leave29                                     ;
    lda pre_tune_delay                              ;
    beq +                                           ;
    dec pre_tune_delay                              ;
    rts                                             ;
+
    ldy tune_number                                 ;
    lda channels_in_each_tune,Y                     ;
    tay                                             ;
-
    jsr update_music_channel_y                      ;
    dey                                             ;
    bpl -                                           ;
leave29
    rts                                             ;

update_music_channel_y
    lda music_enabled                               ;
    beq leave29                                     ;
    ldx note_length,Y                               ;
    dex
    stx note_length,Y                               ;
    bne set_melody_vol                              ;

    tya                                             ;
    clc                                             ;
    adc tune_number                                 ;
    tax                                             ;
    lda tune_addresses_low,X                        ;
    sta tune_address1_low                           ;
    sta tune_address2_low                           ;
    lda tune_addresses_high,X                       ;
    sta tune_address1_high                          ;
    sta tune_address2_high                          ;

    ldx note_number,Y                               ;
tune_address1_low  = * + 1
tune_address1_high = * + 2
    lda rich_man_table,X                            ;
    sta music_note_byte                             ; push music byte
    lsr                                             ;
    lsr                                             ;
    lsr                                             ;
    lsr                                             ;
    lsr                                             ;
    tax                                             ;
    lda duration_table,X                            ;
    ldx note_number,Y                               ;
    bit tune_speed                                  ;
    bmi +                                           ;
    lsr                                             ;
+
    sta note_length,Y                               ;
    lda music_note_byte                             ; music byte
    and #$1f                                        ;
    cmp #non                                        ;
    beq start_rapid_decay                           ;
    ldx #1                                          ;
    stx note_decay_amount,Y                         ;
    tax                                             ;
    lda pitch_table_first,X                         ;
    clc                                             ;
    adc channel_pitch_adjust,Y                      ;
    jsr send_to_sound_chip                          ; first byte
    lda pitch_table_second,X                        ;
    jsr send_to_sound_chip                          ; second byte

    lda #11 * 4                                     ; initial volume
    sta note_volume,Y                               ;

next_note
    ldx note_number,Y                               ;
    inx                                             ;
    stx note_number,Y                               ;
tune_address2_low  = * + 1
tune_address2_high = * + 2
    lda rich_man_table,X                            ;
    cmp #0                                          ;
    bne set_melody_vol                              ;

    ; restart tune
    lda #0                                          ;
    sta note_number,Y                               ;
    lda #1                                          ;
    sta note_length,Y                               ;
set_melody_vol
    ; set volume of playing note
    ; To set volume V (0-15) on channel C (0-2, or 3=noise):
    ; write volume byte:  128 + 32*C + 16 + volume (0-15, 0 = loudest)

    lda note_volume,Y                               ;
    lsr                                             ;
    lsr                                             ;
    eor volume_for_channel,Y                        ;
    jsr send_to_sound_chip                          ; volume byte

    ; update volume
    cpy #0                                          ;
    beq +                                           ; if (channel 0) then branch (decay at normal rate)
    lda music_timer                                 ; }
    and #3                                          ; } decay slowly
    bne leave31                                     ; }
+
    lda note_volume,Y                               ;
    sec
    sbc note_decay_amount,Y                         ;
    sta note_volume,Y                               ;

    lda note_volume,Y                               ;
    bpl leave31                                     ;

    lda #0                                          ;
    sta note_volume,Y                               ;
leave31
    rts                                             ;

start_rapid_decay
    lda #4                                          ;
    sta note_decay_amount,Y                         ;
    bne next_note                                   ;

; ***************************************************************************************
check_for_q_and_s_keys
    lda keyStateS                                   ;
    beq s_not_pressed                               ;
    lda #1                                          ;
    sta music_enabled                               ;
s_not_pressed
    lda keyStateQ                                   ;
    beq q_not_pressed                               ;
    lda #0                                          ;
    sta music_enabled                               ;
    jmp silence_tune                                ;
play_silence_on_channel_y
    lda volume_for_channel,Y                        ;
    jsr send_to_sound_chip                          ; volume byte
q_not_pressed
    rts                                             ;

; ***************************************************************************************
volume_for_channel
    !byte $9f                                       ;
    !byte $bf                                       ;
    !byte $df                                       ;

; ***************************************************************************************
; Change the appearance of logical colour Y to physical colour A
set_logical_colour_y_to_a
    eor #7                                          ;
    ora paletteLookupTable,Y                        ;
    sta videoULAPaletteRegister                     ; store actual colour in register
    eor #$10                                        ;
    sta videoULAPaletteRegister                     ; store actual colour in register
    eor #$50                                        ;
    sta videoULAPaletteRegister                     ; store actual colour in register
    eor #$10                                        ;
    sta videoULAPaletteRegister                     ; store actual colour in register
    rts                                             ;

; ***************************************************************************************
irq_routine
    txa                                             ;
    pha                                             ;
    tya                                             ;
    pha                                             ;

    lda systemVIAInterruptFlagRegister              ; get interrupt flag register
    and #$c0                                        ;
    cmp #$c0                                        ;
    bne exit_irq                                    ; unknown interrupt
    sta systemVIAInterruptFlagRegister              ; clear interrupt

    ldx irq_counter                                 ;
    inx                                             ;
    cpx #39                                         ;
    bcc +                                           ;
    jsr update_sound                                ; update all audio
    jsr update_music                                ;
    ldx #0                                          ;
+
    stx irq_counter                                 ;
    cpx #16                                         ;
    bne +                                           ;
    inc vsync_counter                               ;
    lda #4                                          ; change to footer palette
    jmp change_all_palette                          ;

+
    bcs +                                           ;
    ; apply palette changes in rows 0-15
    lda palette_changes,X                           ;
    bmi exit_irq                                    ;
    and #3                                          ;
    tay                                             ;
    lda palette_changes,X                           ;
    lsr                                             ;
    lsr                                             ;
    jsr set_logical_colour_y_to_a                   ;

+
    cpx #20                                         ;
    bne +                                           ;

    ; final row
    ldy #3                                          ;
    lda #white                                      ;
    jsr set_logical_colour_y_to_a                   ;

+
    cpx #21                                         ;
    bne exit_irq                                    ;

change_all_room_palette
    lda #0                                          ; change to room palette
+
change_all_palette
    clc                                             ;
    adc #<room_palette                              ;
    sta change_palette_low                          ;
    ldy #0                                          ;
-
change_palette_low = * + 1
    lda room_palette,Y                              ;
    jsr set_logical_colour_y_to_a                   ;
    iny                                             ;
    cpy #4                                          ;
    bne -                                           ;

exit_irq
    pla                                             ;
    tay                                             ;
    pla                                             ;
    tax                                             ;
    lda irq_accumulator                             ;
    rti                                             ;

!if ((>room_palette) != (>(room_palette + 4))) {
    !error "Alignment of room_palette is wrong"
}


; ***************************************************************************************
; per channel information
; constants
sound_volume_for_channel
    !byte 11
    !byte 15
    !byte 14
    !byte 11
volume_byte_for_channel
    !byte $ff
    !byte $df
    !byte $bf
    !byte $9f
first_byte_upper
    !byte $e0
    !byte $c0
    !byte $a0
    !byte $80

; ***************************************************************************************
; per sound information
channel_for_sound_x
    !byte 1                 ; 0 : jump
    !byte 0                 ; 1 : arrow
    !byte 2                 ; 2 : item collection
    !byte 1                 ; 3 : game over
    !byte 0                 ; 4 : dying 1
    !byte 1                 ; 5 : dying 2

initial_pitch_low_for_sound_x
    !byte <347              ; 0 : jump
    !byte <5                ; 1 : arrow
    !byte <85               ; 2 : item collection
    !byte <600              ; 3 : game over
    !byte <5                ; 4 : dying 1
    !byte <100              ; 5 : dying 2

initial_pitch_high_for_sound_x
    !byte >347              ; 0 : jump
    !byte >5                ; 1 : arrow
    !byte >85               ; 2 : item collection
    !byte >600              ; 3 : game over
    !byte >5                ; 4 : dying 1
    !byte >100              ; 5 : dying 2

duration_for_sound_x
    !byte 28                ; 0 : jump
    !byte 7                 ; 1 : arrow
    !byte 20                ; 2 : item collection
    !byte 70                ; 3 : game over
    !byte 10                ; 4 : dying 1
    !byte 10                ; 5 : dying 2

pitch_increment_for_sound_x
    !byte 10                ; 0 : jump
    !byte 0                 ; 1 : arrow
    !byte 0                 ; 2 : item collection
    !byte 8                 ; 3 : game over
    !byte 0                 ; 4 : dying 1
    !byte 10                ; 5 : dying 2

; ***************************************************************************************
plot_enemies
    ldx enemies_on_screen                           ;
    beq leave11                                     ;
    stx enemy_to_consider2                          ;
plot_enemies_loop
    dec enemies_need_replot,X                       ;
    bne skip_enemy                                  ;
    jsr calculate_enemy_sprite_address              ;
    jsr plot_enemy                                  ;
    jsr wipe_space_vacated_by_enemy                 ;
skip_enemy
    dec enemy_to_consider2                          ;
    ldx enemy_to_consider2                          ;
    bne plot_enemies_loop                           ;
leave11
    rts                                             ;

; ***************************************************************************************
; Each pixel of the rope is at an offset from the previous one.
; X and Y offsets are given in the following two tables.
; The rope is animated by starting to draw the rope at different offsets into these tables
; (a sliding window). The first set of entries in each table are all the same so we deal
; with that in code. The full uncompressed table is 86 entries:
;
; rope_position    dx    dy
; -------------------------
; $d4               0     3
; $d5               0     3
; $d6               0     3
; $d7               0     3
; $d8               0     3
; $d9               0     3
; $da               0     3
; $db               0     3
; $dc               0     3
; $dd               0     3
; $de               0     3
; $df               0     3
; $e0               0     3
; $e1               0     3
; $e2               0     3
; $e3               0     3
; $e4               0     3
; $e5               0     3
; $e6               0     3
; $e7               0     3
; $e8               0     3
; $e9               0     3
; $ea               0     3
; $eb               0     3
; $ec               0     3
; $ed               0     3
; $ee               0     3
; $ef               0     3
; $f0               0     3
; $f1               0     3
; $f2               0     3
; $f3               0     3
; $f4               1     3
; $f5               1     3
; $f6               1     3
; $f7               1     3
; $f8               1     3
; $f9               1     3
; $fa               1     3
; $fb               1     3
; $fc               1     3
; $fd               1     3
; $fe               1     3
; $ff               1     3
; $00               2     3
; $01               2     3
; $02               2     3
; $03               2     3
; $04               2     2
; $05               2     3
; $06               2     3
; $07               2     2
; $08               2     3
; $09               2     2
; $0a               2     3
; $0b               2     2
; $0c               2     3
; $0d               2     2
; $0e               2     2
; $0f               2     2
; $10               2     3
; $11               2     2
; $12               2     2
; $13               2     2
; $14               2     2
; $15               2     2
; $16               1     2
; $17               2     2
; $18               2     2
; $19               1     2
; $1a               1     2
; $1b               2     2
; $1c               1     2
; $1d               1     2
; $1e               2     2
; $1f               2     2
; $20               3     2
; $21               2     2
; $22               3     2
; $23               2     2
; $24               3     2
; $25               3     2
; $26               3     2
; $27               3     2
; $28               3     2
; $29               3     2
;
; ***************************************************************************************
rope_x_delta_table
    !byte 2,2,2,2, 2,2,2,2, 2,2,2,2, 2,2,2,2, 2,2,2,2
    !byte 2,2,1,2, 2,1,1,2, 1,1,2,2, 3,2,3,2, 3,3,3,3
    !byte 3,3
rope_x_delta_table_end
    !byte 1, 0          ; these values are used for the straight/almost straight part of the rope
    !byte 0             ; this value is used to update the position (0 = don't move) before the first pixel of the rope

rope_y_delta_table
    !byte 3,3,3,3, 2,3,3,2, 3,2,3,2, 3,2,2,2, 3,2,2,2
    !byte 2,2,2,2, 2,2,2,2, 2,2,2,2, 2,2,2,2, 2,2,2,2
    !byte 2,2
rope_y_delta_table_end
    !byte 3, 3          ; these values are used for the straight/almost straight part of the rope
    !byte 0             ; this value is used to update the position (0 = don't move) before the first pixel of the rope

; ***************************************************************************************
rope_pixels_x
    !byte 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0

; ***************************************************************************************
rope_pixels_y
    !byte 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0

; ***************************************************************************************
rope_pixels_screen_address_low_table
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)
    !byte <(screen_memory_start + $0100)

rope_pixels_screen_address_high_table
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)
    !byte >(screen_memory_start + $0100)

rope_pixels_mask_table
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0
    !byte 0

; ***************************************************************************************
; Tile types:
;  0 = PLATFORM
;  1 = WALL
;  2 = SLOPE
;  3 = CONVEYOR
;  4 = DEADLY
;  5 = SCENERY
;  6 = ITEM

background_tiles_colours_fg
    !byte $01, $02, $03, $03, $02, $00, $00 ;
background_tiles_colours_bg
    !byte $02, $00, $00, $00, $00, $00, $00 ;
background_tiles_sprites
    !byte $8d, $8e, $03, $90, $40, $91, $00 ;

; ***************************************************************************************
enemies_sprite
    !byte $00, $1c, $04, $02, $26, $1c, $0e, $00, $00

enemies_unpacked_sprite_offset
    !byte $00, $2a, $4d, $5a, $2e, $31, $31, $30, $0d

enemies_direction
    !byte $00, $00, $00, $ff, $00, $00, $00, $00, $00

player_x_in_enemies
enemies_x
    !byte $a8, $3a, $e0, $78, $6c, $2c, $94, $8a, $f8

player_y_in_enemies
enemies_y
    !byte $68, $18, $68, $70, $18, $48, $60, $ad, $40

player_speed
enemies_speed
    !byte $02, $fe, $00, $00, $fe, $02, $fe, $2c, $ce

enemies_minimum
    !byte $86, $00, $00, $78, $68, $10, $00, $bd, $26

enemies_maximum
    !byte $0c, $e8, $00, $78, $b0, $38, $a8, $8d, $81

enemies_colour
    !byte $0a, $02, $03, $01, $02, $01, $03, $20, $f1

enemies_previous_tile_address_low
    !byte $ff, $47, $9c, $00, $4d, $05, $72, $c9, $25

enemies_previous_speed
    !byte $d0, $fe, $00, $00, $fe, $02, $fe, $a5, $ec

; 1 = plot (normal)
; 2 = skip plot (once)
enemies_need_replot
    !byte $02, $ff, $ff, $00, $ff, $ff, $ff, $7c, $0a

enemy_has_moved
    !byte $c9, $00, $00, $01, $00, $00, $00, $7c, $0a

arrow_timer
    !byte $00, $00

arrow_y
    !byte $40, $40

items_screen_address_low
    !byte $70, $20, $40, $60, $70, $90, $b0, $c9, $a0, $d0, $06, $8d

items_screen_address_high
    !byte $4b, $49, $49, $49, $49, $49, $49, $68, $aa, $68, $85, $fc

exit_rooms
    !byte $14, $15, $15, $15

items_tile_address_low
    !byte $b7, $92, $94, $96, $97, $99, $9b, $68, $84, $08, $08, $08

items_tile_address_high
    !byte $6f, $6f, $6f, $6f, $6f, $6f, $6f, $08, $08, $08, $08, $08

colour_mask_values
life_colours
    !byte $00, $0f, $f0, $ff
end_of_real_code

!if (* > screen_memory_start) {
    !error "Code too long by ", * - screen_memory_start
}
free_before_screen = screen_memory_start - end_of_real_code

!pseudopc * - $0208 + $1100 {

; ***************************************************************************************
;
; everything from here on is initialisation code run only once, then becomes part of the
; screen memory.
;
; ***************************************************************************************


; ***************************************************************************************
entry_point
    lda #140                                        ;
    ldx #12                                         ; *TAPE
    jsr OSBYTE                                      ;

    lda #$c8                                        ; Write BREAK/ESCAPE effect
    ldx #3                                          ; Normal ESCAPE effect, Memory cleared on next reset
    jsr OSBYTE                                      ;

    lda #0                                          ;
    sta replay_timer                                ;

    sei                                             ;
    ldx #$ff                                        ; } reset the stack pointer
    txs                                             ; }

    lda #$aa                                        ; }
    ldx #0                                          ; }
-                                                   ; }
    dex                                             ; } just for debugging purposes, fill page 1
    sta $0100,X                                     ; } (below the stack) with $aa
    bne -                                           ; }

    ldx #copy_melody_end - copy_melody              ; }
-                                                   ; }
    dex                                             ; }
    lda copy_melody,X                               ; }
    sta $0100,X                                     ; }
    cpx #0                                          ; }
    bne -                                           ; }

    ; relocate code
    sei                                             ;
    ldy #<$1100                                     ;
    sty $70                                         ;
    ldx #>$1100                                     ;
    stx $71                                         ; Copy code from $1100 to $0208

    ldy #<$0208                                     ;
    sty $72                                         ;
    ldx #>$0208                                     ;
    stx $73                                         ;

    ldx #>(end_of_real_code - $0208 + $ff)          ; loop counter (copy as many pages as we need)
    ldy #0                                          ;
-
    lda ($70),y                                     ;
    sta ($72),y                                     ; copy a page of memory
    iny                                             ;
    bne -                                           ;

    inc $71                                         ;
    inc $73                                         ; increment high byte of source and destination

    dex                                             ; decrement loop counter
    bne -                                           ; if (not done yet) then branch back

    ; set custom mode 1
    ; Set hardware scrolling value
    lda #4                                          ; Set C0=0
    sta systemVIARegisterB                          ; Setting the address for hardware scrolling
    lda #13                                         ; Set C1=1
    sta systemVIARegisterB                          ; Set Hardware scrolling address (C0=1,C1=1 i.e. $3000)

    ; Set Video ULA register
    lda #%11011000                                  ;
    sta videoULARegister                            ; write to control register

    ; set video ULA
    lda #%11011000                                  ;
    sta videoULARegister                            ;

    ; Write to all 16 registers of the CRTC
    ldy #15                                         ;
write_CRTC_loop
    lda register_CRTC_array,Y                       ; A = value to write
    sty crtcAddressRegister                         ; Set CRTC address register to write into (0-15)
    sta crtcAddressWrite                            ; Write new value into register
    dey                                             ;
    bpl write_CRTC_loop                             ;

    ldx #initial_zero_page_values_end - initial_zero_page_values - 1 ; Copy initial_zero_page_values to zero page
copy_zero_page_values_loop                          ;
    lda initial_zero_page_values,X                  ;
    sta $4d,X                                       ;
    dex                                             ;
    bpl copy_zero_page_values_loop                  ;

    lda #1                                          ;
    sta music_enabled                               ;
    lda #1                                          ;
    sta tune_number                                 ;
    lda #0                                          ;
    ldx #sound_variables_end - sound_variables_start + 1 ;
-
    sta sound_variables_start,X                     ;
    dex                                             ;
    bpl -                                           ;

    LDA #$7f                                        ; }
    STA systemVIAInterruptEnableRegister            ; } Disable all interrupts
    cli                                             ;

    lda #<irq_routine                               ;
    sta irq1_vector_low                             ;
    lda #>irq_routine                               ;
    sta irq1_vector_high                            ;

    lda #$c0                                        ; Enable timer 1
    sta systemVIAInterruptEnableRegister            ; Interrupt enable register
    lda #$c0                                        ; Enable free run mode
    sta systemVIAAuxiliaryControlRegister           ; Auxiliary control register

    lda #<Timer1Value                               ;
    sta systemVIATimer1CounterLow                   ;
    ; Get high byte ready so we can write it as quickly as possible at the right moment
    ldx #>Timer1Value                               ;

    ; Wait for VSync without having to catch it from its IRQ
    lda #2                                          ;
    sta systemVIAInterruptFlagRegister              ; clear VSync flag
-
    bit systemVIAInterruptFlagRegister              ;
    beq -                                           ; poll VSync flag

    stx systemVIATimer1CounterHigh                  ; start Timer 1 counting
    sta systemVIAInterruptFlagRegister              ; clear VSync flag

    ; Set timer to fire every 'short time' (set latch)
    lda #<ShortTimerValue                           ;
    sta systemVIATimer1LatchLow                     ;
    lda #>ShortTimerValue                           ;
    sta systemVIATimer1LatchHigh                    ;

    lda #0                                          ;
    sta irq_counter                                 ;

    jmp real_entry_point                            ;

; ***************************************************************************************
register_CRTC_array
    !byte 127                                       ; R0 = Horizontal total register
    !byte 64                                        ; R1 = Horizontal displayed register
    !byte 86                                        ; R2 = Horizontal sync position register
    !byte 40                                        ; R3 = The sync width register
    !byte 38                                        ; R4 = Vertical total register
    !byte 0                                         ; R5 = Vertical total adjust register
    !byte 32 - 11                                   ; R6 = Vertical displayed register (number of visible character rows)
    !byte 35 - 5                                    ; R7 = Vertical sync position (*TV)
    !byte 0                                         ; R8 = Interlace and delay register
    !byte 7                                         ; R9 = Scan lines per character
    !byte $20                                       ; R10 = Cursor start register
    !byte 0                                         ; R11 = The cursor end register
    !byte >(screen_memory_start / 8)                ; R12 = Displayed screen start address/8 register (High)
    !byte <(screen_memory_start / 8)                ; R13 = Displayed screen start address/8 register (low)
    !byte 15                                        ; R14 = Cursor position register
    !byte 80                                        ; R15 = Cursor position register

; ***************************************************************************************
initial_zero_page_values
; $4d
    !byte $8c                                       ; $4d  life_y
    !byte $fb                                       ; $4e  space_tile
    !byte $01                                       ; $4f  swimming_pool_item_collected
    !byte $fd                                       ; $50  room_data_address_low
    !byte $2c                                       ; $51  room_data_address_high
    !byte $46                                       ; $52  room_data_offset
    !byte $01                                       ; $53  bits_remaining_in_room_data_byte
    !byte $00                                       ; $54  room_data_byte
    !byte $11                                       ; $55  player_room
    !byte $02                                       ; $56  pages_of_tile_table_remaining_when_finding_conveyor
    !byte $88                                       ; $57  game_timer
    !byte $04                                       ; $58  conveyor_length
    !byte $c0                                       ; $59  conveyor_screen_address_low
    !byte $45                                       ; $5a  conveyor_screen_address_high
    !byte $00                                       ; $5b  rope_position_relative_to_centre
    !byte $01                                       ; $5c  rope_velocity_relative_to_centre
    !byte $b9                                       ; $5d  rope_end_x
    !byte $48                                       ; $5e  rope_end_y
    !byte $d2                                       ; $5f  rope_position
    !byte $ef                                       ; $60  tile_address_low
    !byte $6e                                       ; $61  tile_address_high
    !byte $40                                       ; $62  where_player_fell_from
    !byte $00                                       ; $63  player_killed
    !byte $01                                       ; $64  player_is_jumping
    !byte $02                                       ; $65  player_jump_timer
    !byte $02                                       ; $66  items_in_room_minus_one
    !byte $07                                       ; $67  item_number
    !byte $80                                       ; $68  tile
    !byte $00                                       ; $69  player_conveyor_direction
    !byte $fe                                       ; $6a  conveyor_direction
    !byte $00                                       ; $6b  player_on_slope
    !byte $00                                       ; $6c  slope_direction
    !byte $00                                       ; $6d  do_triangle_ends
    !byte $ff                                       ; $6e  length
    !byte $00                                       ; $6f  room_contains_rope
    !byte $01                                       ; $70  scrolltext_address_low
    !byte $3e                                       ; $71  scrolltext_address_high
    !byte $05                                       ; $72  tile_type
    !byte $00                                       ; $73  [unused]
    !byte $00                                       ; $74  length
    !byte $00                                       ; $75  start_x / previous_x
    !byte $ff                                       ; $76  previous_y / height
    !byte $01                                       ; $77  x_delta
    !byte $01                                       ; $78  y_delta
    !byte $00                                       ; $79  width / enemy_to_consider
    !byte $ff                                       ; $7a  (various)
    !byte $81                                       ; $7b  (various)
    !byte $08                                       ; $7c  direction
    !byte $01                                       ; $7d  triangle_direction
    !byte $ff                                       ; $7e  x_skip
    !byte $00                                       ; $7f  triangle_length
    !byte $ff                                       ; $80  height
    !byte $f0                                       ; $81  previous_tile_type / previous_y / room / conveyor_colour
    !byte $01                                       ; $82  add_first_and_last
    !byte $08                                       ; $83  direction_base
    !byte $00                                       ; $84  unpacked_sprite_address_low
    !byte $75                                       ; $85  unpacked_sprite_address_high
    !byte $10                                       ; $86  unpacked_sprite_offset
    !byte $02                                       ; $87  enemies_on_screen
    !byte $aa                                       ; $88  unpacked_byte_two
    !byte $85                                       ; $89  sprite_colour
    !byte $00                                       ; $8a  enemy_to_consider
    !byte $00                                       ; $8b  player_started_jump
    !byte $78                                       ; $8c  player_x
    !byte $42                                       ; $8d  player_y
    !byte $00                                       ; $8e  player_horizontal_speed
    !byte $ff                                       ; $8f  [unused]
    !byte $f1                                       ; $90  screen_address_low
    !byte $44                                       ; $91  screen_address_high
    !byte $c0                                       ; $92  sprite_address_low
    !byte $72                                       ; $93  sprite_address_high
    !byte $3f                                       ; $94  sprite_size_in_bytes
    !byte $18                                       ; $95  sprite_width
    !byte $05                                       ; $96  (various)
    !byte $ff                                       ; $97  (various)
    !byte $07                                       ; $98  seven ; This value is used
    !byte $ff                                       ; $99  melody_active
    !byte $00                                       ; $9a  player_entered_room_falling_too_far
    !byte $07                                       ; $9b  player_lives
    !byte $00                                       ; $9c  player_not_plotted
    !byte $00                                       ; $9d  out_of_time
    !byte $00                                       ; $9e  house_clear
    !byte $00                                       ; $9f  player_rope_pixel
initial_zero_page_values_end

; ***************************************************************************************
copy_melody
!pseudopc $0100 {
; "If I were a Rich Man"
rich_man_table
    +note d5,  1        ; measure 1
    +note c5,  1
    +note d5,  1
    +note c5,  1
    +note b4,  2
    +note g4,  3

    +note non, 1        ; measure 2
    +note b4,  1
    +note c5,  1
    +note d5,  1
    +note c5,  1
    +note d5,  1
    +note c5,  1

    +note b4,  1        ; measure 3
    +note c5,  1
    +note d5,  1
    +note e5,  1
    +note es5, 1
    +note e5,  1
    +note es5, 1
    +note e5,  1

    +note d5,  4        ; measure 4
    +note non, 4

    +note ds5, 2        ; measure 5
    +note d5,  2
    +note cs5, 2
    +note c5,  2

    +note as4, 1        ; measure 6
    +note a4,  1
    +note g4,  1
    +note a4,  1
    +note as4, 3
    +note non, 1

    +note as4, 1        ; measure 7
    +note a4,  1
    +note g4,  1
    +note a4,  1
    +note as4, 2
    +note g4,  2

    +note d5,  4        ; measure 8
    +note non, 4

    +note d5,  1        ; measure 9
    +note c5,  1
    +note d5,  1
    +note c5,  1
    +note b4,  2
    +note g4,  3

    +note non, 1
    +note b4,  1        ; measure 10
    +note c5,  1
    +note d5,  1
    +note c5,  1
    +note d5,  1
    +note c5,  1

    +note b4,  1        ; measure 11
    +note c5,  1
    +note d5,  1
    +note e5,  1
    +note es5, 1
    +note e5,  1
    +note es5, 1
    +note e5,  1

    +note d5,  4        ; measure 12
    +note non, 4

    +note ds5, 2        ; measure 13
    +note d5,  2
    +note cs5, 2
    +note c5,  2

    +note as4, 1        ; measure 14
    +note a4,  1
    +note g4,  1
    +note a4,  1
    +note as4, 2
    +note non, 2

    +note as4, 1        ; measure 15
    +note a4,  1
    +note g4,  1
    +note as4, 1
    +note a4,  1
    +note g4,  1
    +note fs4, 1
    +note a4,  1

    +note g4,  2        ; measure 16
    +note non, 2
    +note b4,  4

    +note c5,  4        ; measure 17
    +note d5,  4

    +note ds5, 1        ; measure 18
    +note non, 1
    +note ds5, 2
    +note ds5, 2
    +note ds5, 2

    +note ds5, 2        ; measure 19
    +note es5, 1
    +note g5,  1
    +note es5, 2
    +note ds5, 2

    +note d5,  2        ; measure 20
    +note d5,  1
    +note d5,  1
    +note d5,  1
    +note c5,  1
    +note as4, 1
    +note c5,  1

    +note d5,  6        ; measure 21
    +note d5,  2

    +note c5,  1        ; measure 22
    +note non, 1
    +note c5,  2
    +note c5,  2
    +note c5,  2

    +note c5,  2        ; measure 23
    +note d5,  1
    +note ds5, 1
    +note d5,  3
    +note c5,  1

    +note b4,  4        ; measure 24
    +note non, 4

    +note b4,  2        ; measure 25
    +note c5,  2
    +note d5,  2

    +note ds5, 2        ; measure 26
    +note ds5, 2
    +note ds5, 2
    +note ds5, 2

    +note ds5, 2        ; measure 27
    +note es5, 1
    +note g5,  1
    +note es5, 2
    +note ds5, 2

    +note d5,  2        ; measure 28
    +note d5,  1
    +note d5,  1
    +note d5,  1
    +note c5,  1
    +note as4, 1
    +note c5,  1

    +note d5,  2        ; measure 29
    +note non, 4
    +note g4,  2

    +note c5,  2        ; measure 30
    +note c5,  2
    +note c5,  1
    +note c5,  2
    +note non, 1

    +note as4, 2        ; measure 31
    +note a4,  2
    +note g4,  2
    +note as4, 2

    +note d5,  7        ; measure 32
    +note non, 1

    +end_melody
rich_man_table_end

; write first byte:   128 + 32*C + bottom four bits of pitch P (0-15)
; write second byte:  top 6 bits of pitch P
!macro pitch_first_byte .pitch {
    !byte 128 + 32 * 0 + (.pitch % 16)
}

!macro pitch_second_byte .pitch {
    !byte .pitch / 16
}

; ***************************************************************************************
pitch_table_first
    +pitch_first_byte 1012         ;  123.52 Hz           B2  =  123.47 Hz            0.05 Hz
    +pitch_first_byte 902          ;  138.58 Hz           C#3 =  138.59 Hz            0.01 Hz
    +pitch_first_byte 851          ;  146.89 Hz           D3  =  146.83 Hz            0.05 Hz
    +pitch_first_byte 758          ;  164.91 Hz           E3  =  164.81 Hz            0.09 Hz
    +pitch_first_byte 716          ;  174.58 Hz           F3  =  174.61 Hz            0.03 Hz
    +pitch_first_byte 676          ;  184.91 Hz           F#3 =  185.00 Hz            0.09 Hz
    +pitch_first_byte 568          ;  220.07 Hz           A3  =  220.00 Hz            0.07 Hz
    +pitch_first_byte 506          ;  247.04 Hz           B3  =  246.94 Hz            0.09 Hz
    +pitch_first_byte 451          ;  277.16 Hz           C#4 =  277.18 Hz            0.02 Hz
    +pitch_first_byte 426          ;  293.43 Hz           D4  =  293.66 Hz            0.24 Hz
    +pitch_first_byte 379          ;  329.82 Hz           E4  =  329.63 Hz            0.19 Hz
    +pitch_first_byte 338          ;  369.82 Hz           F#4 =  369.99 Hz            0.17 Hz
    +pitch_first_byte 319          ;  391.85 Hz           G4  =  392.00 Hz            0.15 Hz
    +pitch_first_byte 301          ;  415.28 Hz           G#4 =  415.30 Hz            0.02 Hz
    +pitch_first_byte 284          ;  440.14 Hz           A4  =  440.00 Hz            0.14 Hz
    +pitch_first_byte 268          ;  466.42 Hz           A#4 =  466.16 Hz            0.25 Hz
    +pitch_first_byte 253          ;  494.07 Hz           B4  =  493.88 Hz            0.19 Hz
    +pitch_first_byte 239          ;  523.01 Hz           C5  =  523.25 Hz            0.24 Hz
    +pitch_first_byte 225          ;  555.56 Hz           C#5 =  554.37 Hz            1.19 Hz
    +pitch_first_byte 213          ;  586.85 Hz           D5  =  587.33 Hz            0.48 Hz
    +pitch_first_byte 201          ;  621.89 Hz           D#5 =  622.25 Hz            0.36 Hz
    +pitch_first_byte 190          ;  657.89 Hz           E5  =  659.26 Hz            1.36 Hz
    +pitch_first_byte 179          ;  698.32 Hz           F5  =  698.46 Hz            0.13 Hz
    +pitch_first_byte 169          ;  739.64 Hz           F#5 =  739.99 Hz            0.34 Hz
    +pitch_first_byte 159          ;  786.16 Hz           G5  =  783.99 Hz            2.17 Hz
    +pitch_first_byte 150          ;  833.33 Hz           G#5 =  830.61 Hz            2.72 Hz
    +pitch_first_byte 142          ;  880.28 Hz           A5  =  880.00 Hz            0.28 Hz
    +pitch_first_byte 127          ;  984.25 Hz           B5  =  987.77 Hz            3.51 Hz
    +pitch_first_byte 113          ; 1106.19 Hz           C#6 = 1108.73 Hz            2.54 Hz
    +pitch_first_byte 106          ; 1179.25 Hz           D6  = 1174.66 Hz            4.59 Hz
    +pitch_first_byte 95           ; 1315.79 Hz           E6  = 1318.51 Hz            2.72 Hz

pitch_table_second
    +pitch_second_byte 1012        ;  123.52 Hz           B2  =  123.47 Hz            0.05 Hz
    +pitch_second_byte 902         ;  138.58 Hz           C#3 =  138.59 Hz            0.01 Hz
    +pitch_second_byte 851         ;  146.89 Hz           D3  =  146.83 Hz            0.05 Hz
    +pitch_second_byte 758         ;  164.91 Hz           E3  =  164.81 Hz            0.09 Hz
    +pitch_second_byte 716         ;  174.58 Hz           F3  =  174.61 Hz            0.03 Hz
    +pitch_second_byte 676         ;  184.91 Hz           F#3 =  185.00 Hz            0.09 Hz
    +pitch_second_byte 568         ;  220.07 Hz           A3  =  220.00 Hz            0.07 Hz
    +pitch_second_byte 506         ;  247.04 Hz           B3  =  246.94 Hz            0.09 Hz
    +pitch_second_byte 451         ;  277.16 Hz           C#4 =  277.18 Hz            0.02 Hz
    +pitch_second_byte 426         ;  293.43 Hz           D4  =  293.66 Hz            0.24 Hz
    +pitch_second_byte 379         ;  329.82 Hz           E4  =  329.63 Hz            0.19 Hz
    +pitch_second_byte 338         ;  369.82 Hz           F#4 =  369.99 Hz            0.17 Hz
    +pitch_second_byte 319         ;  391.85 Hz           G4  =  392.00 Hz            0.15 Hz
    +pitch_second_byte 301         ;  415.28 Hz           G#4 =  415.30 Hz            0.02 Hz
    +pitch_second_byte 284         ;  440.14 Hz           A4  =  440.00 Hz            0.14 Hz
    +pitch_second_byte 268         ;  466.42 Hz           A#4 =  466.16 Hz            0.25 Hz
    +pitch_second_byte 253         ;  494.07 Hz           B4  =  493.88 Hz            0.19 Hz
    +pitch_second_byte 239         ;  523.01 Hz           C5  =  523.25 Hz            0.24 Hz
    +pitch_second_byte 225         ;  555.56 Hz           C#5 =  554.37 Hz            1.19 Hz
    +pitch_second_byte 213         ;  586.85 Hz           D5  =  587.33 Hz            0.48 Hz
    +pitch_second_byte 201         ;  621.89 Hz           D#5 =  622.25 Hz            0.36 Hz
    +pitch_second_byte 190         ;  657.89 Hz           E5  =  659.26 Hz            1.36 Hz
    +pitch_second_byte 179         ;  698.32 Hz           F5  =  698.46 Hz            0.13 Hz
    +pitch_second_byte 169         ;  739.64 Hz           F#5 =  739.99 Hz            0.34 Hz
    +pitch_second_byte 159         ;  786.16 Hz           G5  =  783.99 Hz            2.17 Hz
    +pitch_second_byte 150         ;  833.33 Hz           G#5 =  830.61 Hz            2.72 Hz
    +pitch_second_byte 142         ;  880.28 Hz           A5  =  880.00 Hz            0.28 Hz
    +pitch_second_byte 127         ;  984.25 Hz           B5  =  987.77 Hz            3.51 Hz
    +pitch_second_byte 113         ; 1106.19 Hz           C#6 = 1108.73 Hz            2.54 Hz
    +pitch_second_byte 106         ; 1179.25 Hz           D6  = 1174.66 Hz            4.59 Hz
    +pitch_second_byte 95          ; 1315.79 Hz           E6  = 1318.51 Hz            2.72 Hz
}
copy_melody_end
}

free_total = free_before_nmi + free_before_screen
